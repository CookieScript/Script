
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"));
local Players, Workspace, RS, Camera, HttpService, GuiService, VirtualInputManager, TweenService, CoreGui, Lighting, Uis, SoundService, LogService = game:GetService("Players"), cloneref(game:GetService("Workspace")), cloneref(game:GetService("RunService")), cloneref(game:GetService("Workspace").CurrentCamera), cloneref(game:GetService("HttpService")), cloneref(game:GetService("GuiService")), cloneref(game:GetService("VirtualInputManager")), cloneref(game:GetService("TweenService")), cloneref(game:GetService("CoreGui")), cloneref(game:GetService("Lighting")), cloneref(game:GetService("UserInputService")), cloneref(game:GetService("SoundService")), cloneref(game:GetService("LogService"));
local Client, Mouse, GuiOffset = Players.LocalPlayer, Players.LocalPlayer:GetMouse(), GuiService:GetGuiInset().Y;
local Script = {Variables={InVoid=false,LastTickInVoid=0,RealPosition=nil,LastUserInput=0},Connections={},Desync={}};
local Target = nil;
do
	local Game_LogService_MessageOut = LogService.MessageOut;
	local Current_Connections = {};
	local Hooked_Connections = {};
	local XVNP_LASTUPDATE = 0;
	local XVNP_UPDATEINTERVAL = 5;
	local XVNP_CONNECTIONSNIFFER;
	local function XVNP_L(CONNECTION)
		local s, e = pcall(function()
			local OPENAC_TABLE = debug.getupvalues(CONNECTION.Function)[9];
			local OPENAC_FUNCTION = OPENAC_TABLE[1];
			debug.setupvalue(OPENAC_FUNCTION, 14, function(...)
				return function(...)
					local args = {...};
					if ((type(args[1]) == "table") and args[1][1]) then
						pcall(function()
							if (type(args[1][1]) == "userdata") then
								args[1][1]:Disconnect();
								args[1][2]:Disconnect();
								args[1][3]:Disconnect();
								args[1][4]:Disconnect();
							end
						end);
					end
				end;
			end);
			debug.setupvalue(OPENAC_FUNCTION, 1, function(...)
				task.wait(200);
			end);
			hookfunction(OPENAC_FUNCTION, function(...)
				return {};
			end);
		end);
	end
	XVNP_CONNECTIONSNIFFER = RS.RenderStepped:Connect(function()
		if (#getconnections(Game_LogService_MessageOut) >= 2) then
			XVNP_CONNECTIONSNIFFER:Disconnect();
		end
		if ((tick() - XVNP_LASTUPDATE) >= XVNP_UPDATEINTERVAL) then
			XVNP_LASTUPDATE = tick();
			local OpenAc_Connections = getconnections(Game_LogService_MessageOut);
			for _, CONNECTION in OpenAc_Connections do
				if not table.find(Current_Connections, CONNECTION) then
					table.insert(Current_Connections, CONNECTION);
					table.insert(Hooked_Connections, CONNECTION);
					XVNP_L(CONNECTION);
				end
			end
		end
	end);
end
if cloneref(game:GetService("ReplicatedStorage")):FindFirstChild("OpenAC Replicated Folder") then
    for _, v in ipairs(getconnections(cloneref(game:GetService("LogService")).MessageOut)) do
        v:Disable()
    end

    cloneref(game:GetService("ReplicatedStorage"))["OpenAC Replicated Folder"]:Destroy()
end
-- // Services
local Players, Workspace, RS, Camera, HttpService, GuiService, VirtualInputManager, TweenService, CoreGui, Lighting, MarketplaceService, ReplicatedStorage, Uis, ContextActionService, Stats = cloneref(game:GetService("Players")), cloneref(game:GetService("Workspace")), cloneref(game:GetService("RunService")), cloneref(game:GetService("Workspace").CurrentCamera), cloneref(game:GetService("HttpService")), cloneref(game:GetService("GuiService")), cloneref(game:GetService("VirtualInputManager")), cloneref(game:GetService("TweenService")), cloneref(game:GetService("CoreGui")), cloneref(game:GetService("Lighting")), cloneref(game:GetService("MarketplaceService")), cloneref(game:GetService("ReplicatedStorage")), cloneref(game:GetService("UserInputService")), cloneref(game:GetService("ContextActionService")), cloneref(game:GetService("Stats"))
-- // Vars
local Client, Mouse = Players.LocalPlayer, Players.LocalPlayer:GetMouse()
local UID = (not LPH_OBFUSCATED and 1) or nil
local Script_Key, Script_Name = Script_Key or getgenv().Script_Key, "hvh gui"

local ResetMemoryCategory, SetMemoryCategory, SetUpvalueName, SetMetatable, ProfileBegin, GetMetatable, GetConstants, GetRegistry, GetUpvalues, GetConstant, SetConstant, GetUpvalue, ValidLevel, LoadModule, SetUpvalue, ProfileEnd, GetProtos, GetLocals, Traceback, SetStack, GetLocal, DumpHeap, GetProto, SetLocal, GetStack, GetFenv, GetInfo, Info = debug.resetmemorycategory, debug.setmemorycategory, debug.setupvaluename, debug.setmetatable, debug.profilebegin, debug.getmetatable, debug.getconstants, debug.getregistry, debug.getupvalues, debug.getconstant, debug.setconstant, debug.getupvalue, debug.validlevel, debug.loadmodule, debug.setupvalue, debug.profileend, debug.getprotos, debug.getlocals, debug.traceback, debug.setstack, debug.getlocal, debug.dumpheap, debug.getproto, debug.setlocal, debug.getstack, debug.getfenv, debug.getinfo, debug.info
local RandomSeed, Random, Frexp, Floor, Atan2, Log10, Noise, Round, Ldexp, Clamp, Sinh, Sign, Asin, Acos, Fmod, Huge, Tanh, Sqrt, Atan, Modf, Ceil, Cosh, Deg, Min, Log, Cos, Exp, Max, Rad, Abs, Pow, Sin, Tan, Pi = math.randomseed, math.random, math.frexp, math.floor, math.atan2, math.log10, math.noise, math.round, math.ldexp, math.clamp, math.sinh, math.sign, math.asin, math.acos, math.fmod, math.huge, math.tanh, math.sqrt, math.atan, math.modf, math.ceil, math.cosh, math.deg, math.min, math.log, math.cos, math.exp, math.max, math.rad, math.abs, math.pow, math.sin, math.tan, math.pi
local Foreachi, Isfrozen, Foreach, Insert, Remove, Concat, Freeze, Create, Unpack, Clear, Clone, Maxn, Move, Pack, Find, Sort, Getn = table.foreachi, table.isfrozen, table.foreach, table.insert, table.remove, table.concat, table.freeze, table.create, table.unpack, table.clear, table.clone, table.maxn, table.move, table.pack, table.find, table.sort, table.getn
local PackSize, Reverse, SUnpack, Gmatch, Format, Lower, Split, Match, Upper, Byte, Char, Pack, Gsub, SFind, Rep, Sub, Len = string.packsize, string.reverse, string.unpack, string.gmatch, string.format, string.lower, string.split, string.match, string.upper, string.byte, string.char, string.pack, string.gsub, string.find, string.rep, string.sub, string.len
local Isyieldable, Running, Status, Create, Resume, Close, Yield, Wrap = coroutine.isyieldable, coroutine.running, coroutine.status, coroutine.create, coroutine.resume, coroutine.close, coroutine.yield, coroutine.wrap
local Countlz, Rrotate, Replace, Lrotate, Countrz, Arshift, Extract, Lshift, Rshift, Btest, Band, Bnot, Bxor, Bor = bit32.countlz, bit32.rrotate, bit32.replace, bit32.lrotate, bit32.countrz, bit32.arshift, bit32.extract, bit32.lshift, bit32.rshift, bit32.btest, bit32.band, bit32.bnot, bit32.bxor, bit32.bor
local Desynchronize, Synchronize, Cancel, Delay, Defer, Spawn, Wait = task.desynchronize, task.synchronize, task.cancel, task.delay, task.defer, task.spawn, task.wait 
if not LPH_OBFUSCATED then
    getgenv().DEBUGLOL = true
    LPH_NO_VIRTUALIZE = function(...) return(...) end
    LPH_JIT_MAX = function(...) return(...) end
end
LPH_JIT_MAX(function()

local print = function(str)
    game.StarterGui:SetCore("SendNotification", {Title = "Info",Text = str ,Duration = 1,})
end
local error = function(str)
    game.StarterGui:SetCore("SendNotification", {Title = "Error",Text = str ,Duration = 1,})
end
local warn = function(str)
    game.StarterGui:SetCore("SendNotification", {Title = "warn",Text = str ,Duration = 1,})
end
local HOOKS = {}
function HOOKS.hoodmodded()
    for i,v in next, getgc(true) do
        if typeof(v)=="table" and rawget(v,"DoThings") then
            v.DoThings = function() end
        end
    end
end
function HOOKS.untitledhood()
    local LOLXD;LOLXD = hookmetamethod(game, "__namecall", function(self, ...)
                if not checkcaller() and getnamecallmethod() == "FireServer" then
                    if tostring(self.Name) == ".gg/untitledhood" then
                        local args = {...}
                        if tostring(args[1]) == "ForceDetect" or tostring(args[1]) == "TeleportDetect" or tostring(args[1]) == "GUI_CHECK" then
                            return 
                        end
                    end
                end
                return LOLXD(self, ...);
            end)
end

function HOOKS.Adonis()
    local getinfo = getinfo or debug.getinfo
    local DEBUG = false
    local Hooked = {}
    local Detected, Kill
    setthreadidentity(2)
    for i, v in getgc(true) do
        if typeof(v) == "table" then
            local DetectFunc = rawget(v, "Detected")
            local KillFunc = rawget(v, "Kill")
            if typeof(DetectFunc) == "function" and not Detected then
                Detected = DetectFunc
                local Old; Old = hookfunction(Detected, function(Action, Info, NoCrash)
                    if Action ~= "_" then
                        if DEBUG then
                            warn('Adonis AntiCheat flagged\nMethod: {Action}\nInfo: {Info}')
                        end
                    end
                    
                    return true
                end)
                Insert(Hooked, Detected)
            end

            if rawget(v, "Variables") and rawget(v, "Process") and typeof(KillFunc) == "function" and not Kill then
                Kill = KillFunc
                local Old; Old = hookfunction(Kill, function(Info)
                    if DEBUG then
                        warn('Adonis AntiCheat tried to kill (fallback): {Info}')
                    end
                end)
                Insert(Hooked, Kill)
            end
        end
    end
    local Old; Old = hookfunction(getrenv().debug.info, newcclosure(function(...)
        local LevelOrFunc, Info = ...
        if Detected and LevelOrFunc == Detected then
            if DEBUG then
                warn('Adonis AntiCheat sanity check detected and broken')
            end

            return Yield(Running())
        end
        
        return Old(...)
    end))

    local s, r pcall(function ()
        setthreadidentity(8)
    end)
    if not s then
        setthreadidentity(7)
    end
end

function HOOKS.AntiFindService()
    hookfunction(game.FindService, function()
        return false
    end)
end

function HOOKS.ANTIGC()
    local old; old = hookfunction((gcinfo or collectgarbage), function(...)
        if not checkcaller() then
            return Random(5000000,9000000)
        end
        return old(...)
    end)
end

function HOOKS.IDKK()
    setreadonly(getrenv().string, false)
    local old = Char
    getrenv().Char = function(...)
        if not checkcaller() then
            return wait(9e9)
        else
            return old(...)
        end
    end
end

function HOOKS.Dahood()
    local Old; Old = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(newcclosure(function(...)
        local args = {...}
        local Self, Event = args[1], args[2]
        if getnamecallmethod() == "FireServer" and game.IsA(Self, "RemoteEvent")  then
            if Find({"BreathingHAMON", "OneMoreTime", "BANREMOTE", "PERMAIDBAN", "KICKREMOTE", "BR_KICKPC", "BR_KICKMOBILE", "CHECKER_1", "TeleportDetect", "GUI_CHECK"}, Event) then
                return
            end
        end
        return Old(...)
    end)))
end
function HOOKS.AntiKick()
    local retardedshit; retardedshit = hookmetamethod(game, "__namecall", newcclosure(function(...)
        if Lower(getnamecallmethod()) == "kick" then
            return nil
        end
        return retardedshit(...)
    end))
end

if game.PlaceId == 2788229376 or game.PlaceId == 7213786345 or game.PlaceId == 16033173781 then
    HOOKS.Dahood()
elseif game.PlaceId == 5602055394 or game.PlaceId == 7951883376 then
    HOOKS.hoodmodded()
elseif game.PlaceId == 9183932460 or game.PlaceId == 9435785899 then
    HOOKS.untitledhood()
else
    HOOKS.Adonis()
    HOOKS.ANTIGC()
    HOOKS.AntiKick()
    HOOKS.AntiFindService()
    HOOKS.IDKK()
end




local Notificationslib = {}
local library = {
    drawings = {},
    objects = {},
    hidden = {},
    connections = {},
    pointers = {},
    began = {},
    ended = {},
    changed = {},
    colors = {},
    hovers = {},
    Relations = {},
    folders = {
        main = "ethh.lol",
        assets = "ethh.lol/Images",
        configs = "ethh.lol/Configs"
    },
    shared = {
        initialized = false,
        fps = 0,
        ping = 0
    }
}
local ETHH = {
    Configs = {},
    Luas = {},
    Locals = {
        ShiftTick = tick(),
        Shift = 0,
        LastPreviewUpdate = tick(),
    },
    Safe = false,
    Version = "Hvh Gui"
}
local Themes = {
    Default = {1, [[{"Outline":"000000","Accent":"5d3e98","LightText":"ffffff","DarkText":"afafaf","LightContrast":"1e1e1e","CursorOutline":"0a0a0a","DarkContrast":"141414","TextBorder":"000000","Inline":"323232"}]]},
    Abyss = {2, [[{"Outline":"0a0a0a","Accent":"8c87b4","LightText":"ffffff","DarkText":"afafaf","LightContrast":"1e1e1e","CursorOutline":"141414","DarkContrast":"141414","TextBorder":"0a0a0a","Inline":"2d2d2d"}]]},
    Fatality = {3, [[{"Outline":"0f0f28","Accent":"f00f50","LightText":"c8c8ff","DarkText":"afafaf","LightContrast":"231946","CursorOutline":"0f0f28","DarkContrast":"191432","TextBorder":"0a0a0a","Inline":"322850"}]]},
    Neverlose = {4, [[{"Outline":"000005","Accent":"00b4f0","LightText":"ffffff","DarkText":"afafaf","LightContrast":"000f1e","CursorOutline":"0f0f28","DarkContrast":"050514","TextBorder":"0a0a0a","Inline":"0a1e28"}]]},
    Aimware = {5, [[{"Outline":"000005","Accent":"c82828","LightText":"e8e8e8","DarkText":"afafaf","LightContrast":"2b2b2b","CursorOutline":"191919","DarkContrast":"191919","TextBorder":"0a0a0a","Inline":"373737"}]]},
    Youtube = {6, [[{"Outline":"000000","Accent":"ff0000","LightText":"f1f1f1","DarkText":"aaaaaa","LightContrast":"232323","CursorOutline":"121212","DarkContrast":"0f0f0f","TextBorder":"121212","Inline":"393939"}]]},
    Gamesense = {7, [[{"Outline":"000000","Accent":"a7d94d","LightText":"ffffff","DarkText":"afafaf","LightContrast":"171717","CursorOutline":"141414","DarkContrast":"0c0c0c","TextBorder":"141414","Inline":"282828"}]]},
    Onetap = {8, [[{"Outline":"000000","Accent":"dda85d","LightText":"d6d9e0","DarkText":"afafaf","LightContrast":"2c3037","CursorOutline":"000000","DarkContrast":"1f2125","TextBorder":"000000","Inline":"4e5158"}]]},
    Entropy = {9, [[{"Outline":"0a0a0a","Accent":"81bbe9","LightText":"dcdcdc","DarkText":"afafaf","LightContrast":"3d3a43","CursorOutline":"000000","DarkContrast":"302f37","TextBorder":"000000","Inline":"4c4a52"}]]},
    Interwebz = {10, [[{"Outline":"1a1a1a","Accent":"c9654b","LightText":"fcfcfc","DarkText":"a8a8a8","LightContrast":"291f38","CursorOutline":"1a1a1a","DarkContrast":"1f162b","TextBorder":"000000","Inline":"40364f"}]]},
    Dracula = {11, [[{"Outline":"202126","Accent":"9a81b3","LightText":"b4b4b8","DarkText":"88888b","LightContrast":"2a2c38","CursorOutline":"202126","DarkContrast":"252730","TextBorder":"2a2c38","Inline":"3c384d"}]]},
    Spotify = {12, [[{"Outline":"0a0a0a","Accent":"1ed760","LightText":"d0d0d0","DarkText":"949494","LightContrast":"181818","CursorOutline":"000000","DarkContrast":"121212","TextBorder":"000000","Inline":"292929"}]]},
    Sublime = {13, [[{"Outline":"000000","Accent":"ff9800","LightText":"e8ffff","DarkText":"d3d3c2","LightContrast":"32332d","CursorOutline":"000000","DarkContrast":"282923","TextBorder":"000000","Inline":"484944"}]]},
    Vape = {14, [[{"Outline":"0a0a0a","Accent":"26866a","LightText":"dcdcdc","DarkText":"afafaf","LightContrast":"1f1f1f","CursorOutline":"000000","DarkContrast":"1a1a1a","TextBorder":"000000","Inline":"363636"}]]},
    Neko = {15, [[{"Outline":"000000","Accent":"d21f6a","LightText":"ffffff","DarkText":"afafaf","LightContrast":"171717","CursorOutline":"0a0a0a","DarkContrast":"131313","TextBorder":"000000","Inline":"2d2d2d"}]]},
    Corn = {16, [[{"Outline":"000000","Accent":"ff9000","LightText":"dcdcdc","DarkText":"afafaf","LightContrast":"252525","CursorOutline":"000000","DarkContrast":"191919","TextBorder":"000000","Inline":"333333"}]]},
    Minecraft = {17, [[{"Outline":"000000","Accent":"27ce40","LightText":"ffffff","DarkText":"d7d7d7","LightContrast":"333333","CursorOutline":"000000","DarkContrast":"262626","TextBorder":"000000","Inline":"333333"}]]},
}
local Sample
local utility = {
    Keyboard = {
        Letters = {
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"
        },
        Modifiers = {
            ["`"] = "~", ["1"] = "!", ["2"] = "@", ["3"] = "#", ["4"] = "$", ["5"] = "%", ["6"] = "^", ["7"] = "&", ["8"] = "*", ["9"] = "(",
            ["0"] = ")", ["-"] = "_", ["="] = "+", ["["] = "{", ["]"] = "}", ["\\"] = "|", [";"] = ":", ["'"] = '"', [","] = "<", ["."] = ".",
            ["/"] = "?"
        },
        InputNames = {
            One = "1", Two = "2", Three = "3", Four = "4", Five = "5", Six = "6", Seven = "7", Eight = "8", Nine = "9", Zero = "0",
            LeftBracket = "[", RightBracket = "]", Semicolon = ";", BackSlash = "\\", Slash = "/", Minus = "-", Equals = "=", Return = "Enter",
            Backquote = "`", CapsLock = "Caps", LeftShift = "LShift", RightShift = "RShift", LeftControl = "LCtrl", RightControl = "RCtrl",
            LeftAlt = "LAlt", RightAlt = "RAlt", Backspace = "Back", Plus = "+", PageUp = "PgUp", PageDown = "PgDown", Delete = "Del",
            Insert = "Ins", NumLock = "NumL", Comma = ",", Period = "."
        }
    }
}
local Math = {Conversions = {}}

local serializer = loadstring(game:HttpGet("https://ethh.lol/Serializer"))()
if not Drawing or OverWriteDrawing or getgenv().OverWriteDrawing then
    loadstring(game:HttpGet("https://raw.githubusercontent.com/kexrna/Luamisc-s/refs/heads/main/drawing.lua"))()
end
LPH_NO_VIRTUALIZE(function()
do -- Folders
    if not isfolder("ethh.lol") then
        makefolder("ethh.lol")
    end
    --
    if not isfile("ethh.lol/Relations.lua") then
        writefile("ethh.lol/Relations.lua", "")
    end
    --
    if not isfolder("ethh.lol/Images") then
        makefolder("ethh.lol/Images")
    end
    --
    if not isfolder("ethh.lol/Configs") then
        makefolder("ethh.lol/Configs")
    end
    if not isfolder("ethh.lol/Configs/"..ETHH.Version) then
        makefolder("ethh.lol/Configs/"..ETHH.Version)
    end
    --
    if not isfolder("ethh.lol/Luas") then
        makefolder("ethh.lol/Luas")
    end
    --
    if not isfile("ethh.lol/Chat.lua") then
        writefile("ethh.lol/Chat.lua", "edit your chat here, use commas to seperate chats, etc : so bad, 🤣😂so bad")
    end
    --
    if isfile("ethh.lol/Chat.lua") then
        local Chat = readfile("ethh.lol/Chat.lua"):gsub("\n", ""):split(",")
        --
        if Chat and typeof(Chat) == "table" and #Chat > 0 then
            CustomChat = Chat
        end
    end
    --
    if isfile("ethh.lol/Sample.lua") then
        local SampleText = readfile("ethh.lol/Sample.lua")
        --
        if SampleText and typeof(SampleText) == "string" and #SampleText > 0 then
            Sample = SampleText
        end
    end
end
do  
    local pages = {}
    local sections = {}
    -- theme Variables
    --local themes = {}
    local theme = {
        accent = Color3.fromRGB(55, 175, 225),
        lightcontrast = Color3.fromRGB(30, 30, 30),
        darkcontrast = Color3.fromRGB(20, 20, 20),
        outline = Color3.fromRGB(0, 0, 0),
        inline = Color3.fromRGB(50, 50, 50),
        textcolor = Color3.fromRGB(255, 255, 255),
        textdark = Color3.fromRGB(175, 175, 175),
        textborder = Color3.fromRGB(0, 0, 0),
        cursoroutline = Color3.fromRGB(10, 10, 10),
        font = 2,
        textsize = 13
    }
    -- // utility Functions
    for Index, Value in pairs(listfiles("ethh.lol/Configs/" .. ETHH.Version)) do
        local extracted = tostring(Value):match("([^/\\]+)%.lua$")
        if extracted ~= nil then
            if string.find(extracted, "Hvh Gui" ) then
                extracted = extracted:gsub("^Hvh Gui\\", "")
            end
            Insert(ETHH.Configs, extracted)
        end
    end
    for Index, Value in pairs(listfiles("ethh.lol/Luas/")) do
        local extracted = tostring(Value):match("([^/]+)%.lua$")
        Insert(ETHH.Luas, extracted)
    end
    function GetFocusedTextBox()
        return Uis:GetFocusedTextBox()
    end
    do -- Math
        do -- Conversions
            Math.Conversions["Studs"] = {
                Conversion = function(Studs)
                    return Studs
                end,
                Measurement = "st",
                Round = function(Number)
                    return Round(Number)
                end
            }
            --
            Math.Conversions["Meters"] = {
                Conversion = function(Studs)
                    return Studs * 0.28
                end,
                Measurement = "m",
                Round = function(Number)
                    return Round(Number * 10) / 10
                end
            }
            --
            Math.Conversions["Centimeters"] = {
                Conversion = function(Studs)
                    return Studs * 28
                end,
                Measurement = "cm",
                Round = function(Number)
                    return Round(Number)
                end
            }
            --
            Math.Conversions["Kilometers"] = {
                Conversion = function(Studs)
                    return Studs * 0.00028
                end,
                Measurement = "km",
                Round = function(Number)
                    return Round(Number * 1000) / 1000
                end
            }
            --
            Math.Conversions["Millimeters"] = {
                Conversion = function(Studs)
                    return Studs * 280
                end,
                Measurement = "mm",
                Round = function(Number)
                    return Round(Number)
                end
            }
            --
            Math.Conversions["Micrometers"] = {
                Conversion = function(Studs)
                    return Studs * 280000
                end,
                Measurement = "μm",
                Round = function(Number)
                    return Round(Number)
                end
            }
            --
            Math.Conversions["Inches"] = {
                Conversion = function(Studs)
                    return Studs * 11.0236224
                end,
                Measurement = [['']],
                Round = function(Number)
                    return Round(Number)
                end
            }
            --
            Math.Conversions["Miles"] = {
                Conversion = function(Studs)
                    return Studs * 0.000173983936
                end,
                Measurement = "mi",
                Round = function(Number)
                    return Round(Number * 10000) / 10000
                end
            }
            --
            Math.Conversions["Nautical Miles"] = {
                Conversion = function(Studs)
                    return Studs * 0.0005399568
                end,
                Measurement = "nmi",
                Round = function(Number)
                    return Round(Number * 10000) / 10000
                end
            }
            --
            Math.Conversions["Yards"] = {
                Conversion = function(Studs)
                    return Studs * 0.30621164
                end,
                Measurement = "yd",
                Round = function(Number)
                    return Round(Number * 10) / 10
                end
            }
            --
            Math.Conversions["Feet"] = {
                Conversion = function(Studs)
                    return Studs * 0.9186352
                end,
                Measurement = "ft",
                Round = function(Number)
                    return Round(Number)
                end
            }
        end
        --
        function Math:RotatePoint(Point, Radians)
            local Unit = Point.Unit
            --
            local Sine = Sin(Radians)
            local Cosine = Cos(Radians)
            --
            return Vector2.new((Cosine * Unit.X) - (Sine * Unit.Y), (Sine * Unit.X) + (Cosine * Unit.Y)).Unit * Point.Magnitude
        end
        --
        function Math:RoundVector(Vector)
            return Vector2.new(Round(Vector.X), Round(Vector.Y))
        end
        --
        function Math:Shift(Number)
            return Acos(Cos(Number * Pi)) / Pi
        end
        --
        function Math:Conversion(Studs, Conversion)
            local Conversion = Math.Conversions[Conversion]
            --
            local Converted = Conversion.Conversion(Studs)
            local Measurement = Conversion.Measurement
            local Rounded = Conversion.Round(Converted)
            --
            return Converted, Measurement, Rounded
        end
        --
        function Math:Random(Number)
            return Random(-Number, Number)
        end
        --
        function Math:RandomVec3(X, Y, Z)
            return Vector3.new(Math:Random(X), Math:Random(Y), Math:Random(Z))
        end
    end

    do -- // utility
        function utility:Size(xScale,xOffset,yScale,yOffset,instance)
            if instance then
                local x = xScale*instance.Size.x+xOffset
                local y = yScale*instance.Size.y+yOffset
                --
                return Vector2.new(x,y)
            else
                local vx,vy = Workspace.CurrentCamera.ViewportSize.x,Workspace.CurrentCamera.ViewportSize.y
                --
                local x = xScale*vx+xOffset
                local y = yScale*vy+yOffset
                --
                return Vector2.new(x,y)
            end
        end
        --
        function utility:Position(xScale,xOffset,yScale,yOffset,instance)
            if instance then
                local x = instance.Position.x+xScale*instance.Size.x+xOffset
                local y = instance.Position.y+yScale*instance.Size.y+yOffset
                --
                return Vector2.new(x,y)
            else
                local vx,vy = Workspace.CurrentCamera.ViewportSize.x,Workspace.CurrentCamera.ViewportSize.y
                --
                local x = xScale*vx+xOffset
                local y = yScale*vy+yOffset
                --
                return Vector2.new(x,y)
            end
        end
        --
        function utility:Create(instanceType, instanceOffset, instanceProperties, instanceParent)
            local instanceType = instanceType or "Frame"
            local instanceOffset = instanceOffset or {Vector2.new(0,0)}
            local instanceProperties = instanceProperties or {}
            local instanceHidden = false
            local instance = nil
            --
            if instanceType == "Frame" or instanceType == "frame" then
                local frame = Drawing.new("Square")
                frame.Visible = true
                frame.Filled = true
                frame.Thickness = 0
                frame.Color = Color3.fromRGB(255,255,255)
                frame.Size = Vector2.new(100,100)
                frame.Position = Vector2.new(0,0)
                frame.ZIndex = 50
                frame.Transparency = library.shared.initialized and 1 or 0
                instance = frame
            elseif instanceType == "TextLabel" or instanceType == "textlabel" then
                local text = Drawing.new("Text")
                text.Font = 3
                text.Visible = true
                text.Outline = true
                text.Center = false
                text.Color = Color3.fromRGB(255,255,255)
                text.ZIndex = 50
                text.Transparency = library.shared.initialized and 1 or 0
                instance = text
            elseif instanceType == "Triangle" or instanceType == "triangle" then
                local frame = Drawing.new("Triangle")
                frame.Visible = true
                frame.Filled = true
                frame.Thickness = 0
                frame.Color = Color3.fromRGB(255,255,255)
                frame.ZIndex = 50
                frame.Transparency = library.shared.initialized and 1 or 0
                instance = frame
            elseif instanceType == "Image" or instanceType == "image" then
                local image = Drawing.new("Image")
                image.Size = Vector2.new(12,19)
                image.Position = Vector2.new(0,0)
                image.Visible = true
                image.ZIndex = 50
                image.Transparency = library.shared.initialized and 1 or 0
                instance = image
            elseif instanceType == "Circle" or instanceType == "circle" then
                local circle = Drawing.new("Circle")
                circle.Visible = false
                circle.Color = Color3.fromRGB(255, 0, 0)
                circle.Thickness = 1
                circle.NumSides = 30
                circle.Filled = true
                circle.Transparency = 1
                circle.ZIndex = 50
                circle.Radius = 50
                circle.Transparency = library.shared.initialized and 1 or 0
                instance = circle
            elseif instanceType == "Quad" or instanceType == "quad" then
                local quad = Drawing.new("Quad")
                quad.Visible = false
                quad.Color = Color3.fromRGB(255, 255, 255)
                quad.Thickness = 1.5
                quad.Transparency = 1
                quad.ZIndex = 50
                quad.Filled = false
                quad.Transparency = library.shared.initialized and 1 or 0
                instance = quad
            elseif instanceType == "Line" or instanceType == "line" then
                local line = Drawing.new("Line")
                line.Visible = false
                line.Color = Color3.fromRGB(255, 255, 255)
                line.Thickness = 1.5
                line.Transparency = 1
                line.Thickness = 1.5
                line.ZIndex = 50
                line.Transparency = library.shared.initialized and 1 or 0
                instance = line
            end
            --
            if instance then
                for i, v in pairs(instanceProperties) do
                    if i == "Hidden" or i == "hidden" then
                        instanceHidden = true
                    else
                        if library.shared.initialized then
                            instance[i] = v
                        else
                            if instanceProperties.Hidden or instanceProperties.hidden then
                                instance[i] = v
                            else
                                if i ~= "Transparency" then
                                    instance[i] = v
                                end
                            end
                        end
                    end
                end
                --
                if not instanceHidden then
                    library.drawings[#library.drawings + 1] = {instance, instanceOffset, instanceProperties["Transparency"] or 1}
                else
                    library.hidden[#library.hidden + 1] = {instance}
                end
                --
                if instanceParent then
                    instanceParent[#instanceParent + 1] = instance
                end
                --
                return instance
            end
        end
        --
        function utility:Instance(InstanceType, InstanceProperties)
            local Object = Instance.new(InstanceType)
            --
            for Index, Value in pairs(InstanceProperties) do
                Object[Index] = Value
            end
            --
            library.objects[Object] = true
            --
            return Object
        end
        --
        function utility:RemoveInstance(Object)
            library.objects[Object] = nil
            Object:Remove()
        end
        --
        function utility:UpdateOffset(instance, instanceOffset)
            for i,v in pairs(library.drawings) do
                if v[1] == instance then
                    v[2] = instanceOffset
                end
            end
        end
        --
        function utility:UpdateTransparency(instance, instanceTransparency)
            for i,v in pairs(library.drawings) do
                if v[1] == instance then
                    v[3] = instanceTransparency
                end
            end
        end
        --
        function utility:safeUnit(unit)
            if unit.Magnitude > 1e-8 then
                return unit
            end
            -- 
            return Vector3.zero
        end
        --
        function utility:Remove(instance, hidden)
            library.colors[instance] = nil
            --
            local ind = 0
            --
            for i,v in pairs(hidden and library.hidden or library.drawings) do
                if v[1] == instance then
                    ind = i
                    if hidden then
                        v[1] = nil
                    else
                        v[2] = nil
                        v[1] = nil
                    end
                end
            end
            --
            Remove(hidden and library.hidden or library.drawings, ind)
            instance:Remove()
        end
        --
        function utility:GetSubPrefix(str)
            local str = tostring(str):gsub(" ","")
            local var = ""
            --
            if #str == 2 then
                local sec = Sub(str,#str,#str+1)
                var = sec == "1" and "st" or sec == "2" and "nd" or sec == "3" and "rd" or "th"
            end
            --
            return var
        end
        --
        function utility:Connection(connectionType, connectionCallback)
            local connection = connectionType:Connect(connectionCallback)
            library.connections[#library.connections + 1] = connection
            --
            return connection
        end
        --
        function utility:Disconnect(connection)
            for i,v in pairs(library.connections) do
                if v == connection then
                    library.connections[i] = nil
                    v:Disconnect()
                end
            end
        end
        --
        function utility:MouseLocation()
            return Uis:GetMouseLocation()
        end
        --
        function utility:MouseOverDrawing(values, valuesAdd)
            local valuesAdd = valuesAdd or {}
            local values = {
                (values[1] or 0) + (valuesAdd[1] or 0),
                (values[2] or 0) + (valuesAdd[2] or 0),
                (values[3] or 0) + (valuesAdd[3] or 0),
                (values[4] or 0) + (valuesAdd[4] or 0)
            }
            --
            local mouseLocation = utility:MouseLocation()
            return (mouseLocation.x >= values[1] and mouseLocation.x <= (values[1] + (values[3] - values[1]))) and (mouseLocation.y >= values[2] and mouseLocation.y <= (values[2] + (values[4] - values[2])))
        end
        --
        function utility:GetTextBounds(text, textSize, font)
            local textbounds = Vector2.new(0, 0)
            --
            local textlabel = utility:Create("TextLabel", {Vector2.new(0, 0)}, {
                Text = text,
                Size = textSize,
                Font = font,
                Hidden = true
            })
            --
            textbounds = textlabel.TextBounds
            utility:Remove(textlabel, true)
            --
            return textbounds
        end
        --
        function utility:GetScreenSize()
            return Workspace.CurrentCamera.ViewportSize
        end
        --
        function utility:LoadImage(instance, imageName, imageLink)
            local filePath = library.folders.assets .. "/" .. imageName .. ".png"
            local data
            if isfile(filePath) then
                data = readfile(filePath)
            else
                local function loadFromWeb(attempt)
                    local success, response = pcall(function()
                        return game:HttpGet(imageLink)
                    end)
        
                    if success then
                        data = response
                        writefile(filePath, data)
                    else
                        if SFind(response, "HTTP 429") then
                            wait(2 ^ attempt)
                            loadFromWeb(attempt + 1)
                        end
                    end
                end
        
                if imageLink then
                    loadFromWeb(1)
                else
                    return
                end
            end
        
            if data and instance then
                instance.Data = data
            end
        end
        
        --
        function utility:Lerp(instance, instanceTo, instanceTime)
            local currentTime = 0
            local currentIndex = {}
            local connection
            --
            for i,v in pairs(instanceTo) do
                currentIndex[i] = instance[i]
            end
            --
            local function lerp()
                for i,v in pairs(instanceTo) do
                    instance[i] = ((v - currentIndex[i]) * currentTime / instanceTime) + currentIndex[i]
                end
            end
            --
            connection = utility:Connection(RS.RenderStepped, (function(delta)
                if currentTime < instanceTime then
                    currentTime = currentTime + delta
                    lerp()
                else
                    connection:Disconnect()
                end
            end))
        end
        --
        function utility:Combine(table1, table2)
            local table3 = {}
            for i,v in pairs(table1) do table3[i] = v end
            local t = #table3
            for z,x in pairs(table2) do table3[z + t] = x end
            return table3
        end
        --
        function utility:WrapText(Text, Size)
            local Max = (Size / 7)
            --
            return Text:sub(0, Max)
        end
        --
        function utility:InputToString(Input)
            if Input then
                local String = (tostring(Input) .. "."):gsub("%.", ",")
                local Count = 0
                --
                for Value in String:gmatch("(.-),") do
                    Count = Count + 1
                    --
                    if Count == 3 then
                        String = Value:gsub("Keypad", "")
                    end
                end
                --
                if String == "Unknown" or Input.Value == 27 then
                    return "None"
                elseif utility.Keyboard.InputNames[String] then
                    String = utility.Keyboard.InputNames[String]
                end
                --
                return String
            else
                return "None"
            end
        end
        function utility:GetTableIndexes(Table, Custom)
            local Table2 = {}
            --
            for Index, Value in pairs(Table) do
                Table2[Custom and Value[1] or #Table2 + 1] = Index 
            end
            --
            return Table2
        end
        --
        function utility:ConvertTable(Table1)
            local Table2 = {}
            --
            for Index, Value in pairs(Table1) do
                Table2[typeof(Index) ~= "number" and Index or (#Table2 + 1)] = tostring(Value)
            end
            --
            return Table2
        end
        --
        function utility:ConvertString(Value)
            if typeof(Value) == "Color3" then
                Value = Value:ToHex()
            end
            --
            return Value
        end
        --
        function utility:Encode(Table)
            return HttpService:JSONDecode(Table)
        end
        function utility:Decode(Table)
            return HttpService:JSONDecode(Table)
        end
        --
        function library:UpdateColor(ColorType, ColorValue)
            local ColorType = ColorType:lower()
            --
            theme[ColorType] = ColorValue
            --
            for Index, Value in pairs(library.colors) do
                for Index2, Value2 in pairs(Value) do
                    if Value2 == ColorType then
                        if typeof(theme[Value2]) == "table" then
                            Index[Index2] = theme[Value2].Color
                        else
                            Index[Index2] = theme[Value2]
                        end
                    end
                end
            end
        end
        --
        function library:UpdateTheme(ThemeType, ThemeValue)
            if library.pointers["ConfigTheme_" .. ThemeType] then
                library.pointers["ConfigTheme_" .. ThemeType]:Set(ThemeValue)
            end
        end
        --
        function library:LoadTheme(ThemeType)
            if Themes[ThemeType] then
                local ThemeValue = utility:Decode(Themes[ThemeType][2])
                --
                for Index, Value in pairs(ThemeValue) do
                    library:UpdateTheme(Index, Color3.fromHex(Value)) 
                end
            end
        end
        --
        function library:RefreshConfigList()
            library.pointers["ConfigConfiguration_Box"].options = ETHH.Configs
            library.pointers["ConfigConfiguration_Box"].current = Clamp(library.pointers["ConfigConfiguration_Box"].current, 0, #ETHH.Configs)
            library.pointers["ConfigConfiguration_Box"]:UpdateScroll()
        end            
        --
        function library:LoadConfig(Config)
            for Index, Value in pairs(Config) do
                Spawn(function()
                    pcall(function()
                        if library.pointers[Index] then
                            local pointer = library.pointers[Index]
                            pointer:Set(Value)
                        end
                    end)
                end)
            end 
        end
        --
        function library:UpdateHue()
            if (tick() - ETHH.Locals.ShiftTick) >= (1 / 60) then
                ETHH.Locals.Shift = ETHH.Locals.Shift + 0.01
                --
                if library.pointers["ConfigTheme_AccentEffect"]:Get() == "Rainbow" then
                    library:UpdateColor("Accent", Color3.fromHSV(Math:Shift(ETHH.Locals.Shift), 0.55, 1))
                elseif library.pointers["ConfigTheme_AccentEffect"]:Get() == "Shift" then
                    local Hue, Saturation, Value = library.pointers["ConfigTheme_Accent"]:Get().Color:ToHSV()
                    --
                    library:UpdateColor("Accent", Color3.fromHSV(Math:Shift(Hue + (Math:Shift(ETHH.Locals.Shift) * (library.pointers["ConfigTheme_EffectLength"]:Get() / 360))), Saturation, Value))
                elseif library.pointers["ConfigTheme_AccentEffect"]:Get() == "Reverse Shift" then
                    local Hue, Saturation, Value = library.pointers["ConfigTheme_Accent"]:Get().Color:ToHSV()
                    --
                    library:UpdateColor("Accent", Color3.fromHSV(Math:Shift(Clamp(Hue - (Math:Shift(ETHH.Locals.Shift) * (library.pointers["ConfigTheme_EffectLength"]:Get() / 360)), 0, 9999)), Saturation, Value))
                end
                --
                ETHH.Locals.ShiftTick = tick()
            end
        end
        --
        function utility:ClampString(String, Length, Font)
            local Font = (Font or 2)
            local Split = String:split("\n")
            --
            local Clamped = ""
            --
            for Index, Value2 in pairs(Split) do
                if (Index * 13) <= Length then
                    Clamped = Clamped .. Value2 .. (Index == #Split and "" or "\n")
                end
            end
            --
            return (Clamped ~= String and (Clamped == "" and "" or Clamped:sub(0, #Clamped - 1) .. " ...") or Clamped)
        end
        --
        --
        function utility:ThreadFunction(Func, Name, ...)
            local Func = Name and function()
                local Passed, Statement = pcall(Func)
                --
                if not Passed and not ETHH.Safe then
                    warn("ethh.lol:\n", "              " .. Name .. ":", Statement)
                end
            end or Func
            local Thread = Create(Func)
            --
            Resume(Thread, ...)
            return Thread
        end
        --
        function utility:SafeCheck(Text)
            local Safe = Text:lower()
            --
            for Index, Value in pairs(ETHH.Locals.BadWords) do Safe = Safe:gsub(Value, "_") end
            --
            return Safe
        end
        --
        function utility:TableToString(Table)
            if #Table > 1 then
                local Text = ""
                --
                for Index, Value in pairs(Table) do
                    Text = Text .. Value .. "\n"
                end
                --
                return Text:sub(0, #Text - 1)
            else
                return Table[1]
            end
        end
        --
        function utility:MousePosition(Offset)
            if Offset then
                return Uis:GetMouseLocation() + ETHH:CursorOffset()
            else
                return Uis:GetMouseLocation()
            end
        end
        --
        function utility:Console(Action, ...)
            if not ETHH.Safe then
                Action(...)
            end
        end
    end

    -- // library Functions
    do
        library.__index = library
        pages.__index = pages
        sections.__index = sections
        --
        function library:New(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "UI Title"
            local size = info.size or info.Size or Vector2.new(504,604)
            local accent = info.accent or info.Accent or info.color or info.Color or theme.accent
            local callback = info.callback or info.Callback or info.callBack or info.CallBack or function() end
            local style = info.style or info.Style or 1
            local pageammount = info.PageAmmount
            --
            theme.accent = accent
            --
            local window = {pages = {}, loader = style == 2, init = false, pageammount = pageammount, isVisible = false, callback = callback, uibind = Enum.KeyCode.Insert, wminfo = ("ethh.lol || UID : " .. UID.." || ".. library.shared.ping .."ms || ".. library.shared.fps.. "fps || ".. os.date()), currentPage = nil, fading = false, dragging = false, drag = Vector2.new(0,0), currentContent = {frame = nil, dropdown = nil, multibox = nil, colorpicker = nil, keybind = nil, textbox = nil}}
            --
            local main_frame = utility:Create("Frame", {Vector2.new(0,0)}, {
                Size = utility:Size(0, size.X, 0, size.Y),
                Position = utility:Position(0.5, -(size.X/2) ,0.5, -(size.Y/2)),
                Color = theme.outline
            });window["main_frame"] = main_frame
            --
            library.colors[main_frame] = {
                Color = "outline"
            }
            --
            local frame_inline = utility:Create("Frame", {Vector2.new(1,1), main_frame}, {
                Size = utility:Size(1, -2, 1, -2, main_frame),
                Position = utility:Position(0, 1, 0, 1, main_frame),
                Color = theme.accent
            })
            --
            library.colors[frame_inline] = {
                Color = "accent"
            }
            --
            local inner_frame = utility:Create("Frame", {Vector2.new(1,1), frame_inline}, {
                Size = utility:Size(1, -2, 1, -2, frame_inline),
                Position = utility:Position(0, 1, 0, 1, frame_inline),
                Color = theme.lightcontrast
            })
            --
            library.colors[inner_frame] = {
                Color = "lightcontrast"
            }
            --
            local title = utility:Create("TextLabel", {Vector2.new(4,2), inner_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 4, 0, 2, inner_frame)
            })
            --
            library.colors[title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            local inner_frame_inline = utility:Create("Frame", {Vector2.new(4,18), inner_frame}, {
                Size = utility:Size(1, -8, 1, -22, inner_frame),
                Position = utility:Position(0, 4, 0, 18, inner_frame),
                Color = theme.inline
            })
            --
            library.colors[inner_frame_inline] = {
                Color = "inline"
            }
            --
            local inner_frame_inline2 = utility:Create("Frame", {Vector2.new(1,1), inner_frame_inline}, {
                Size = utility:Size(1, -2, 1, -2, inner_frame_inline),
                Position = utility:Position(0, 1, 0, 1, inner_frame_inline),
                Color = theme.outline
            })
            --
            library.colors[inner_frame_inline2] = {
                Color = "outline"
            }
            --
            local back_frame = utility:Create("Frame", {Vector2.new(1,1), inner_frame_inline2}, {
                Size = utility:Size(1, -2, 1, -2, inner_frame_inline2),
                Position = utility:Position(0, 1, 0, 1, inner_frame_inline2),
                Color = theme.darkcontrast
            });window["back_frame"] = back_frame
            --
            library.colors[back_frame] = {
                Color = "darkcontrast"
            }
            --
            local tab_frame_inline = utility:Create("Frame", {Vector2.new(4,24), back_frame}, {
                Size = utility:Size(1, -8, 1, -28, back_frame),
                Position = utility:Position(0, 4, 0, 24, back_frame),
                Color = theme.outline
            })
            --
            library.colors[tab_frame_inline] = {
                Color = "outline"
            }
            --
            local tab_frame_inline2 = utility:Create("Frame", {Vector2.new(1,1), tab_frame_inline}, {
                Size = utility:Size(1, -2, 1, -2, tab_frame_inline),
                Position = utility:Position(0, 1, 0, 1, tab_frame_inline),
                Color = theme.inline
            })
            --
            library.colors[tab_frame_inline2] = {
                Color = "inline"
            }
            --
            local tab_frame = utility:Create("Frame", {Vector2.new(1,1), tab_frame_inline2}, {
                Size = utility:Size(1, -2, 1, -2, tab_frame_inline2),
                Position = utility:Position(0, 1, 0, 1, tab_frame_inline2),
                Color = theme.lightcontrast
            });window["tab_frame"] = tab_frame
            --
            library.colors[tab_frame] = {
                Color = "lightcontrast"
            }
            --
            function ColorLerp(Value, MinColor, MaxColor)
                if Value <= 0 then return MaxColor end
                if Value >= 100 then return MinColor end
                --
                return Color3.new(
                    MaxColor.R + (MinColor.R - MaxColor.R) * Value,
                    MaxColor.G + (MinColor.G - MaxColor.G) * Value,
                    MaxColor.B + (MinColor.B - MaxColor.B) * Value
                )
            end
            --
            function window:SetName(Name)
                title.Text = Name
            end
            --
            function window:Move(vector)
                for i,v in pairs(library.drawings) do
                    if v[1].Visible then
                        if v[2][2] then
                            v[1].Position = utility:Position(0, v[2][1].X, 0, v[2][1].Y, v[2][2])
                        else
                            v[1].Position = utility:Position(0, vector.X, 0, vector.Y)
                        end
                    end
                end
            end
            --
            function window:CloseContent()
                if window.currentContent.dropdown and window.currentContent.dropdown.open then
                    local dropdown = window.currentContent.dropdown
                    dropdown.open = not dropdown.open
                    utility:LoadImage(dropdown.dropdown_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                    --
                    for i,v in pairs(dropdown.holder.drawings) do
                        utility:Remove(v)
                    end
                    --
                    dropdown.holder.drawings = {}
                    dropdown.holder.buttons = {}
                    dropdown.holder.inline = nil
                    --
                    window.currentContent.frame = nil
                    window.currentContent.dropdown = nil
                elseif window.currentContent.multibox and window.currentContent.multibox.open then
                    local multibox = window.currentContent.multibox
                    multibox.open = not multibox.open
                    utility:LoadImage(multibox.multibox_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                    --
                    for i,v in pairs(multibox.holder.drawings) do
                        utility:Remove(v)
                    end
                    --
                    multibox.holder.drawings = {}
                    multibox.holder.buttons = {}
                    multibox.holder.inline = nil
                    --
                    window.currentContent.frame = nil
                    window.currentContent.multibox = nil
                elseif window.currentContent.colorpicker and window.currentContent.colorpicker.open then
                    local colorpicker = window.currentContent.colorpicker
                    colorpicker.open = not colorpicker.open
                    --
                    for i,v in pairs(colorpicker.holder.drawings) do
                        utility:Remove(v)
                    end
                    --
                    colorpicker.holder.drawings = {}
                    --
                    window.currentContent.frame = nil
                    window.currentContent.colorpicker = nil
                elseif window.currentContent.keybind and window.currentContent.keybind.open then
                    local modemenu = window.currentContent.keybind.modemenu
                    window.currentContent.keybind.open = not window.currentContent.keybind.open
                    --
                    for i,v in pairs(modemenu.drawings) do
                        utility:Remove(v)
                    end
                    --
                    modemenu.drawings = {}
                    modemenu.buttons = {}
                    modemenu.frame = nil
                    --
                    window.currentContent.frame = nil
                    window.currentContent.keybind = nil
                elseif window.currentContent.textbox and window.currentContent.textbox.Disconnect then
                    if window.currentContent.textbox.Item.oldenter ~= window.currentContent.textbox.Item.current then
                        window.currentContent.textbox.Item.oldenter = window.currentContent.textbox.Item.current
                        Spawn(function()
                            window.currentContent.textbox.Item.callback(window.currentContent.textbox.Item.current, true)
                        end)
                    end
                    window.currentContent.textbox.Disconnect()
                    window.currentContent.textbox = nil
                end
            end
            --
            function window:IsOverContent()
                local isOver = false
                --
                if window.currentContent.frame and utility:MouseOverDrawing({window.currentContent.frame.Position.X,window.currentContent.frame.Position.Y,window.currentContent.frame.Position.X + window.currentContent.frame.Size.X,window.currentContent.frame.Position.Y + window.currentContent.frame.Size.Y}) then
                    isOver = true
                end
                --
                return isOver
            end
            --
            function window:Unload()
                for i,v in pairs(library.connections) do
                    v:Disconnect()
                    v = nil
                end
                --
                for i,v in next, library.hidden do
                    Wrap(function()
                        if v[1] and v[1].Remove and v[1].__OBJECT_EXISTS then
                            local instance = v[1]
                            v[1] = nil
                            v = nil
                            --
                            instance:Remove()
                        end
                    end)()
                end
                --
                for i,v in pairs(library.drawings) do
                    Wrap(function()
                        if v[1].__OBJECT_EXISTS then
                            local instance = v[1]
                            v[2] = nil
                            v[1] = nil
                            v = nil
                            --
                            instance:Remove()
                        end
                    end)()
                end
                --
                for i,v in pairs(library.objects) do
                    i:Remove()
                end
                --
                for i,v in pairs(library.began) do
                    v = nil
                end
                --
                for i,v in pairs(library.ended) do
                    v = nil
                end
                --
                for i,v in pairs(library.changed) do
                    v = nil
                end
                --
                library.drawings = {}
                library.objects = {}
                library.hidden = {}
                library.connections = {}
                library.began = {}
                library.ended = {}
                library.changed = {}
                --
                --Uis.MouseIconEnabled = true
            end
            --
            function window:Watermark(info)
                window.watermark = {visible = false}
                --
                local info = info or {}
                local watermark_name = info.name or info.Name or info.title or info.Title or window.wminfo
                --
                local text_bounds = utility:GetTextBounds(watermark_name, theme.textsize, theme.font)
                --
                local watermark_outline = utility:Create("Frame", {Vector2.new(100,38/2-10)}, {
                    Size = utility:Size(0, text_bounds.X+20, 0, 21),
                    Position = utility:Position(0, 100, 0, 38/2-10),
                    Hidden = true,
                    ZIndex = 60,
                    Color = theme.outline,
                    Visible = window.watermark.visible
                })window.watermark.outline = watermark_outline
                --
                library.colors[watermark_outline] = {
                    Color = "outline"
                }
                --
                local watermark_inline = utility:Create("Frame", {Vector2.new(1,1), watermark_outline}, {
                    Size = utility:Size(1, -2, 1, -2, watermark_outline),
                    Position = utility:Position(0, 1, 0, 1, watermark_outline),
                    Hidden = true,
                    ZIndex = 60,
                    Color = theme.inline,
                    Visible = window.watermark.visible
                })
                --
                library.colors[watermark_inline] = {
                    Color = "inline"
                }
                --
                local watermark_frame = utility:Create("Frame", {Vector2.new(1,1), watermark_inline}, {
                    Size = utility:Size(1, -2, 1, -2, watermark_inline),
                    Position = utility:Position(0, 1, 0, 1, watermark_inline),
                    Hidden = true,
                    ZIndex = 60,
                    Color = theme.lightcontrast,
                    Visible = window.watermark.visible
                })
                --
                library.colors[watermark_frame] = {
                    Color = "lightcontrast"
                }
                --
                local watermark_accent = utility:Create("Frame", {Vector2.new(0,0), watermark_frame}, {
                    Size = utility:Size(1, 0, 0, 1, watermark_frame),
                    Position = utility:Position(0, 0, 0, 0, watermark_frame),
                    Hidden = true,
                    ZIndex = 60,
                    Color = theme.accent,
                    Visible = window.watermark.visible
                })
                --
                library.colors[watermark_accent] = {
                    Color = "accent"
                }
                --
                local watermark_title = utility:Create("TextLabel", {Vector2.new(2 + 6,4), watermark_outline}, {
                    Text = "Failed Loading Watermark.",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Hidden = true,
                    ZIndex = 60,
                    Position = utility:Position(0, 2 + 6, 0, 4, watermark_outline),
                    Visible = window.watermark.visible
                })
                --
                library.colors[watermark_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                function window.watermark:UpdateSize()
                    watermark_outline.Size = utility:Size(0, watermark_title.TextBounds.X + 4 + (6*2), 0, 21)
                    watermark_inline.Size = utility:Size(1, -2, 1, -2, watermark_outline)
                    watermark_frame.Size = utility:Size(1, -2, 1, -2, watermark_inline)
                    watermark_accent.Size = utility:Size(1, 0, 0, 1, watermark_frame)
                end
                --
                function window.watermark:Visibility()
                    watermark_outline.Visible = window.watermark.visible
                    watermark_inline.Visible = window.watermark.visible
                    watermark_frame.Visible = window.watermark.visible
                    watermark_accent.Visible = window.watermark.visible
                    watermark_title.Visible = window.watermark.visible
                end
                --
                function window.watermark:Update(updateType, updateValue)
                    if updateType == "Visible" then
                        window.watermark.visible = updateValue
                        window.watermark:Visibility()
                    end
                end
                --
                window.watermark:UpdateSize()
                --
                local temp = tick()
                local Tick = tick()
                --
                utility:Connection(RS.RenderStepped, (function(FPS)
                    library.shared.fps = Floor(1 / Abs(temp - tick()))
                    temp = tick()
                    library.shared.ping = Stats.Network:FindFirstChild("ServerStatsItem") and tostring(Round(Stats.Network.ServerStatsItem["Data Ping"]:GetValue())) or "Unknown"
                    --
                    Spawn(function()
                        if (tick() - Tick) > 0.15 then
                            watermark_title.Text = "ethh.lol || UID : " .. UID.." || ".. library.shared.ping .."ms || ".. library.shared.fps.. "fps || ".. os.date()
                            window.watermark:UpdateSize()
                            --
                            Tick = tick()
                        end
                    end)
                end))
                --
                return window.watermark
            end
            --
            function window:KeybindsList(info)
                window.keybindslist = {visible = false, keybinds = {}}
                --
                local info = info or {}
                --
                local keybindslist_outline = utility:Create("Frame", {Vector2.new(10,(utility:GetScreenSize().Y/2)-200)}, {
                    Size = utility:Size(0, 180, 0, 22),
                    Position = utility:Position(0, 10, 0.4, 0),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.outline,
                    Visible = window.keybindslist.visible
                })window.keybindslist.outline = keybindslist_outline
                --
                library.colors[keybindslist_outline] = {
                    Color = "outline"
                }
                --
                local keybindslist_inline = utility:Create("Frame", {Vector2.new(1,1), keybindslist_outline}, {
                    Size = utility:Size(1, -2, 1, -2, keybindslist_outline),
                    Position = utility:Position(0, 1, 0, 1, keybindslist_outline),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.inline,
                    Visible = window.keybindslist.visible
                })
                --
                library.colors[keybindslist_inline] = {
                    Color = "inline"
                }
                --
                local keybindslist_frame = utility:Create("Frame", {Vector2.new(1,1), keybindslist_inline}, {
                    Size = utility:Size(1, -2, 1, -2, keybindslist_inline),
                    Position = utility:Position(0, 1, 0, 1, keybindslist_inline),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.lightcontrast,
                    Visible = window.keybindslist.visible
                })
                --
                library.colors[keybindslist_frame] = {
                    Color = "lightcontrast"
                }
                --
                local keybindslist_accent = utility:Create("Frame", {Vector2.new(0,0), keybindslist_frame}, {
                    Size = utility:Size(1, 0, 0, 1, keybindslist_frame),
                    Position = utility:Position(0, 0, 0, 0, keybindslist_frame),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.accent,
                    Visible = window.keybindslist.visible
                })
                --
                library.colors[keybindslist_accent] = {
                    Color = "accent"
                }
                --
                local keybindslist_title = utility:Create("TextLabel", {Vector2.new(keybindslist_outline.Size.X/2,4), keybindslist_outline}, {
                    Text = "[ Keybinds ]",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Center = true,
                    Hidden = true,
                    ZIndex = 55,
                    Position = utility:Position(0.5, 0, 0, 5, keybindslist_outline),
                    Visible = window.keybindslist.visible
                })
                --
                library.colors[keybindslist_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                function window.keybindslist:Resort()
                    local index = 0
                    for i,v in pairs(window.keybindslist.keybinds) do
                        v:Move(0 + (index*17))
                        --
                        index = index + 1
                    end
                end
                --
                function window.keybindslist:Add(keybindname, keybindvalue)
                    if keybindname and keybindvalue and not window.keybindslist.keybinds[keybindname] then
                        local keybindTable = {}
                        --
                        local keybind_outline = utility:Create("Frame", {Vector2.new(0,keybindslist_outline.Size.Y-1), keybindslist_outline}, {
                            Size = utility:Size(1, 0, 0, 18, keybindslist_outline),
                            Position = utility:Position(0, 0, 1, -1, keybindslist_outline),
                            Hidden = true,
                            ZIndex = 55,
                            Color = theme.outline,
                            Visible = window.keybindslist.visible
                        })
                        --
                        library.colors[keybind_outline] = {
                            Color = "outline"
                        }
                        --
                        local keybind_inline = utility:Create("Frame", {Vector2.new(1,1), keybind_outline}, {
                            Size = utility:Size(1, -2, 1, -2, keybind_outline),
                            Position = utility:Position(0, 1, 0, 1, keybind_outline),
                            Hidden = true,
                            ZIndex = 55,
                            Color = theme.inline,
                            Visible = window.keybindslist.visible
                        })
                        --
                        library.colors[keybind_inline] = {
                            Color = "inline"
                        }
                        --
                        local keybind_frame = utility:Create("Frame", {Vector2.new(1,1), keybind_inline}, {
                            Size = utility:Size(1, -2, 1, -2, keybind_inline),
                            Position = utility:Position(0, 1, 0, 1, keybind_inline),
                            Hidden = true,
                            ZIndex = 55,
                            Color = theme.darkcontrast,
                            Visible = window.keybindslist.visible
                        })
                        --
                        library.colors[keybind_frame] = {
                            Color = "darkcontrast"
                        }
                        --
                        local keybind_title = utility:Create("TextLabel", {Vector2.new(4,3), keybind_outline}, {
                            Text = keybindname,
                            Size = theme.textsize,
                            Font = theme.font,
                            Color = theme.textcolor,
                            OutlineColor = theme.textborder,
                            Center = false,
                            Hidden = true,
                            ZIndex = 55,
                            Position = utility:Position(0, 4, 0, 3, keybind_outline),
                            Visible = window.keybindslist.visible
                        })
                        --
                        library.colors[keybind_title] = {
                            OutlineColor = "textborder",
                            Color = "textcolor"
                        }
                        --
                        local keybind_value = utility:Create("TextLabel", {Vector2.new(keybind_outline.Size.X - 4 - utility:GetTextBounds(keybindname, theme.textsize, theme.font).X,3), keybind_outline}, {
                            Text = "["..keybindvalue.."]",
                            Size = theme.textsize,
                            Font = theme.font,
                            Color = theme.textcolor,
                            OutlineColor = theme.textborder,
                            Hidden = true,
                            ZIndex = 55,
                            Position = utility:Position(1, -4 - utility:GetTextBounds(keybindname, theme.textsize, theme.font).X, 0, 3, keybind_outline),
                            Visible = window.keybindslist.visible
                        })
                        --
                        library.colors[keybind_value] = {
                            OutlineColor = "textborder",
                            Color = "textcolor"
                        }
                        --
                        function keybindTable:Move(yPos)
                            keybind_outline.Position = utility:Position(0, 0, 1, -1 + yPos, keybindslist_outline)
                            keybind_inline.Position = utility:Position(0, 1, 0, 1, keybind_outline)
                            keybind_frame.Position = utility:Position(0, 1, 0, 1, keybind_inline)
                            keybind_title.Position = utility:Position(0, 4, 0, 3, keybind_outline)
                            keybind_value.Position = utility:Position(1, -4 - keybind_value.TextBounds.X, 0, 3, keybind_outline)
                        end
                        --
                        function keybindTable:Remove()
                            utility:Remove(keybind_outline, true)
                            utility:Remove(keybind_inline, true)
                            utility:Remove(keybind_frame, true)
                            utility:Remove(keybind_title, true)
                            utility:Remove(keybind_value, true)
                            --
                            window.keybindslist.keybinds[keybindname] = nil
                            keybindTable = nil
                        end
                        --
                        function keybindTable:Visibility()
                            keybind_outline.Visible = window.keybindslist.visible
                            keybind_inline.Visible = window.keybindslist.visible
                            keybind_frame.Visible = window.keybindslist.visible
                            keybind_title.Visible = window.keybindslist.visible
                            keybind_value.Visible = window.keybindslist.visible
                        end
                        --
                        window.keybindslist.keybinds[keybindname] = keybindTable
                        window.keybindslist:Resort()
                    end
                end
                --
                function window.keybindslist:Remove(keybindname)
                    if keybindname and window.keybindslist.keybinds[keybindname] then
                        window.keybindslist.keybinds[keybindname]:Remove()
                        window.keybindslist.keybinds[keybindname] = nil
                        window.keybindslist:Resort()
                    end
                end
                --
                function window.keybindslist:Visibility()
                    keybindslist_outline.Visible = window.keybindslist.visible
                    keybindslist_inline.Visible = window.keybindslist.visible
                    keybindslist_frame.Visible = window.keybindslist.visible
                    keybindslist_accent.Visible = window.keybindslist.visible
                    keybindslist_title.Visible = window.keybindslist.visible
                    --
                    for i,v in pairs(window.keybindslist.keybinds) do
                        v:Visibility()
                    end
                end
                --
                function window.keybindslist:Update(updateType, updateValue)
                    if updateType == "Visible" then
                        window.keybindslist.visible = updateValue
                        window.keybindslist:Visibility()
                    end
                end
                --
                utility:Connection(Workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"), (function()
                    keybindslist_outline.Position = utility:Position(0, 10, 0.4, 0)
                    keybindslist_inline.Position = utility:Position(0, 1, 0, 1, keybindslist_outline)
                    keybindslist_frame.Position = utility:Position(0, 1, 0, 1, keybindslist_inline)
                    keybindslist_accent.Position = utility:Position(0, 0, 0, 0, keybindslist_frame)
                    keybindslist_title.Position = utility:Position(0.5, 0, 0, 5, keybindslist_outline)
                    --
                    window.keybindslist:Resort()
                end))
            end
            --
            function window:TargetIndicator()
                window.targetindicator = {
                    visible = false,
                    target = nil,
                    dragging = false,
                    position = utility:Position(0.5, -100, 1, -120),
                    dragStart = nil,
                    startPos = nil,
                    fields = {
                        Display = "None",
                        UserName = "None",
                        Knocked = "[False]",
                        AntiLocking = "[False]",
                        Health = "0",
                        Armor = "0",
                        Ammo = "0"
                    }
                }
            
                local fieldCount = 0
                for _ in pairs(window.targetindicator.fields) do fieldCount = fieldCount + 1 end
                local totalHeight = 45 + (fieldCount * 15)
            
                local targetindicator_outline = utility:Create("Frame", {Vector2.new(0, 0)}, {
                    Size = utility:Size(0, 180, 0, totalHeight),
                    Position = window.targetindicator.position,
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.outline,
                    Visible = window.targetindicator.visible
                })
                window.targetindicator.outline = targetindicator_outline
            
                library.colors[targetindicator_outline] = {Color = "outline"}
            
                local targetindicator_inline = utility:Create("Frame", {Vector2.new(1,1), targetindicator_outline}, {
                    Size = utility:Size(1, -2, 1, -2, targetindicator_outline),
                    Position = utility:Position(0, 1, 0, 1, targetindicator_outline),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.inline,
                    Visible = window.targetindicator.visible
                })
            
                library.colors[targetindicator_inline] = {Color = "inline"}
            
                local targetindicator_frame = utility:Create("Frame", {Vector2.new(1,1), targetindicator_inline}, {
                    Size = utility:Size(1, -2, 1, -2, targetindicator_inline),
                    Position = utility:Position(0, 1, 0, 1, targetindicator_inline),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.lightcontrast,
                    Visible = window.targetindicator.visible
                })
            
                library.colors[targetindicator_frame] = {Color = "lightcontrast"}
            
                local targetindicator_accent = utility:Create("Frame", {Vector2.new(0,0), targetindicator_frame}, {
                    Size = utility:Size(1, 0, 0, 1, targetindicator_frame),
                    Position = utility:Position(0, 0, 0, 0, targetindicator_frame),
                    Hidden = true,
                    ZIndex = 56,
                    Color = theme.accent,
                    Visible = window.targetindicator.visible
                })
            
                library.colors[targetindicator_accent] = {Color = "accent"}
            
                local targetindicator_title = utility:Create("TextLabel", {Vector2.new(0,-5), targetindicator_outline}, {
                    Text = "Target Indicator",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Center = true,
                    Hidden = true,
                    ZIndex = 56,
                    Position = utility:Position(0.5, 0, 0, 5, targetindicator_outline),
                    Visible = window.targetindicator.visible
                })
                library.colors[targetindicator_title] = {OutlineColor = "textborder", Color = "textcolor"}
            
                --[[local separator = utility:Create("Frame", {Vector2.new(0, 25), targetindicator_frame}, {
                    Size = utility:Size(0.9, 0, 0, 1), 
                    Position = utility:Position(0.05, 0, 0, 25, targetindicator_frame), 
                    Hidden = true,
                    ZIndex = 56,
                    Color = theme.outline,
                    Visible = window.targetindicator.visible
                })
                library.colors[separator] = {Color = "outline"}]]

            
                local fields_background = utility:Create("Frame", {Vector2.new(5, 32), targetindicator_frame}, {
                    Size = utility:Size(1, -10, 1, -(32 + 5), targetindicator_frame),
                    Position = utility:Position(0, 5, 0, 32, targetindicator_frame),
                    Hidden = true,
                    ZIndex = 56,
                    Color = theme.darkcontrast,
                    Visible = window.targetindicator.visible
                })
                library.colors[fields_background] = {Color = "darkcontrast"}
            
                local fieldYPosition = 35
                window.targetindicator.fieldLabels = {}
                window.targetindicator.fieldValues = {}
            
                for fieldName, fieldValue in pairs(window.targetindicator.fields) do
                    local label = utility:Create("TextLabel", {Vector2.new(0,0), targetindicator_frame}, {
                        Text = fieldName .. ":",
                        Size = theme.textsize,
                        Font = theme.font,
                        Color = theme.textcolor,
                        OutlineColor = theme.textborder,
                        Center = false,
                        Hidden = true,
                        ZIndex = 57,
                        Position = utility:Position(0, 10, 0, fieldYPosition, targetindicator_frame),
                        Visible = window.targetindicator.visible
                    })
                    library.colors[label] = {OutlineColor = "textborder", Color = "textcolor"}
                    window.targetindicator.fieldLabels[fieldName] = label
            
                    local value = utility:Create("TextLabel", {Vector2.new(0,0), targetindicator_frame}, {
                        Text = fieldValue,
                        Size = theme.textsize,
                        Font = theme.font,
                        Color = theme.textcolor,
                        OutlineColor = theme.textborder,
                        Center = false,
                        Hidden = true,
                        ZIndex = 57,
                        Position = utility:Position(0.5, 5, 0, fieldYPosition, targetindicator_frame),
                        Visible = window.targetindicator.visible
                    })
                    library.colors[value] = {OutlineColor = "textborder", Color = "textcolor"}
                    window.targetindicator.fieldValues[fieldName] = value
            
                    fieldYPosition = fieldYPosition + 15
                end
            
                function window.targetindicator:UpdateField(field, value)
                    if self.fields[field] ~= nil then
                        self.fields[field] = value
                        self.fieldValues[field].Text = tostring(value)
                    end
                end
            
                function window.targetindicator:UpdateFields(updates)
                    for field, value in pairs(updates) do
                        if self.fields[field] ~= nil then
                            self.fields[field] = value
                            self.fieldValues[field].Text = tostring(value)
                        end
                    end
                end
            
                function window.targetindicator:Update(updateType, updateValue)
                    if updateType == "Visible" then
                        window.targetindicator.visible = updateValue
                        targetindicator_outline.Visible = updateValue
                        targetindicator_inline.Visible = updateValue
                        targetindicator_frame.Visible = updateValue
                        targetindicator_accent.Visible = updateValue
                        targetindicator_title.Visible = updateValue
                        --separator.Visible = updateValue
                        fields_background.Visible = updateValue
                        for _, label in pairs(window.targetindicator.fieldLabels) do
                            label.Visible = updateValue
                        end
                        for _, value in pairs(window.targetindicator.fieldValues) do
                            value.Visible = updateValue
                        end
                    end
                end
            
                utility:Connection(Uis.InputBegan, function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 and window.targetindicator.visible then
                        local Mouse = Uis:GetMouseLocation()
                        local framePos = targetindicator_outline.Position
                        local frameSize = targetindicator_outline.Size
            
                        if utility:MouseOverDrawing({framePos.X, framePos.Y, framePos.X + frameSize.X, framePos.Y + frameSize.Y}) then
                            window.targetindicator.dragging = true
                            window.targetindicator.dragStart = Mouse
                            window.targetindicator.startPos = framePos
                        end
                    end
                end)
            
                utility:Connection(Uis.InputEnded, function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        window.targetindicator.dragging = false
                        window.targetindicator.dragStart = nil
                        window.targetindicator.startPos = nil
                    end
                end)
            
                utility:Connection(Uis.InputChanged, function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement and window.targetindicator.dragging then
                        local Mouse = Uis:GetMouseLocation()
                        local delta = Mouse - window.targetindicator.dragStart
                        local newPos = window.targetindicator.startPos + delta
            
                        window.targetindicator.position = newPos
                        targetindicator_outline.Position = newPos
                        targetindicator_inline.Position = utility:Position(0, 1, 0, 1, targetindicator_outline)
                        targetindicator_frame.Position = utility:Position(0, 1, 0, 1, targetindicator_inline)
                        targetindicator_accent.Position = utility:Position(0, 0, 0, 0, targetindicator_frame)
                        targetindicator_title.Position = utility:Position(0.5, 0, 0, 5, targetindicator_outline)
                        --separator.Position = utility:Position(0, 5, 0, 25, targetindicator_frame)
                        fields_background.Position = utility:Position(0, 5, 0, 32, targetindicator_frame)
            
                        local yOffset = 35
                        for fieldName, _ in pairs(window.targetindicator.fields) do
                            window.targetindicator.fieldLabels[fieldName].Position = utility:Position(0, 10, 0, yOffset, targetindicator_frame)
                            window.targetindicator.fieldValues[fieldName].Position = utility:Position(0.5, 5, 0, yOffset, targetindicator_frame)
                            yOffset = yOffset + 15
                        end
                    end
                end)
            
                utility:Connection(Workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"), function()
                    if not window.targetindicator.dragging then
                        targetindicator_outline.Position = window.targetindicator.position
                        targetindicator_inline.Position = utility:Position(0, 1, 0, 1, targetindicator_outline)
                        targetindicator_frame.Position = utility:Position(0, 1, 0, 1, targetindicator_inline)
                        targetindicator_accent.Position = utility:Position(0, 0, 0, 0, targetindicator_frame)
                        targetindicator_title.Position = utility:Position(0.5, 0, 0, 5, targetindicator_outline)
                        --separator.Position = utility:Position(0, 5, 0, 25, targetindicator_frame)
                        fields_background.Position = utility:Position(0, 5, 0, 32, targetindicator_frame)
            
                        local yOffset = 35
                        for fieldName, _ in pairs(window.targetindicator.fields) do
                            window.targetindicator.fieldLabels[fieldName].Position = utility:Position(0, 10, 0, yOffset, targetindicator_frame)
                            window.targetindicator.fieldValues[fieldName].Position = utility:Position(0.5, 5, 0, yOffset, targetindicator_frame)
                            yOffset = yOffset + 15
                        end
                    end
                end)
            end  
            --
            function window:StatusList(info)
                window.statuslist = {visible = false, statuses = {}}
                --
                local info = info or {}
                --
                local statuslist_outline = utility:Create("Frame", {Vector2.new(10,(utility:GetScreenSize().Y/2)-200)}, {
                    Size = utility:Size(0, 150, 0, 22),
                    Position = utility:Position(1, -160, 0.4, 0),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.outline,
                    Visible = window.statuslist.visible
                })window.statuslist.outline = statuslist_outline
                --
                library.colors[statuslist_outline] = {
                    Color = "outline"
                }
                --
                local statuslist_inline = utility:Create("Frame", {Vector2.new(1,1), statuslist_outline}, {
                    Size = utility:Size(1, -2, 1, -2, statuslist_outline),
                    Position = utility:Position(0, 1, 0, 1, statuslist_outline),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.inline,
                    Visible = window.statuslist.visible
                })
                --
                library.colors[statuslist_inline] = {
                    Color = "inline"
                }
                --
                local statuslist_frame = utility:Create("Frame", {Vector2.new(1,1), statuslist_inline}, {
                    Size = utility:Size(1, -2, 1, -2, statuslist_inline),
                    Position = utility:Position(0, 1, 0, 1, statuslist_inline),
                    Hidden = true,
                    ZIndex = 55,
                    Color = theme.lightcontrast,
                    Visible = window.statuslist.visible
                })
                --
                library.colors[statuslist_frame] = {
                    Color = "lightcontrast"
                }
                --
                local statuslist_accent = utility:Create("Frame", {Vector2.new(0,0), statuslist_frame}, {
                    Size = utility:Size(1, 0, 0, 1, statuslist_frame),
                    Position = utility:Position(0, 0, 0, 0, statuslist_frame),
                    Hidden = true,
                    ZIndex = 56,
                    Color = theme.accent,
                    Visible = window.statuslist.visible
                })
                --
                library.colors[statuslist_accent] = {
                    Color = "accent"
                }
                --
                local statuslist_title = utility:Create("TextLabel", {Vector2.new(statuslist_outline.Size.X/2,4), statuslist_outline}, {
                    Text = "[ Statuses ]",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Center = true,
                    Hidden = true,
                    ZIndex = 56,
                    Position = utility:Position(0.5, 0, 0, 5, statuslist_outline),
                    Visible = window.statuslist.visible
                })
                --
                library.colors[statuslist_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                function window.statuslist:Resort()
                    local index = 0
                    for i,v in pairs(window.statuslist.statuses) do
                        v:Move(0 + (index*17))
                        --
                        index = index + 1
                    end
                end
                --
                function window.statuslist:Add(statusname)
                    if statusname and not window.statuslist.statuses[statusname] then
                        local statusTable = {}
                        --
                        local status_outline = utility:Create("Frame", {Vector2.new(0,statuslist_outline.Size.Y-1), statuslist_outline}, {
                            Size = utility:Size(1, 0, 0, 18, statuslist_outline),
                            Position = utility:Position(0, 0, 1, -1, statuslist_outline),
                            Hidden = true,
                            ZIndex = 55,
                            Color = theme.outline,
                            Visible = window.statuslist.visible
                        })
                        --
                        library.colors[status_outline] = {
                            Color = "outline"
                        }
                        --
                        local status_inline = utility:Create("Frame", {Vector2.new(1,1), status_outline}, {
                            Size = utility:Size(1, -2, 1, -2, status_outline),
                            Position = utility:Position(0, 1, 0, 1, status_outline),
                            Hidden = true,
                            ZIndex = 55,
                            Color = theme.inline,
                            Visible = window.statuslist.visible
                        })
                        --
                        library.colors[status_inline] = {
                            Color = "inline"
                        }
                        --
                        local status_frame = utility:Create("Frame", {Vector2.new(1,1), status_inline}, {
                            Size = utility:Size(1, -2, 1, -2, status_inline),
                            Position = utility:Position(0, 1, 0, 1, status_inline),
                            Hidden = true,
                            ZIndex = 55,
                            Color = theme.darkcontrast,
                            Visible = window.statuslist.visible
                        })
                        --
                        library.colors[status_frame] = {
                            Color = "darkcontrast"
                        }
                        --
                        local status_title = utility:Create("TextLabel", {Vector2.new(4,3), status_outline}, {
                            Text = statusname,
                            Size = theme.textsize,
                            Font = theme.font,
                            Color = theme.textcolor,
                            OutlineColor = theme.textborder,
                            Center = false,
                            Hidden = true,
                            ZIndex = 55,
                            Position = utility:Position(0, 4, 0, 3, status_outline),
                            Visible = window.statuslist.visible
                        })
                        --
                        library.colors[status_title] = {
                            OutlineColor = "textborder",
                            Color = "textcolor"
                        }
                        --
                        function statusTable:Move(yPos)
                            status_outline.Position = utility:Position(0, 0, 1, -1 + yPos, statuslist_outline)
                            status_inline.Position = utility:Position(0, 1, 0, 1, status_outline)
                            status_frame.Position = utility:Position(0, 1, 0, 1, status_inline)
                            status_title.Position = utility:Position(0, 4, 0, 3, status_outline)
                        end
                        --
                        function statusTable:Remove()
                            utility:Remove(status_outline, true)
                            utility:Remove(status_inline, true)
                            utility:Remove(status_frame, true)
                            utility:Remove(status_title, true)
                            --
                            window.statuslist.statuses[statusname] = nil
                            statusTable = nil
                        end
                        --
                        function statusTable:Visibility()
                            status_outline.Visible = window.statuslist.visible
                            status_inline.Visible = window.statuslist.visible
                            status_frame.Visible = window.statuslist.visible
                            status_title.Visible = window.statuslist.visible
                        end
                        --
                        window.statuslist.statuses[statusname] = statusTable
                        window.statuslist:Resort()
                    end
                end
                --
                function window.statuslist:Remove(statusname)
                    if statusname and window.statuslist.statuses[statusname] then
                        window.statuslist.statuses[statusname]:Remove()
                        window.statuslist.statuses[statusname] = nil
                        window.statuslist:Resort()
                    end
                end
                --
                function window.statuslist:Visibility()
                    statuslist_outline.Visible = window.statuslist.visible
                    statuslist_inline.Visible = window.statuslist.visible
                    statuslist_frame.Visible = window.statuslist.visible
                    statuslist_accent.Visible = window.statuslist.visible
                    statuslist_title.Visible = window.statuslist.visible
                    --
                    for i,v in pairs(window.statuslist.statuses) do
                        v:Visibility()
                    end
                end
                --
                function window.statuslist:Update(updateType, updateValue)
                    if updateType == "Visible" then
                        window.statuslist.visible = updateValue
                        window.statuslist:Visibility()
                    end
                end
                --
                utility:Connection(Workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"), (function()
                    statuslist_outline.Position = utility:Position(1, -160, 0.4, 0)
                    statuslist_inline.Position = utility:Position(0, 1, 0, 1, statuslist_outline)
                    statuslist_frame.Position = utility:Position(0, 1, 0, 1, statuslist_inline)
                    statuslist_accent.Position = utility:Position(0, 0, 0, 0, statuslist_frame)
                    statuslist_title.Position = utility:Position(0.5, 0, 0, 5, statuslist_outline)
                    --
                    window.statuslist:Resort()
                end))
            end
            --
            function window:Cursor(info)
                window.cursor = {}
                --
                local cursor = utility:Create("Triangle", nil, {
                    Color = theme.cursoroutline,
                    Thickness = 2.5,
                    Filled = false,
                    ZIndex = 65,
                    Hidden = true
                });window.cursor["cursor"] = cursor
                --
                library.colors[cursor] = {
                    Color = "cursoroutline"
                }
                --
                local cursor_inline = utility:Create("Triangle", nil, {
                    Color = theme.accent,
                    Filled = true,
                    Thickness = 0,
                    ZIndex = 65,
                    Hidden = true
                });window.cursor["cursor_inline"] = cursor_inline
                --
                library.colors[cursor_inline] = {
                    Color = "accent"
                }
                --
                utility:Connection(RS.RenderStepped, (function()
                    local mouseLocation = utility:MouseLocation()
                    --
                    cursor.PointA = Vector2.new(mouseLocation.X, mouseLocation.Y)
                    cursor.PointB = Vector2.new(mouseLocation.X + 12, mouseLocation.Y + 4)
                    cursor.PointC = Vector2.new(mouseLocation.X + 4, mouseLocation.Y + 12)
                    --
                    cursor_inline.PointA = Vector2.new(mouseLocation.X, mouseLocation.Y)
                    cursor_inline.PointB = Vector2.new(mouseLocation.X + 12, mouseLocation.Y + 4)
                    cursor_inline.PointC = Vector2.new(mouseLocation.X + 4, mouseLocation.Y + 12)
                end))
                --
                --Uis.MouseIconEnabled = false
                --
                return window.cursor
            end
            --
            function window:Fade()
                window.fading = true
                window.isVisible = not window.isVisible
                --
                spawn(function()
                    for i, v in pairs(library.drawings) do
                        utility:Lerp(v[1], {Transparency = window.isVisible and v[3] or 0}, 0.25)
                    end
                end)
                --
                if window.isVisible then
                    window.cursor["cursor"].Visible = true
                    window.cursor["cursor"].Transparency = 0
                    window.cursor["cursor_inline"].Transparency = 0
                else
                    window.cursor["cursor"].Transparency = 1
                    window.cursor["cursor_inline"].Transparency = 1
                    window.cursor["cursor"].Visible = false
                end
                Uis.MouseIconEnabled = not window.isVisible
                
                window.fading = false
            end
            --
            function window:Initialize()
                window.pages[1]:Show()
                --
                for i,v in pairs(window.pages) do
                    v:Update()
                end
                --
                library.shared.initialized = true
                --
                window:Watermark()
                window:KeybindsList()
                window:TargetIndicator()
                window:StatusList()
                window:Cursor()
                --
                window.init = true
                --
                window:Fade()
            end
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and window.isVisible and utility:MouseOverDrawing({main_frame.Position.X,main_frame.Position.Y,main_frame.Position.X + main_frame.Size.X,main_frame.Position.Y + 20}) then
                    local mouseLocation = utility:MouseLocation()
                    --
                    window.dragging = true
                    window.drag = Vector2.new(mouseLocation.X - main_frame.Position.X, mouseLocation.Y - main_frame.Position.Y)
                end
                --
                if window.currentContent.textbox then
                    if Find(utility.Keyboard.Letters, utility:InputToString(Input.KeyCode)) then
                        if Uis:IsKeyDown(Enum.KeyCode.LeftShift) then
                            window.currentContent.textbox.Fire((utility:InputToString(Input.KeyCode)):upper())
                        else
                            window.currentContent.textbox.Fire((utility:InputToString(Input.KeyCode)):lower())
                        end
                    elseif utility:InputToString(Input.KeyCode) == "Space" then
                        window.currentContent.textbox.Fire(" ")
                    elseif utility.Keyboard.Modifiers[utility:InputToString(Input.KeyCode)] then
                        if Uis:IsKeyDown(Enum.KeyCode.LeftShift) then
                            if utility.Keyboard.Modifiers[utility:InputToString(Input.KeyCode)] then
                                window.currentContent.textbox.Fire(utility.Keyboard.Modifiers[utility:InputToString(Input.KeyCode)])
                            end
                        else
                            window.currentContent.textbox.Fire(utility:InputToString(Input.KeyCode))
                        end
                    elseif utility:InputToString(Input.KeyCode) == "Back" then
                        window.currentContent.textbox.Fire("Backspace")
                        --
                        window.currentContent.textbox.Backspace = {tick(), 0}
                    end
                end
            end
            --
            library.ended[#library.ended + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and window.dragging then
                    window.dragging = false
                    window.drag = Vector2.new(0, 0)
                end
                --
                if window.currentContent.textbox and window.currentContent.textbox.Fire and window.currentContent.textbox.Backspace then
                    if utility:InputToString(Input.KeyCode) == "Back" then
                        window.currentContent.textbox.Backspace = nil
                    end
                end
            end
            --
            library.changed[#library.changed + 1] = function(Input)
                if window.dragging and window.isVisible then
                    local mouseLocation = utility:MouseLocation()
                    if utility:GetScreenSize().Y-main_frame.Size.Y-5 > 5 then
                        local move = Vector2.new(Clamp(mouseLocation.X - window.drag.X, 5, utility:GetScreenSize().X-main_frame.Size.X-5), Clamp(mouseLocation.Y - window.drag.Y, 5, utility:GetScreenSize().Y-main_frame.Size.Y-5))
                        window:Move(move)
                    else
                        local move = Vector2.new(mouseLocation.X - window.drag.X, mouseLocation.Y - window.drag.Y)
                        window:Move(move)
                    end
                end
            end
            --
            library.began[#library.began + 1] = function(Input)
                if Input.KeyCode == window.uibind and window.init == true then
                    window:Fade()
                end
            end
            --
            utility:Connection(Uis.InputBegan, (function(Input)
                for _, func in pairs(library.began) do
                    if not window.dragging then
                        local e,s = pcall(function()
                            func(Input)
                        end)
                    else
                        break
                    end
                end
            end))
            --
            utility:Connection(Uis.InputEnded, (function(Input)
                for _, func in pairs(library.ended) do
                    local e,s = pcall(function()
                        func(Input)
                    end)
                end
            end))
            --
            utility:Connection(Uis.InputChanged, (function()
                for _, func in pairs(library.changed) do
                    local e,s = pcall(function()
                        func()
                    end)
                end
            end))
            --
            utility:Connection(RS.RenderStepped, (function()
                if window.currentContent.textbox and window.currentContent.textbox.Fire and window.currentContent.textbox.Backspace then
                    local Time = (tick() - window.currentContent.textbox.Backspace[1])
                    --
                    if Time > 0.4 then
                        window.currentContent.textbox.Backspace[2] = window.currentContent.textbox.Backspace[2] + 1
                        --
                        if (window.currentContent.textbox.Backspace[2] % 5 == 0) then
                            window.currentContent.textbox.Fire("Backspace")
                        end
                    end
                end
            end))
            --
            utility:Connection(Workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"), (function()
                window:Move(Vector2.new((utility:GetScreenSize().X/2) - (size.X/2), (utility:GetScreenSize().Y/2) - (size.Y/2)))
            end))
            --
            return setmetatable(window, library)
        end
        --
        function library:Page(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "New Page"
            --
            local window = self
            --
            local page = {open = false, sections = {}, sectionOffset = {left = 0, right = 0}, window = window}
            --
            local position = 4
            --
            for i, v in pairs(window.pages) do
                position = position + (v.page_button.Size.X + 2)
            end
            --
            local textbounds = utility:GetTextBounds(name, theme.textsize, theme.font)
            --
            local page_button = utility:Create("Frame", {Vector2.new(position, 4), window.back_frame}, {
                Size = utility:Size(0, window.pageammount and (((window.back_frame.Size.X - 8 - ((window.pageammount - 1) * 2)) / window.pageammount)) or (textbounds.X + 20), 0, 21),
                Position = utility:Position(0, position, 0, 4, window.back_frame),
                Color = theme.outline
            }); page["page_button"] = page_button
            --
            library.colors[page_button] = {
                Color = "outline"
            }
            --
            local page_button_inline = utility:Create("Frame", {Vector2.new(1, 1), page_button}, {
                Size = utility:Size(1, -2, 1, -1, page_button),
                Position = utility:Position(0, 1, 0, 1, page_button),
                Color = theme.inline
            }); page["page_button_inline"] = page_button_inline
            --
            library.colors[page_button_inline] = {
                Color = "inline"
            }
            --
            local page_button_color = utility:Create("Frame", {Vector2.new(1, 1), page_button_inline}, {
                Size = utility:Size(1, -2, 1, -1, page_button_inline),
                Position = utility:Position(0, 1, 0, 1, page_button_inline),
                Color = theme.darkcontrast
            }); page["page_button_color"] = page_button_color
            --
            library.colors[page_button_color] = {
                Color = "darkcontrast"
            }
            --
            local page_button_title = utility:Create("TextLabel", {Vector2.new(utility:Position(0.5, 0, 0, 2, page_button_color).X - page_button_color.Position.X, 2), page_button_color}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textdark,
                Center = true,
                OutlineColor = theme.textborder,
                Position = utility:Position(0.5, 0, 0, 2, page_button_color)
            }); page["page_button_title"] = page_button_title
            --
            library.colors[page_button_title] = {
                OutlineColor = "textborder",
                Color = "textdark"
            }
            
            local page_accent = utility:Create("Frame", {Vector2.new(0, 0), page_button_color}, {
                Size = utility:Size(1, 0, 0, 2, page_button_color),
                Position = utility:Position(0, 0, 0, 0, page_button_color),
                Color = theme.accent,
                Visible = page.open
            }); page["page_accent"] = page_accent

            --
            library.colors[page_accent] = {
                Color = "accent"
            }
        
            --
            window.pages[#window.pages + 1] = page
            --
            function page:GetTotalYSize(Side)
                local TotalYSize = 0
                --
                for i, v in pairs(page.sections) do
                    if v.side == Side then
                        TotalYSize = TotalYSize + v.section_inline.Size.Y + 5
                    end
                end
                --
                return TotalYSize
            end
            --
            function page:Update()
                page.sectionOffset["left"] = 0
                page.sectionOffset["right"] = 0
                --
                for i, v in pairs(page.sections) do
                    if v.side then
                        utility:UpdateOffset(v.section_inline, {Vector2.new(v.side == "right" and (window.tab_frame.Size.X / 2) + 2 or 5, 5 + page["sectionOffset"][v.side]), window.tab_frame})
                        v:Update(page.sectionOffset[v.side] + 10)
                        page.sectionOffset[v.side] = page.sectionOffset[v.side] + v.section_inline.Size.Y + 5
                    else
                        page.sectionOffset["left"] = page.sectionOffset["left"] + v["playerList_inline"].Size.Y + 5
                        page.sectionOffset["right"] = page.sectionOffset["right"] + v["playerList_inline"].Size.Y + 5
                    end
                end
                --
                window:Move(window.main_frame.Position)
            end
            --
            function page:Show()
                if window.currentPage then
                    window.currentPage.page_button_color.Size = utility:Size(1, -2, 1, -1, window.currentPage.page_button_inline)
                    window.currentPage.page_button_color.Color = theme.darkcontrast
                    window.currentPage.page_button_title.Color = theme.textdark
                    window.currentPage.page_accent.Visible = false
                    window.currentPage.open = false
                    --
                    library.colors[window.currentPage.page_button_color] = {
                        Color = "darkcontrast"
                    }
                    --
                    library.colors[window.currentPage.page_button_title] = {
                        OutlineColor = "textborder",
                        Color = "textdark"
                    }
                    --
                    for i, v in pairs(window.currentPage.sections) do
                        for z, x in pairs(v.visibleContent) do
                            x.Visible = false
                        end
                    end
                    --
                    window:CloseContent()
                end
                --
                window.currentPage = page
                page_button_color.Size = utility:Size(1, -2, 1, 0, page_button_inline)
                page_button_color.Color = theme.lightcontrast
                page_button_title.Color = theme.textcolor
                page_accent.Visible = true -- Make the accent visible when this page is shown
                page.open = true
                --
                library.colors[page_button_color] = {
                    Color = "lightcontrast"
                }
                --
                library.colors[page_button_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                for i, v in pairs(page.sections) do
                    for z, x in pairs(v.visibleContent) do
                        x.Visible = true
                    end
                end
                --
                window.callback(name, window.currentPage)
                window:Move(window.main_frame.Position)
            end
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and utility:MouseOverDrawing({page_button.Position.X, page_button.Position.Y, page_button.Position.X + page_button.Size.X, page_button.Position.Y + page_button.Size.Y}) and window.currentPage ~= page then
                    page:Show()
                end
            end
            --
            return setmetatable(page, pages)
        end
        --
        function pages:Section(info)
            local window = self.window
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "New Section"
            local size = info.size or info.Size
            local fill = info.fill or info.Fill
            local side = window.loader and "left" or (info.side or info.Side or "left")
            side = side:lower()
            local page = self
            local section = {window = window, page = page, visibleContent = {}, currentAxis = 20, side = side}
            --
            local section_inline = utility:Create("Frame", {Vector2.new(side == "right" and (window.tab_frame.Size.X/2)+2 or 5,5 + page["sectionOffset"][side]), window.tab_frame}, {
                Size = utility:Size(window.loader and 1 or 0.5, window.loader and -10 or -7, 0, size or 22, window.tab_frame),
                Position = utility:Position(side == "right" and 0.5 or 0, side == "right" and 2 or 5, 0, 5 + page.sectionOffset[side], window.tab_frame),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent);section["section_inline"] = section_inline
            --
            library.colors[section_inline] = {
                Color = "inline"
            }
            --
            local section_outline = utility:Create("Frame", {Vector2.new(1,1), section_inline}, {
                Size = utility:Size(1, -2, 1, -2, section_inline),
                Position = utility:Position(0, 1, 0, 1, section_inline),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent);section["section_outline"] = section_outline
            --
            library.colors[section_outline] = {
                Color = "outline"
            }
            --
            local section_frame = utility:Create("Frame", {Vector2.new(1,1), section_outline}, {
                Size = utility:Size(1, -2, 1, -2, section_outline),
                Position = utility:Position(0, 1, 0, 1, section_outline),
                Color = theme.darkcontrast,
                Visible = page.open
            }, section.visibleContent);section["section_frame"] = section_frame
            --
            library.colors[section_frame] = {
                Color = "darkcontrast"
            }
            --
            local section_accent = utility:Create("Frame", {Vector2.new(0,0), section_frame}, {
                Size = utility:Size(1, 0, 0, 2, section_frame),
                Position = utility:Position(0, 0, 0, 0, section_frame),
                Color = theme.accent,
                Visible = page.open
            }, section.visibleContent);section["section_accent"] = section_accent
            --
            library.colors[section_accent] = {
                Color = "accent"
            }
            --
            local section_title = utility:Create("TextLabel", {Vector2.new(3,3), section_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 3, 0, 3, section_frame),
                Visible = page.open
            }, section.visibleContent);section["section_title"] = section_title
            --
            library.colors[section_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            function section:Update(Padding)
                section_inline.Size = utility:Size(window.loader and 1 or 0.5, window.loader and -10 or -7, 0, fill and (window.tab_frame.Size.Y - (Padding or 0)) or (size or (section.currentAxis+4)), window.tab_frame)
                section_outline.Size = utility:Size(1, -2, 1, -2, section_inline)
                section_frame.Size = utility:Size(1, -2, 1, -2, section_outline)
            end
            --
            page.sectionOffset[side] = page.sectionOffset[side] + 100 + 5
            page.sections[#page.sections + 1] = section
            --
            return setmetatable(section, sections)
        end
        --
        function pages:MultiSection(info)
            local info = info or {}
            local msections = info.sections or info.Sections or {}
            local side = info.side or info.Side or "left"
            local size = info.size or info.Size or 150
            local fill = info.fill or info.Fill
            local callback = info.callback or info.Callback or info.callBack or info.CallBack or function() end
            side = side:lower()
            local window = self.window
            local page = self
            local multiSection = {window = window, page = page, sections = {}, backup = {}, visibleContent = {}, currentSection = nil, side = side}
            --
            local multiSection_inline = utility:Create("Frame", {Vector2.new(side == "right" and (window.tab_frame.Size.X/2)+2 or 5,5 + page["sectionOffset"][side]), window.tab_frame}, {
                Size = utility:Size(window.loader and 1 or 0.5, window.loader and -10 or -7, 0, size, window.tab_frame),
                Position = utility:Position(side == "right" and 0.5 or 0, side == "right" and 2 or 5, 0, 5 + page.sectionOffset[side], window.tab_frame),
                Color = theme.inline,
                Visible = page.open
            }, multiSection.visibleContent);multiSection["section_inline"] = multiSection_inline
            --
            library.colors[multiSection_inline] = {
                Color = "inline"
            }
            --
            local multiSection_outline = utility:Create("Frame", {Vector2.new(1,1), multiSection_inline}, {
                Size = utility:Size(1, -2, 1, -2, multiSection_inline),
                Position = utility:Position(0, 1, 0, 1, multiSection_inline),
                Color = theme.outline,
                Visible = page.open
            }, multiSection.visibleContent);multiSection["section_outline"] = multiSection_outline
            --
            library.colors[multiSection_outline] = {
                Color = "outline"
            }
            --
            local multiSection_frame = utility:Create("Frame", {Vector2.new(1,1), multiSection_outline}, {
                Size = utility:Size(1, -2, 1, -2, multiSection_outline),
                Position = utility:Position(0, 1, 0, 1, multiSection_outline),
                Color = theme.darkcontrast,
                Visible = page.open
            }, multiSection.visibleContent);multiSection["section_frame"] = multiSection_frame
            --
            library.colors[multiSection_frame] = {
                Color = "darkcontrast"
            }
            --
            local multiSection_backFrame = utility:Create("Frame", {Vector2.new(0,2), multiSection_frame}, {
                Size = utility:Size(1, 0, 0, 17, multiSection_frame),
                Position = utility:Position(0, 0, 0, 2, multiSection_frame),
                Color = theme.lightcontrast,
                Visible = page.open
            }, multiSection.visibleContent)
            --
            library.colors[multiSection_backFrame] = {
                Color = "lightcontrast"
            }
            --
            local multiSection_bottomFrame = utility:Create("Frame", {Vector2.new(0,multiSection_backFrame.Size.Y - 1), multiSection_backFrame}, {
                Size = utility:Size(1, 0, 0, 1, multiSection_backFrame),
                Position = utility:Position(0, 0, 1, -1, multiSection_backFrame),
                Color = theme.outline,
                Visible = page.open
            }, multiSection.visibleContent)
            --
            library.colors[multiSection_bottomFrame] = {
                Color = "outline"
            }
            --
            local multiSection_accent = utility:Create("Frame", {Vector2.new(0,0), multiSection_frame}, {
                Size = utility:Size(1, 0, 0, 2, multiSection_frame),
                Position = utility:Position(0, 0, 0, 0, multiSection_frame),
                Color = theme.accent,
                Visible = page.open
            }, multiSection.visibleContent);multiSection["section_accent"] = multiSection_accent
            --
            library.colors[multiSection_accent] = {
                Color = "accent"
            }
            --
            function multiSection:Update(Padding)
                multiSection_inline.Size = utility:Size(window.loader and 1 or 0.5, window.loader and -10 or -7, 0, fill and (window.tab_frame.Size.Y - (Padding or 0)) or size, window.tab_frame)
                multiSection_outline.Size = utility:Size(1, -2, 1, -2, multiSection_inline)
                multiSection_frame.Size = utility:Size(1, -2, 1, -2, multiSection_outline)
                --
                for Index, Value in pairs(multiSection.sections) do
                    Value:Update(Padding)
                end
            end
            --
            for i,v in pairs(msections) do
                local msection = {window = window, page = page, currentAxis = 24, sections = {}, visibleContent = {}, section_inline = multiSection_inline, section_outline = multiSection_outline, section_frame = multiSection_frame, section_accent = multiSection_accent}
                --
                local textBounds = utility:GetTextBounds(v, theme.textsize, theme.font)
                --
                local msection_frame = utility:Create("Frame", {Vector2.new(((i - 1) * (1 / #msections)) * multiSection_backFrame.Size.X,0), multiSection_backFrame}, {
                    Size = utility:Size(1 / #msections, 0, 1, -1, multiSection_backFrame),
                    Position = utility:Position((i - 1) * (1 / #msections), 0, 0, 0, multiSection_backFrame),
                    Color = i == 1 and theme.darkcontrast or theme.lightcontrast,
                    Visible = page.open
                }, multiSection.visibleContent);msection["msection_frame"] = msection_frame
                --
                library.colors[msection_frame] = {
                    Color = i == 1 and "darkcontrast" or "lightcontrast"
                }
                --
                local msection_line = utility:Create("Frame", {Vector2.new(msection_frame.Size.X - (i == #msections and 0 or 1),0), msection_frame}, {
                    Size = utility:Size(0, 1, 1, 0, msection_frame),
                    Position = utility:Position(1, -(i == #msections and 0 or 1), 0, 0, msection_frame),
                    Color = theme.outline,
                    Visible = page.open
                }, multiSection.visibleContent)
                --
                library.colors[msection_line] = {
                    Color = "outline"
                }
                --
                local msection_title = utility:Create("TextLabel", {Vector2.new(msection_frame.Size.X * 0.5,1), msection_frame}, {
                    Text = v,
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Center = true,
                    Position = utility:Position(0.5, 0, 0, 1, msection_frame),
                    Visible = page.open
                }, multiSection.visibleContent)
                --
                library.colors[msection_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                local msection_bottomline = utility:Create("Frame", {Vector2.new(0,msection_frame.Size.Y), msection_frame}, {
                    Size = utility:Size(1, (i == #msections and 0 or -1), 0, 1, msection_frame),
                    Position = utility:Position(0, 0, 1, 0, msection_frame),
                    Color = i == 1 and theme.darkcontrast or theme.outline,
                    Visible = page.open
                }, multiSection.visibleContent);msection["msection_bottomline"] = msection_bottomline
                --
                library.colors[msection_bottomline] = {
                    Color = i == 1 and "darkcontrast" or "outline"
                }
                --
                function msection:Update()
                    if multiSection.currentSection == msection then
                        multiSection.visibleContent = utility:Combine(multiSection.backup, multiSection.currentSection.visibleContent)
                    else
                        for z,x in pairs(msection.visibleContent) do
                            x.Visible = false
                        end
                    end
                end
                --
                library.began[#library.began + 1] = function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and page.open and  utility:MouseOverDrawing({msection_frame.Position.X,msection_frame.Position.Y,msection_frame.Position.X + msection_frame.Size.X,msection_frame.Position.Y + msection_frame.Size.Y}) and multiSection.currentSection ~= msection and not window:IsOverContent() then
                        multiSection.currentSection.msection_frame.Color = theme.lightcontrast
                        multiSection.currentSection.msection_bottomline.Color = theme.outline
                        --
                        library.colors[multiSection.currentSection.msection_frame] = {
                            Color = "lightcontrast"
                        }
                        --
                        library.colors[multiSection.currentSection.msection_bottomline] = {
                            Color = "outline"
                        }
                        --
                        for i,v in pairs(multiSection.currentSection.visibleContent) do
                            v.Visible = false
                        end
                        --
                        multiSection.currentSection = msection
                        msection_frame.Color = theme.darkcontrast
                        msection_bottomline.Color = theme.darkcontrast
                        --
                        library.colors[msection_frame] = {
                            Color = "darkcontrast"
                        }
                        --
                        library.colors[msection_bottomline] = {
                            Color = "darkcontrast"
                        }
                        --
                        for i,v in pairs(multiSection.currentSection.visibleContent) do
                            v.Visible = true
                        end
                        --
                        multiSection.visibleContent = utility:Combine(multiSection.backup, multiSection.currentSection.visibleContent)
                        --
                        callback(v, msection)
                        window:Move(window.main_frame.Position)
                    end
                end
                --
                if i == 1 then
                    multiSection.currentSection = msection
                    callback(v, msection)
                end
                --
                multiSection.sections[#multiSection.sections + 1] = setmetatable(msection, sections)
            end
            --
            for z,x in pairs(multiSection.visibleContent) do
                multiSection.backup[z] = x
            end
            --
            page.sectionOffset[side] = page.sectionOffset[side] + 100 + 5
            page.sections[#page.sections + 1] = multiSection
            --
            return Unpack(multiSection.sections)
        end
        --
        function pages:PlayerList(info)
            local info = info or {}
            --
            local window = self.window
            local page = self
            --
            local playerList = {window = window, page = page, visibleContent = {}, buttons = {}, currentAxis = 20, scrollingindex = 0, scrolling = {false, nil}, items = {}, players = {}}
            --
            local playerList_inline = utility:Create("Frame", {Vector2.new(5,5), window.tab_frame}, {
                Size = utility:Size(1, -10, 0, ((10 * 22) + 4) + 20 + 60 + 12, window.tab_frame),
                Position = utility:Position(0, 5, 0, 5, window.tab_frame),
                Color = theme.inline,
                Visible = page.open
            }, playerList.visibleContent);playerList["playerList_inline"] = playerList_inline
            --
            library.colors[playerList_inline] = {
                Color = "inline"
            }
            --
            local playerList_outline = utility:Create("Frame", {Vector2.new(1,1), playerList_inline}, {
                Size = utility:Size(1, -2, 1, -2, playerList_inline),
                Position = utility:Position(0, 1, 0, 1, playerList_inline),
                Color = theme.outline,
                Visible = page.open
            }, playerList.visibleContent);playerList["playerList_outline"] = playerList_outline
            --
            library.colors[playerList_outline] = {
                Color = "outline"
            }
            --
            local playerList_frame = utility:Create("Frame", {Vector2.new(1,1), playerList_outline}, {
                Size = utility:Size(1, -2, 1, -2, playerList_outline),
                Position = utility:Position(0, 1, 0, 1, playerList_outline),
                Color = theme.darkcontrast,
                Visible = page.open
            }, playerList.visibleContent);playerList["playerList_frame"] = playerList_frame
            --
            library.colors[playerList_frame] = {
                Color = "darkcontrast"
            }
            --
            local playerList_accent = utility:Create("Frame", {Vector2.new(0,0), playerList_frame}, {
                Size = utility:Size(1, 0, 0, 2, playerList_frame),
                Position = utility:Position(0, 0, 0, 0, playerList_frame),
                Color = theme.accent,
                Visible = page.open
            }, playerList.visibleContent);playerList["playerList_accent"] = playerList_accent
            --
            library.colors[playerList_accent] = {
                Color = "accent"
            }
            --
            local playerList_title = utility:Create("TextLabel", {Vector2.new(3,3), playerList_frame}, {
                Text = "Player List - 0 Players",
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 3, 0, 3, playerList_frame),
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[playerList_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            local list_outline = utility:Create("Frame", {Vector2.new(4,20), playerList_frame}, {
                Size = utility:Size(1, -8, 0, ((10 * 22) + 4), playerList_frame),
                Position = utility:Position(0, 4, 0, 20, playerList_frame),
                Color = theme.outline,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[list_outline] = {
                Color = "outline"
            }
            --
            local list_inline = utility:Create("Frame", {Vector2.new(1,1), list_outline}, {
                Size = utility:Size(1, -2, 1, -2, list_outline),
                Position = utility:Position(0, 1, 0, 1, list_outline),
                Color = theme.inline,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[list_inline] = {
                Color = "inline"
            }
            --
            local list_frame = utility:Create("Frame", {Vector2.new(1,1), list_inline}, {
                Size = utility:Size(1, -10, 1, -2, list_inline),
                Position = utility:Position(0, 1, 0, 1, list_inline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[list_frame] = {
                Color = "lightcontrast"
            }
            --
            local list_scroll = utility:Create("Frame", {Vector2.new(list_inline.Size.X - 9,1), list_inline}, {
                Size = utility:Size(0, 8, 1, -2, list_inline),
                Position = utility:Position(1, -9, 0, 1, list_inline),
                Color = theme.darkcontrast,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[list_scroll] = {
                Color = "darkcontrast"
            }
            --
            local list_bar = utility:Create("Frame", {Vector2.new(1,1), list_scroll}, {
                Size = utility:Size(1, -2, 0.5, -2, list_scroll),
                Position = utility:Position(0, 1, 0, 1, list_scroll),
                Color = theme.accent,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[list_bar] = {
                Color = "accent"
            }
            --
            local list_gradient = utility:Create("Image", {Vector2.new(0,0), list_frame}, {
                Size = utility:Size(1, 0, 1, 0, list_frame),
                Position = utility:Position(0, 0, 0 , 0, list_frame),
                Transparency = 0.25,
                Visible = page.open
            }, playerList.visibleContent)
            --
            for Index = 1, 10 do
                local item = {}
                local listitemposition = (Index - 1) * 22
                --
                local listitem_line
                --
                if Index ~= 10 then
                    listitem_line = utility:Create("Frame", {Vector2.new(3,listitemposition + 21), list_frame}, {
                        Size = utility:Size(1, -6, 0, 2, list_frame),
                        Position = utility:Position(0, 3, 0, listitemposition + 21, list_frame),
                        Transparency = 0,
                        Color = theme.outline,
                        Visible = page.open
                    }, playerList.visibleContent)
                    --
                    library.colors[listitem_line] = {
                        Color = "outline"
                    }
                end
                --
                local listitem_firstline = utility:Create("Frame", {Vector2.new(1/3 * list_frame.Size.X,listitemposition + 3), list_frame}, {
                    Size = utility:Size(0, 2, 0, 16, list_frame),
                    Position = utility:Position(1/3, 1, 0, listitemposition + 3, list_frame),
                    Transparency = 0,
                    Color = theme.outline,
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[listitem_firstline] = {
                    Color = "outline"
                }
                --
                local listitem_secondline = utility:Create("Frame", {Vector2.new(2/3 * list_frame.Size.X,listitemposition + 3), list_frame}, {
                    Size = utility:Size(0, 2, 0, 16, list_frame),
                    Position = utility:Position(2/3, 1, 0, listitemposition + 3, list_frame),
                    Transparency = 0,
                    Color = theme.outline,
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[listitem_secondline] = {
                    Color = "outline"
                }
                --
                local listitem_username = utility:Create("TextLabel", {Vector2.new(4, 4 + listitemposition), list_frame}, {
                    Text = "",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Position = utility:Position(0, 4, 0, 4 + listitemposition, list_frame),
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[listitem_username] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                local listitem_team = utility:Create("TextLabel", {Vector2.new(6 + (1/3 * list_frame.Size.X), 4 + listitemposition), list_frame}, {
                    Text = "",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Position = utility:Position(1/3, 6, 0, 4 + listitemposition, list_frame),
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[listitem_team] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                local listitem_status = utility:Create("TextLabel", {Vector2.new(6 + (2/3 * list_frame.Size.X), 4 + listitemposition), list_frame}, {
                    Text = "",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Position = utility:Position(2/3, 6, 0, 4 + listitemposition, list_frame),
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[listitem_status] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                function item:Set(enabled, selected)
                    if listitem_line then
                        if window.isVisible then
                            listitem_line.Transparency = enabled and 0.3 or 0
                        end
                        --
                        utility:UpdateTransparency(listitem_line, enabled and 0.3 or 0)
                    end
                    --
                    if window.isVisible then
                        listitem_firstline.Transparency = enabled and 0.3 or 0
                        listitem_secondline.Transparency = enabled and 0.3 or 0
                    end
                    --
                    utility:UpdateTransparency(listitem_firstline, enabled and 0.3 or 0)
                    utility:UpdateTransparency(listitem_secondline, enabled and 0.3 or 0)
                    --
                    if enabled then
                        listitem_username.Text = selected[2]
                        listitem_team.Text = selected[1].Team and tostring(selected[1].Team) or "None"
                        listitem_status.Text = selected[3]
                        --
                        listitem_username.Color = selected[4] and theme.accent or theme.textcolor
                        listitem_status.Color = selected[3] == "Local Player" and Color3.fromRGB(200, 55, 200) or selected[3] == "Priority" and Color3.fromRGB(55, 55, 200) or selected[3] == "Friend" and Color3.fromRGB(55, 200, 55) or selected[3] == "Enemy" and Color3.fromRGB(200, 55, 55) or theme.textcolor
                        --
                        library.colors[listitem_username] = {
                            OutlineColor = "textborder",
                            Color = selected[4] and "accent" or "textcolor"
                        }
                        -- 
                        library.colors[listitem_status] = {
                            OutlineColor = "textborder",
                            Color = selected[3] == "None" and "textcolor" or nil
                        }
                    else
                        listitem_username.Text = ""
                        listitem_team.Text = ""
                        listitem_status.Text = ""
                    end
                end
                --
                playerList.items[#playerList.items + 1] = item
            end
            --
            local options_iconoutline = utility:Create("Frame", {Vector2.new(0,list_outline.Size.Y + 4), list_outline}, {
                Size = utility:Size(0, 60, 0, 60, list_outline),
                Position = utility:Position(0, 0, 1, 4, list_outline),
                Color = theme.outline,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[options_iconoutline] = {
                Color = "outline"
            }
            --
            local options_iconinline = utility:Create("Frame", {Vector2.new(1,1), options_iconoutline}, {
                Size = utility:Size(1, -2, 1, -2, options_iconoutline),
                Position = utility:Position(0, 1, 0, 1, options_iconoutline),
                Color = theme.inline,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[options_iconinline] = {
                Color = "inline"
            }
            --
            local options_iconframe = utility:Create("Frame", {Vector2.new(1,1), options_iconinline}, {
                Size = utility:Size(1, -2, 1, -2, options_iconinline),
                Position = utility:Position(0, 1, 0, 1, options_iconinline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[options_iconframe] = {
                Color = "lightcontrast"
            }
            --
            local options_avatar = utility:Create("Image", {Vector2.new(0,0), options_iconframe}, {
                Size = utility:Size(1, 0, 1, 0, options_iconframe),
                Position = utility:Position(0, 0, 0 , 0, options_iconframe),
                Transparency = 0.8,
                Visible = page.open
            }, playerList.visibleContent)
            --
            local options_loadingtext = utility:Create("TextLabel", {Vector2.new((options_iconoutline.Size.X / 2) - 1, (options_iconoutline.Size.X / 2) - 10), options_iconframe}, {
                Text = "..?",
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textdark,
                OutlineColor = theme.textborder,
                Position = utility:Position(0.5, -1, 0.5, -10, options_iconframe),
                Center = true,
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[options_loadingtext] = {
                OutlineColor = "textborder",
                Color = "textdark"
            }
            --
            local options_title = utility:Create("TextLabel", {Vector2.new(options_iconoutline.Size.X + 5, 0), options_iconoutline}, {
                Text = "No player selected.", -- ("Display Name : %s\nName : %s\nHealth : %s/%s"):format("gg_bbot", "1envo", "100", "100")
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(1, 5, 0, 0, options_iconoutline),
                Visible = page.open
            }, playerList.visibleContent)
            --
            library.colors[options_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            for Index = 1, 1 do
                local button = {
                    open = false,
                    current = "None",
                    options = {"None", "Friend", "Enemy", "Priority"},
                    holder = {buttons = {}, drawings = {}},
                    selection = nil
                }
                --
                local button_outline = utility:Create("Frame", {Vector2.new(list_outline.Size.X - 180, list_outline.Size.Y + (Index == 1 and 10 or 36)), list_outline}, {
                    Size = utility:Size(0, 180, 0, 22, list_outline),
                    Position = utility:Position(1, -180, 1, Index == 1 and 10 or 36, list_outline),
                    Color = theme.outline,
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[button_outline] = {
                    Color = "outline"
                }
                --
                local button_inline = utility:Create("Frame", {Vector2.new(1,1), button_outline}, {
                    Size = utility:Size(1, -2, 1, -2, button_outline),
                    Position = utility:Position(0, 1, 0, 1, button_outline),
                    Color = theme.inline,
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[button_inline] = {
                    Color = "inline"
                }
                --
                local button_frame = utility:Create("Frame", {Vector2.new(1,1), button_inline}, {
                    Size = utility:Size(1, -2, 1, -2, button_inline),
                    Position = utility:Position(0, 1, 0, 1, button_inline),
                    Color = theme.lightcontrast,
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[button_frame] = {
                    Color = "lightcontrast"
                }
                --
                local button_gradient = utility:Create("Image", {Vector2.new(0,0), button_frame}, {
                    Size = utility:Size(1, 0, 1, 0, button_frame),
                    Position = utility:Position(0, 0, 0 , 0, button_frame),
                    Transparency = 0.5,
                    Visible = page.open
                }, playerList.visibleContent)
                --
                local button_title = utility:Create("TextLabel", {Vector2.new(button_frame.Size.X/2,1), button_frame}, {
                    Text = Index == 1 and "Prioritise" or "Friendly",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Center = true,
                    Position = utility:Position(0.5, 0, 0, 1, button_frame),
                    Visible = page.open
                }, playerList.visibleContent)
                --
                library.colors[button_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                local button_image = utility:Create("Image", {Vector2.new(button_frame.Size.X - 15,button_frame.Size.Y/2 - 3), button_frame}, {
                    Size = utility:Size(0, 9, 0, 6, button_frame),
                    Position = utility:Position(1, -15, 0.5, -3, button_frame),
                    Visible = page.open
                }, playerList.visibleContent)
                --
                utility:LoadImage(button_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                --
                function button:Update(Selection)
                    local Visible = Selection ~= nil and (Selection[1] ~= Client) or false
                    --
                    for Index, Value in pairs({button_outline, button_inline, button_frame, button_gradient, button_title, button_image}) do
                        Value.Visible = page.open and Visible or false
                        --
                        if Visible then
                            local fnd = Find(playerList.visibleContent, Value)
                            --
                            if not fnd then
                                playerList.visibleContent[#playerList.visibleContent + 1] = Value
                            end
                        else
                            local fnd = Find(playerList.visibleContent, Value)
                            --
                            if fnd then
                                Remove(playerList.visibleContent, fnd)
                            end
                        end
                    end
                    --
                    if Selection then
                        button_title.Text = Selection[3]
                        button.current = Selection[3]
                        button.selection = Selection
                    else
                        button.selection = nil
                    end
                end
                --
                function button:UpdateValue()
                    if button.open and button.holder.inline then
                        for i,v in pairs(button.holder.buttons) do
                            local value = button.options[i]
                            --
                            v[1].Text = value
                            v[1].Color = value == tostring(button.current) and theme.accent or theme.textcolor
                            v[1].Position = utility:Position(0, value == tostring(button.current) and 8 or 6, 0, 2, v[2])
                            library.colors[v[1]] = {
                                Color = v[1].Text == tostring(button.current) and "accent" or "textcolor"
                            }
                            utility:UpdateOffset(v[1], {Vector2.new(v[1].Text == tostring(button.current) and 8 or 6, 2), v[2]})
                        end
                    end
                end
                --
                function button:Close()
                    button.open = not button.open
                    utility:LoadImage(button_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                    --
                    for i,v in pairs(button.holder.drawings) do
                        utility:Remove(v)
                    end
                    --
                    button.holder.drawings = {}
                    button.holder.buttons = {}
                    button.holder.inline = nil
                    --
                    window.currentContent.frame = nil
                    window.currentContent.button = nil
                end
                --
                function button:Open()
                    window:CloseContent()
                    button.open = not button.open
                    utility:LoadImage(button_image, "arrow_up", "https://i.imgur.com/SL9cbQp.png")
                    --
                    local button_open_outline = utility:Create("Frame", {Vector2.new(0,21), button_outline}, {
                        Size = utility:Size(1, 0, 0, 3 + (#button.options * 19), button_outline),
                        Position = utility:Position(0, 0, 0, 21, button_outline),
                        Color = theme.outline,
                        Visible = page.open
                    }, button.holder.drawings);button.holder.outline = button_open_outline
                    --
                    library.colors[button_open_outline] = {
                        Color = "outline"
                    }
                    --
                    local button_open_inline = utility:Create("Frame", {Vector2.new(1,1), button_open_outline}, {
                        Size = utility:Size(1, -2, 1, -2, button_open_outline),
                        Position = utility:Position(0, 1, 0, 1, button_open_outline),
                        Color = theme.inline,
                        Visible = page.open
                    }, button.holder.drawings);button.holder.inline = button_open_inline
                    --
                    library.colors[button_open_inline] = {
                        Color = "inline"
                    }
                    --
                    for Index = 1, (#button.options) do
                        local Value = button.options[Index]
                        --
                        if Value then
                            local button_value_frame = utility:Create("Frame", {Vector2.new(1,1 + (19 * (Index-1))), button_open_inline}, {
                                Size = utility:Size(1, -2, 0, 18, button_open_inline),
                                Position = utility:Position(0, 1, 0, 1 + (19 * (Index-1)), button_open_inline),
                                Color = theme.lightcontrast,
                                Visible = page.open
                            }, button.holder.drawings)
                            --
                            library.colors[button_value_frame] = {
                                Color = "lightcontrast"
                            }
                            --
                            local button_value = utility:Create("TextLabel", {Vector2.new(Value == tostring(button.current) and 8 or 6,2), button_value_frame}, {
                                Text = Value,
                                Size = theme.textsize,
                                Font = theme.font,
                                Color = Value == tostring(button.current) and theme.accent or theme.textcolor,
                                OutlineColor = theme.textborder,
                                Position = utility:Position(0, Value == tostring(button.current) and 8 or 6, 0, 2, button_value_frame),
                                Visible = page.open
                            }, button.holder.drawings)
                            --
                            button.holder.buttons[#button.holder.buttons + 1] = {button_value, button_value_frame}
                            --
                            library.colors[button_value] = {
                                OutlineColor = "textborder",
                                Color = Value == tostring(button.current) and "accent" or "textcolor"
                            }
                        end
                    end
                    --
                    window.currentContent.frame = button_open_inline
                    window.currentContent.button = button
                end
                --
                utility:LoadImage(button_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                --
                library.began[#library.began + 1] = function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 and (button_outline.Visible or button.open) and window.isVisible then
                        if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and button_outline.Visible then
                            if button.open and button.holder.inline and utility:MouseOverDrawing({button.holder.inline.Position.X, button.holder.inline.Position.Y, button.holder.inline.Position.X + button.holder.inline.Size.X, button.holder.inline.Position.Y + button.holder.inline.Size.Y}) then
                                for i,v in pairs(button.holder.buttons) do
                                    local value = button.options[i]
                                    --
                                    if utility:MouseOverDrawing({v[2].Position.X, v[2].Position.Y, v[2].Position.X + v[2].Size.X, v[2].Position.Y + v[2].Size.Y}) and value ~= button.current then
                                        button.current = value
                                        button_title.Text = button.current
            
                                        if button.selection then
                                            button.selection[3] = value
                                            playerList:Refresh(button.selection)
                                        end
            
                                        button:UpdateValue()
                                    end
                                end
                            elseif utility:MouseOverDrawing({button_outline.Position.X, button_outline.Position.Y, button_outline.Position.X + button_outline.Size.X, button_outline.Position.Y + button_outline.Size.Y}) and not window:IsOverContent() then
                                Spawn(function()
                                    utility:LoadImage(button_gradient, "gradientdown", "https://i.imgur.com/DzrzUt3.png") 
                                    --
                                    Wait(0.15)
                                    --
                                    utility:LoadImage(button_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png") 
                                end)
                                --
                                if not button.open then
                                    button:Open()
                                else
                                    button:Close()
                                end
                            else
                                if button.open then
                                    button:Close()
                                end
                            end
                        elseif Input.UserInputType == Enum.UserInputType.MouseButton1 and button.open then
                            button:Close()
                        end
                    end
                end
                --
                playerList.buttons[#playerList.buttons + 1] = button
            end
            --
            utility:LoadImage(list_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function playerList:GetSelection()
                for Index, Value in pairs(playerList.players) do
                    if Value[4] then
                        return Value
                    end
                end
            end
            --
            function playerList:UpdateScroll()
                if (#playerList.players - 10) > 0 then
                    playerList.scrollingindex = Clamp(playerList.scrollingindex, 0, (#playerList.players - 10))
                    --
                    list_bar.Transparency = window.isVisible and 1 or 0
                    list_bar.Size = utility:Size(1, -2, (10 / #playerList.players), -2, list_scroll)
                    list_bar.Position = utility:Position(0, 1, 0, 1 + ((((list_scroll.Size.Y - 2) - list_bar.Size.Y) / (#playerList.players - 10)) * playerList.scrollingindex), list_scroll)
                    utility:UpdateTransparency(list_bar, 1)
                    utility:UpdateOffset(list_bar, {Vector2.new(1, 1 + ((((list_scroll.Size.Y - 2) - list_bar.Size.Y) / (#playerList.players - 10)) * playerList.scrollingindex)), list_scroll})
                else
                    playerList.scrollingindex = 0
                    list_bar.Transparency = 0
                    utility:UpdateTransparency(list_bar, 0)
                end
                --
                playerList:Refresh()
            end
            --
            local lastselection
            --
            playerList.OnSelectionChanged = Instance.new("BindableEvent")
            --
            function playerList:Refresh(Relation)
                for Index, Value in pairs(playerList.items) do
                    local Found = playerList.players[Index + playerList.scrollingindex]
                    --
                    if Found then
                        Value:Set(true, Found)
                    else
                        Value:Set(false)
                    end
                end
                --
                if Relation then
                    library.Relations[Relation[1].UserId] = Relation[3] ~= "None" and Relation[3] or nil
                end
                --
                playerList_title.Text = ("Player List - %s Players"):format(#playerList.items - 1)
                --
                local Selection = playerList:GetSelection()
                --
                playerList.buttons[1]:Update(Selection)
                --
                window:Move(window.main_frame.Position)
                --
                if Selection then
                    if lastselection ~= Selection then
                        playerList.OnSelectionChanged:Fire(Selection)
                        lastselection = Selection
                        --
                        --options_avatar.Data = ""
                        options_loadingtext.Text = "..?"
                        --
                        options_title.Text = ("User ID : %s\nDisplayName: %s\nName : %s\nHealth : %s/%s"):format(Selection[1].UserId, Selection[1].Name ~= "" and Selection[1].DisplayName or Selection[1].Name, Selection[1].Name, "100", "100")
                        local thumbType = Enum.ThumbnailType.HeadShot
                        local thumbSize = Enum.ThumbnailSize.Size150x150
                        local content, ready = Players:GetUserThumbnailAsync(Selection[1].UserId, thumbType, thumbSize)
                        --
                        if playerList:GetSelection() == Selection then
                            options_avatar.Data = (ready and content)
                            options_loadingtext.Text = ""
                        end
                    end
                else
                    options_title.Text = "No player selected."
                    --options_avatar.Data = ""
                    options_loadingtext.Text = "..?"
                    lastselection = nil
                end
            end
            --
            function playerList:Update() end
            --
            utility:Connection(Players.PlayerAdded, (function(Player)
                playerList.players[#playerList.players + 1] = {Player, (Player.DisplayName), "None", false}
                --
                playerList:UpdateScroll()
            end))
            --
            utility:Connection(Players.PlayerRemoving, (function(Player)
                for Index, Value in pairs(playerList.players) do
                    if Value[1] == Player then
                        Remove(playerList.players, Index)
                    end
                end
                --
                playerList:UpdateScroll()
            end))
            --
            for Index, Value in pairs(Players:GetPlayers()) do
                playerList.players[#playerList.players + 1] = {Value, (Value.DisplayName), Value == Client and "Local Player" or "None", false}
            end
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and list_outline.Visible and window.isVisible then
                    if utility:MouseOverDrawing({list_bar.Position.X, list_bar.Position.Y, list_bar.Position.X + list_bar.Size.X, list_bar.Position.Y + list_bar.Size.Y}) then
                        playerList.scrolling = {true, (utility:MouseLocation().Y - list_bar.Position.Y)}
                    elseif utility:MouseOverDrawing({list_frame.Position.X, list_frame.Position.Y, list_frame.Position.X + list_frame.Size.X, list_frame.Position.Y + list_frame.Size.Y}) and not window:IsOverContent() then
                        for Index = 1, 10 do
                            local Found = playerList.players[Index + playerList.scrollingindex]
                            --
                            if Found and utility:MouseOverDrawing({list_frame.Position.X, list_frame.Position.Y + 2 + (22 * (Index - 1)), list_frame.Position.X + list_frame.Size.X, list_frame.Position.Y + 2 + (22 * (Index - 1)) + 22}) then
                                if Found[4] then
                                    Found[4] = false
                                else
                                    for Index2, Value2 in pairs(playerList.players) do
                                        if Value2 ~= Found then
                                            Value2[4] = false
                                        end
                                    end
                                    --
                                    Found[4] = true
                                end
                                --
                                playerList:UpdateScroll()
                                --
                                break
                            end
                        end
                    end
                end
            end
            --
            library.ended[#library.ended + 1] = function(Input)
                if playerList.scrolling[1] and Input.UserInputType == Enum.UserInputType.MouseButton1 then
                    playerList.scrolling = {false, nil}
                end
            end
            --
            library.changed[#library.changed + 1] = function(Input)
                if playerList.scrolling[1] then
                    local MouseLocation = utility:MouseLocation()
                    local Position = Clamp((MouseLocation.Y - list_scroll.Position.Y - playerList.scrolling[2]), 0, ((list_scroll.Size.Y - list_bar.Size.Y)))
                    --
                    playerList.scrollingindex = Clamp(Round((((Position + list_scroll.Position.Y) - list_scroll.Position.Y) / ((list_scroll.Size.Y - list_bar.Size.Y))) * (#playerList.players - 10)), 0, #playerList.players - 10)
                    playerList:UpdateScroll()
                end
            end
            --
            utility:Connection(Mouse.WheelForward, (function()
                if (#playerList.players - 10) > 0 and page.open and list_bar.Visible and utility:MouseOverDrawing({list_frame.Position.X, list_frame.Position.Y, list_frame.Position.X + list_frame.Size.X, list_frame.Position.Y + list_frame.Size.Y}) and not window:IsOverContent() then
                    playerList.scrollingindex = Clamp(playerList.scrollingindex - 1, 0, #playerList.players - 10)
                    playerList:UpdateScroll()
                end
            end))
            --
            utility:Connection(Mouse.WheelBackward, (function()
                if (#playerList.players - 10) > 0 and page.open and list_bar.Visible and utility:MouseOverDrawing({list_frame.Position.X, list_frame.Position.Y, list_frame.Position.X + list_frame.Size.X, list_frame.Position.Y + list_frame.Size.Y}) and not window:IsOverContent() then
                    playerList.scrollingindex = Clamp(playerList.scrollingindex + 1, 0, #playerList.players - 10)
                    playerList:UpdateScroll()
                end
            end))
            --
            playerList:UpdateScroll()
            --
            page.sectionOffset["left"] = page.sectionOffset["left"] + playerList_inline.Size.Y + 5
            page.sectionOffset["right"] = page.sectionOffset["right"] + playerList_inline.Size.Y + 5
            page.sections[#page.sections + 1] = playerList
            return playerList
        end
        --
        function sections:Label(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "New Label"
            local middle = info.middle or info.Middle or info.center or info.Center or false
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local label = {axis = section.currentAxis}
            --
            local label_title = utility:Create("TextLabel", {Vector2.new(middle and (section.section_frame.Size.X/2) or 4,label.axis), section.section_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Center = middle,
                Position = utility:Position(middle and 0.5 or 0, middle and 0 or 4, 0, 0, section.section_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[label_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = label
            end
            --
            section.currentAxis = section.currentAxis + label_title.TextBounds.Y + 4
            --
            return label
        end
        --
        function sections:Toggle(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "New Toggle"
            local def = info.def or info.Def or info.default or info.Default or false
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local toggle = {axis = section.currentAxis, current = def, addedAxis = 0, addedKeybind = nil, colorpickers = 0, keybind = nil}
            --
            local toggle_outline = utility:Create("Frame", {Vector2.new(4,toggle.axis), section.section_frame}, {
                Size = utility:Size(0, 15, 0, 15),
                Position = utility:Position(0, 4, 0, toggle.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[toggle_outline] = {
                Color = "outline"
            }
            --
            local toggle_inline = utility:Create("Frame", {Vector2.new(1,1), toggle_outline}, {
                Size = utility:Size(1, -2, 1, -2, toggle_outline),
                Position = utility:Position(0, 1, 0, 1, toggle_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[toggle_inline] = {
                Color = "inline"
            }
            --
            local toggle_frame = utility:Create("Frame", {Vector2.new(1,1), toggle_inline}, {
                Size = utility:Size(1, -2, 1, -2, toggle_inline),
                Position = utility:Position(0, 1, 0, 1, toggle_inline),
                Color = toggle.current == true and theme.accent or theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[toggle_frame] = {
                Color = toggle.current == true and "accent" or "lightcontrast"
            }
            --
            local toggle__gradient = utility:Create("Image", {Vector2.new(0,0), toggle_frame}, {
                Size = utility:Size(1, 0, 1, 0, toggle_frame),
                Position = utility:Position(0, 0, 0 , 0, toggle_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            local toggle_title = utility:Create("TextLabel", {Vector2.new(23,toggle.axis + (15/2) - (utility:GetTextBounds(name, theme.textsize, theme.font).Y/2)), section.section_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 23, 0, toggle.axis + (15/2) - (utility:GetTextBounds(name, theme.textsize, theme.font).Y/2), section.section_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[toggle_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            utility:LoadImage(toggle__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function toggle:Get()
                return toggle.current
            end
            --
            function toggle:Set(bool)
                if typeof(bool) == "boolean" then
                    toggle.current = bool
                    if typeof(theme.accent) == "table" then
                        theme.accent = theme.accent.Color
                    end
                    toggle_frame.Color = toggle.current == true and theme.accent or theme.lightcontrast
                    library.colors[toggle_frame] = {
                        Color = toggle.current == true and "accent" or "lightcontrast"
                    }
                    --
                    callback(toggle.current)
                    if toggle.keybind then
                        toggle.keybind.active = (bool and (toggle.keybind.mode == "Always" or toggle.keybind.mode == "Off Hold") or false)
                        toggle.keybind:Callback()
                        --
                        if toggle.keybind.mode == "Off Hold" and toggle.current then
                            window.keybindslist:Add(toggle.keybind.keybindname, toggle.keybind.keybind_value.Text)
                        else
                            window.keybindslist:Remove(toggle.keybind.keybindname)
                        end
                    end
                end
            end
            --
            library.colors[toggle_frame] = {
                Color = toggle.current == true and "accent" or "lightcontrast"
            }
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and toggle_outline.Visible and window.isVisible and page.open and utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + toggle.axis, section.section_frame.Position.X + section.section_frame.Size.X - toggle.addedAxis, section.section_frame.Position.Y + toggle.axis + 15}) and not window:IsOverContent() then
                    toggle.current = not toggle.current
                    toggle_frame.Color = toggle.current == true and theme.accent or theme.lightcontrast
                    --
                    library.colors[toggle_frame] = {
                        Color = toggle.current == true and "accent" or "lightcontrast"
                    }
                    --
                    callback(toggle.current)
                    --
                    if toggle.keybind then
                        toggle.keybind.active = (toggle.current and (toggle.keybind.mode == "Always" or toggle.keybind.mode == "Off Hold") or false)
                        toggle.keybind:Callback()
                        if toggle.keybind.mode == "Off Hold" and toggle.current then
                            window.keybindslist:Add(toggle.keybind.keybindname, toggle.keybind.keybind_value.Text)
                        else
                            window.keybindslist:Remove(toggle.keybind.keybindname)
                        end
                    end
                end
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = toggle
            end
            --
            section.currentAxis = section.currentAxis + 15 + 4
            --
            function toggle:Colorpicker(info)
                local info = info or {}
                local cpinfo = info.info or info.Info or name
                local def = info.def or info.Def or info.default or info.Default or Color3.fromRGB(92, 72, 112)
                local transp = info.transparency or info.Transparency or info.transp or info.Transp or info.alpha or info.Alpha or 0.2
                local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
                local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
                --
                local hh, ss, vv = def:ToHSV()
                local colorpicker = {toggle, axis = toggle.axis, index = toggle.colorpickers, current = {hh, ss, vv , (transp or 0)}, holding = {picker = false, huepicker = false, transparency = false}, holder = {inline = nil, picker = nil, picker_cursor = nil, huepicker = nil, huepicker_cursor = {}, transparency = nil, transparencybg = nil, transparency_cursor = {}, drawings = {}}}
                --
                local colorpicker_outline = utility:Create("Frame", {Vector2.new(section.section_frame.Size.X-(toggle.colorpickers == 0 and (30+4) or (64 + 4)),colorpicker.axis), section.section_frame}, {
                    Size = utility:Size(0, 30, 0, 15),
                    Position = utility:Position(1, -(toggle.colorpickers == 0 and (30+4) or (64 + 4)), 0, colorpicker.axis, section.section_frame),
                    Color = theme.outline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[colorpicker_outline] = {
                    Color = "outline"
                }
                --
                local colorpicker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_outline}, {
                    Size = utility:Size(1, -2, 1, -2, colorpicker_outline),
                    Position = utility:Position(0, 1, 0, 1, colorpicker_outline),
                    Color = theme.inline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[colorpicker_inline] = {
                    Color = "inline"
                }
                --
                local colorpicker__transparency
                if transp then
                    colorpicker__transparency = utility:Create("Image", {Vector2.new(1,1), colorpicker_inline}, {
                        Size = utility:Size(1, -2, 1, -2, colorpicker_inline),
                        Position = utility:Position(0, 1, 0 , 1, colorpicker_inline),
                        Visible = page.open
                    }, section.visibleContent)
                end
                --
                local colorpicker_frame = utility:Create("Frame", {Vector2.new(1,1), colorpicker_inline}, {
                    Size = utility:Size(1, -2, 1, -2, colorpicker_inline),
                    Position = utility:Position(0, 1, 0, 1, colorpicker_inline),
                    Color = def,
                    Transparency = transp and (1 - transp) or 1,
                    Visible = page.open
                }, section.visibleContent)
                --
                local colorpicker__gradient = utility:Create("Image", {Vector2.new(0,0), colorpicker_frame}, {
                    Size = utility:Size(1, 0, 1, 0, colorpicker_frame),
                    Position = utility:Position(0, 0, 0 , 0, colorpicker_frame),
                    Transparency = 0.5,
                    Visible = page.open
                }, section.visibleContent)
                --
                if transp then
                    utility:LoadImage(colorpicker__transparency, "cptransp", "https://i.imgur.com/IIPee2A.png")
                end
                utility:LoadImage(colorpicker__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                --
                function colorpicker:Set(arg)
                    local color, transp_val 
                    if typeof(arg) == "Color3" then
                        color, transp_val = arg, 0
                    elseif arg.Color and arg.Transparency then
                        color, transp_val = arg.Color, arg.Transparency
                    else
                        color, transp_val = Color3.new(arg[1], arg[2], arg[3]), arg[4]
                    end
                    if typeof(color) == "table" then
                        if color.Color and color.Transparency then
                            local h, s, v = Unpack(color.Color)
                            colorpicker.current = {h, s, v , color.Transparency}
                            colorpicker_frame.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                            colorpicker_frame.Transparency = 1 - colorpicker.current[4]
                            callback(Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), colorpicker.current[4])
                        else
                            colorpicker.current = color
                            colorpicker_frame.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                            colorpicker_frame.Transparency = 1 - colorpicker.current[4]
                            callback(Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), colorpicker.current[4])
                        end
                    elseif typeof(color) == "Color3" then
                        local h, s, v = color:ToHSV()
                        colorpicker.current = {h, s, v, (transp_val or 0)}
                        colorpicker_frame.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                        colorpicker_frame.Transparency = 1 - colorpicker.current[4]
                        callback(Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), colorpicker.current[4]) 
                    end
                end
                --
                function colorpicker:Refresh()
                    local mouseLocation = utility:MouseLocation()
                    if colorpicker.open and colorpicker.holder.picker and colorpicker.holding.picker then
                        colorpicker.current[2] = Clamp(mouseLocation.X - colorpicker.holder.picker.Position.X, 0, colorpicker.holder.picker.Size.X) / colorpicker.holder.picker.Size.X
                        --
                        colorpicker.current[3] = 1-(Clamp(mouseLocation.Y - colorpicker.holder.picker.Position.Y, 0, colorpicker.holder.picker.Size.Y) / colorpicker.holder.picker.Size.Y)
                        --
                        colorpicker.holder.picker_cursor.Position = utility:Position(colorpicker.current[2], -3, 1-colorpicker.current[3] , -3, colorpicker.holder.picker)
                        --
                        utility:UpdateOffset(colorpicker.holder.picker_cursor, {Vector2.new((colorpicker.holder.picker.Size.X*colorpicker.current[2])-3,(colorpicker.holder.picker.Size.Y*(1-colorpicker.current[3]))-3), colorpicker.holder.picker})
                        --
                        if colorpicker.holder.transparencybg then
                            colorpicker.holder.transparencybg.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                        end
                    elseif colorpicker.open and colorpicker.holder.huepicker and colorpicker.holding.huepicker then
                        colorpicker.current[1] = (Clamp(mouseLocation.Y - colorpicker.holder.huepicker.Position.Y, 0, colorpicker.holder.huepicker.Size.Y) / colorpicker.holder.huepicker.Size.Y)
                        --
                        colorpicker.holder.huepicker_cursor[1].Position = utility:Position(0, -3, colorpicker.current[1], -3, colorpicker.holder.huepicker)
                        colorpicker.holder.huepicker_cursor[2].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.huepicker_cursor[1])
                        colorpicker.holder.huepicker_cursor[3].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.huepicker_cursor[2])
                        colorpicker.holder.huepicker_cursor[3].Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                        --
                        utility:UpdateOffset(colorpicker.holder.huepicker_cursor[1], {Vector2.new(-3,(colorpicker.holder.huepicker.Size.Y*colorpicker.current[1])-3), colorpicker.holder.huepicker})
                        --
                        colorpicker.holder.background.Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                        --
                        if colorpicker.holder.transparency_cursor and colorpicker.holder.transparency_cursor[3] then
                            colorpicker.holder.transparency_cursor[3].Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4])
                        end
                        --
                        if colorpicker.holder.transparencybg then
                            colorpicker.holder.transparencybg.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                        end
                    elseif colorpicker.open and colorpicker.holder.transparency and colorpicker.holding.transparency then
                        colorpicker.current[4] = 1 - (Clamp(mouseLocation.X - colorpicker.holder.transparency.Position.X, 0, colorpicker.holder.transparency.Size.X) / colorpicker.holder.transparency.Size.X)
                        --
                        colorpicker.holder.transparency_cursor[1].Position = utility:Position(1-colorpicker.current[4], -3, 0, -3, colorpicker.holder.transparency)
                        colorpicker.holder.transparency_cursor[2].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.transparency_cursor[1])
                        colorpicker.holder.transparency_cursor[3].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.transparency_cursor[2])
                        colorpicker.holder.transparency_cursor[3].Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4])
                        colorpicker_frame.Transparency = (1 - colorpicker.current[4])
                        --
                        utility:UpdateTransparency(colorpicker_frame, (1 - colorpicker.current[4]))
                        utility:UpdateOffset(colorpicker.holder.transparency_cursor[1], {Vector2.new((colorpicker.holder.transparency.Size.X*(1-colorpicker.current[4]))-3,-3), colorpicker.holder.transparency})
                        --
                        colorpicker.holder.background.Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                    end
                    --
                    colorpicker:Set(colorpicker.current)
                end
                --
                function colorpicker:Get()
                    return {Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), Transparency = colorpicker.current[4]}
                end
                --
                library.began[#library.began + 1] = function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and colorpicker_outline.Visible then
                        if colorpicker.open and colorpicker.holder.inline and utility:MouseOverDrawing({colorpicker.holder.inline.Position.X, colorpicker.holder.inline.Position.Y, colorpicker.holder.inline.Position.X + colorpicker.holder.inline.Size.X, colorpicker.holder.inline.Position.Y + colorpicker.holder.inline.Size.Y}) then
                            if colorpicker.holder.picker and utility:MouseOverDrawing({colorpicker.holder.picker.Position.X - 2, colorpicker.holder.picker.Position.Y - 2, colorpicker.holder.picker.Position.X - 2 + colorpicker.holder.picker.Size.X + 4, colorpicker.holder.picker.Position.Y - 2 + colorpicker.holder.picker.Size.Y + 4}) then
                                colorpicker.holding.picker = true
                                colorpicker:Refresh()
                            elseif colorpicker.holder.huepicker and utility:MouseOverDrawing({colorpicker.holder.huepicker.Position.X - 2, colorpicker.holder.huepicker.Position.Y - 2, colorpicker.holder.huepicker.Position.X - 2 + colorpicker.holder.huepicker.Size.X + 4, colorpicker.holder.huepicker.Position.Y - 2 + colorpicker.holder.huepicker.Size.Y + 4}) then
                                colorpicker.holding.huepicker = true
                                colorpicker:Refresh()
                            elseif colorpicker.holder.transparency and utility:MouseOverDrawing({colorpicker.holder.transparency.Position.X - 2, colorpicker.holder.transparency.Position.Y - 2, colorpicker.holder.transparency.Position.X - 2 + colorpicker.holder.transparency.Size.X + 4, colorpicker.holder.transparency.Position.Y - 2 + colorpicker.holder.transparency.Size.Y + 4}) then
                                colorpicker.holding.transparency = true
                                colorpicker:Refresh()
                            end
                        elseif utility:MouseOverDrawing({section.section_frame.Position.X + (section.section_frame.Size.X - (colorpicker.index == 0 and (30 + 4 + 2) or (64 + 4 + 2))), section.section_frame.Position.Y + colorpicker.axis, section.section_frame.Position.X + section.section_frame.Size.X - (colorpicker.index == 1 and 36 or 0), section.section_frame.Position.Y + colorpicker.axis + 15}) and not window:IsOverContent() then
                            if not colorpicker.open then
                                window:CloseContent()
                                colorpicker.open = not colorpicker.open
                                --
                                local colorpicker_open_outline = utility:Create("Frame", {Vector2.new(4,colorpicker.axis + 19), section.section_frame}, {
                                    Size = utility:Size(1, -8, 0, transp and 219 or 200, section.section_frame),
                                    Position = utility:Position(0, 4, 0, colorpicker.axis + 19, section.section_frame),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings);colorpicker.holder.inline = colorpicker_open_outline
                                --
                                library.colors[colorpicker_open_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_outline),
                                    Color = theme.inline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_inline] = {
                                    Color = "inline"
                                }
                                --
                                local colorpicker_open_frame = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_inline),
                                    Color = theme.darkcontrast
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_frame] = {
                                    Color = "darkcontrast"
                                }
                                --
                                local colorpicker_open_accent = utility:Create("Frame", {Vector2.new(0,0), colorpicker_open_frame}, {
                                    Size = utility:Size(1, 0, 0, 2, colorpicker_open_frame),
                                    Position = utility:Position(0, 0, 0, 0, colorpicker_open_frame),
                                    Color = theme.accent
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_accent] = {
                                    Color = "accent"
                                }
                                --
                                local colorpicker_title = utility:Create("TextLabel", {Vector2.new(4,2), colorpicker_open_frame}, {
                                    Text = cpinfo,
                                    Size = theme.textsize,
                                    Font = theme.font,
                                    Color = theme.textcolor,
                                    OutlineColor = theme.textborder,
                                    Position = utility:Position(0, 4, 0, 2, colorpicker_open_frame),
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_title] = {
                                    OutlineColor = "textborder",
                                    Color = "textcolor"
                                }
                                --
                                local colorpicker_open_picker_outline = utility:Create("Frame", {Vector2.new(4,17), colorpicker_open_frame}, {
                                    Size = utility:Size(1, -27, 1, transp and -40 or -21, colorpicker_open_frame),
                                    Position = utility:Position(0, 4, 0, 17, colorpicker_open_frame),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_picker_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_picker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_picker_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_picker_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_picker_outline),
                                    Color = theme.inline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_picker_inline] = {
                                    Color = "inline"
                                }
                                --
                                local colorpicker_open_picker_bg = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_picker_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_picker_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_picker_inline),
                                    Color = Color3.fromHSV(colorpicker.current[1],1,1)
                                }, colorpicker.holder.drawings);colorpicker.holder.background = colorpicker_open_picker_bg
                                --
                                local colorpicker_open_picker_image = utility:Create("Image", {Vector2.new(0,0), colorpicker_open_picker_bg}, {
                                    Size = utility:Size(1, 0, 1, 0, colorpicker_open_picker_bg),
                                    Position = utility:Position(0, 0, 0 , 0, colorpicker_open_picker_bg),
                                }, colorpicker.holder.drawings);colorpicker.holder.picker = colorpicker_open_picker_image
                                --
                                local colorpicker_open_picker_cursor = utility:Create("Image", {Vector2.new((colorpicker_open_picker_image.Size.X*colorpicker.current[2])-3,(colorpicker_open_picker_image.Size.Y*(1-colorpicker.current[3]))-3), colorpicker_open_picker_image}, {
                                    Size = utility:Size(0, 6, 0, 6, colorpicker_open_picker_image),
                                    Position = utility:Position(colorpicker.current[2], -3, 1-colorpicker.current[3] , -3, colorpicker_open_picker_image),
                                }, colorpicker.holder.drawings);colorpicker.holder.picker_cursor = colorpicker_open_picker_cursor
                                --
                                local colorpicker_open_huepicker_outline = utility:Create("Frame", {Vector2.new(colorpicker_open_frame.Size.X-19,17), colorpicker_open_frame}, {
                                    Size = utility:Size(0, 15, 1, transp and -40 or -21, colorpicker_open_frame),
                                    Position = utility:Position(1, -19, 0, 17, colorpicker_open_frame),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_huepicker_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_huepicker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_outline),
                                    Color = theme.inline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_huepicker_inline] = {
                                    Color = "inline"
                                }
                                --
                                local colorpicker_open_huepicker_image = utility:Create("Image", {Vector2.new(1,1), colorpicker_open_huepicker_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_inline),
                                    Position = utility:Position(0, 1, 0 , 1, colorpicker_open_huepicker_inline),
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker = colorpicker_open_huepicker_image
                                --
                                local colorpicker_open_huepicker_cursor_outline = utility:Create("Frame", {Vector2.new(-3,(colorpicker_open_huepicker_image.Size.Y*colorpicker.current[1])-3), colorpicker_open_huepicker_image}, {
                                    Size = utility:Size(1, 6, 0, 6, colorpicker_open_huepicker_image),
                                    Position = utility:Position(0, -3, colorpicker.current[1], -3, colorpicker_open_huepicker_image),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[1] = colorpicker_open_huepicker_cursor_outline
                                --
                                library.colors[colorpicker_open_huepicker_cursor_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_huepicker_cursor_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_cursor_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_cursor_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_cursor_outline),
                                    Color = theme.textcolor
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[2] = colorpicker_open_huepicker_cursor_inline
                                --
                                library.colors[colorpicker_open_huepicker_cursor_inline] = {
                                    Color = "textcolor"
                                }
                                --
                                local colorpicker_open_huepicker_cursor_color = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_cursor_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_cursor_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_cursor_inline),
                                    Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[3] = colorpicker_open_huepicker_cursor_color
                                --
                                if transp then
                                    local colorpicker_open_transparency_outline = utility:Create("Frame", {Vector2.new(4,colorpicker_open_frame.Size.Y-19), colorpicker_open_frame}, {
                                        Size = utility:Size(1, -27, 0, 15, colorpicker_open_frame),
                                        Position = utility:Position(0, 4, 1, -19, colorpicker_open_frame),
                                        Color = theme.outline
                                    }, colorpicker.holder.drawings)
                                    --
                                    library.colors[colorpicker_open_transparency_outline] = {
                                        Color = "outline"
                                    }
                                    --
                                    local colorpicker_open_transparency_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_outline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_outline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_outline),
                                        Color = theme.inline
                                    }, colorpicker.holder.drawings)
                                    --
                                    library.colors[colorpicker_open_transparency_inline] = {
                                        Color = "inline"
                                    }
                                    --
                                    local colorpicker_open_transparency_bg = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_inline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_inline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_inline),
                                        Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparencybg = colorpicker_open_transparency_bg
                                    --
                                    local colorpicker_open_transparency_image = utility:Create("Image", {Vector2.new(1,1), colorpicker_open_transparency_inline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_inline),
                                        Position = utility:Position(0, 1, 0 , 1, colorpicker_open_transparency_inline),
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency = colorpicker_open_transparency_image
                                    --
                                    local colorpicker_open_transparency_cursor_outline = utility:Create("Frame", {Vector2.new((colorpicker_open_transparency_image.Size.X*(1-colorpicker.current[4]))-3,-3), colorpicker_open_transparency_image}, {
                                        Size = utility:Size(0, 6, 1, 6, colorpicker_open_transparency_image),
                                        Position = utility:Position(1-colorpicker.current[4], -3, 0, -3, colorpicker_open_transparency_image),
                                        Color = theme.outline
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[1] = colorpicker_open_transparency_cursor_outline
                                    --
                                    library.colors[colorpicker_open_transparency_cursor_outline] = {
                                        Color = "outline"
                                    }
                                    --
                                    local colorpicker_open_transparency_cursor_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_cursor_outline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_cursor_outline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_cursor_outline),
                                        Color = theme.textcolor
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[2] = colorpicker_open_transparency_cursor_inline
                                    --
                                    library.colors[colorpicker_open_transparency_cursor_inline] = {
                                        Color = "textcolor"
                                    }
                                    --
                                    local colorpicker_open_transparency_cursor_color = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_cursor_inline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_cursor_inline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_cursor_inline),
                                        Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4]),
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[3] = colorpicker_open_transparency_cursor_color
                                    --
                                    utility:LoadImage(colorpicker_open_transparency_image, "transp", "https://i.imgur.com/ncssKbH.png")
                                    --utility:LoadImage(colorpicker_open_transparency_image, "transp", "https://i.imgur.com/VcMAYjL.png")
                                end
                                --
                                utility:LoadImage(colorpicker_open_picker_image, "valsat", "https://i.imgur.com/wpDRqVH.png")
                                utility:LoadImage(colorpicker_open_picker_cursor, "valsat_cursor", "https://raw.githubusercontent.com/mvonwalk/splix-assets/main/Images-cursor.png")
                                utility:LoadImage(colorpicker_open_huepicker_image, "hue", "https://i.imgur.com/iEOsHFv.png")
                                --
                                window.currentContent.frame = colorpicker_open_inline
                                window.currentContent.colorpicker = colorpicker
                            else
                                colorpicker.open = not colorpicker.open
                                --
                                for i,v in pairs(colorpicker.holder.drawings) do
                                    utility:Remove(v)
                                end
                                --
                                colorpicker.holder.drawings = {}
                                colorpicker.holder.inline = nil
                                --
                                window.currentContent.frame = nil
                                window.currentContent.colorpicker = nil
                            end
                        else
                            if colorpicker.open then
                                colorpicker.open = not colorpicker.open
                                --
                                for i,v in pairs(colorpicker.holder.drawings) do
                                    utility:Remove(v)
                                end
                                --
                                colorpicker.holder.drawings = {}
                                colorpicker.holder.inline = nil
                                --
                                window.currentContent.frame = nil
                                window.currentContent.colorpicker = nil
                            end
                        end
                    elseif Input.UserInputType == Enum.UserInputType.MouseButton1 and colorpicker.open then
                        colorpicker.open = not colorpicker.open
                        --
                        for i,v in pairs(colorpicker.holder.drawings) do
                            utility:Remove(v)
                        end
                        --
                        colorpicker.holder.drawings = {}
                        colorpicker.holder.inline = nil
                        --
                        window.currentContent.frame = nil
                        window.currentContent.colorpicker = nil
                    end
                end
                --
                library.ended[#library.ended + 1] = function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                        if colorpicker.holding.picker then
                            colorpicker.holding.picker = not colorpicker.holding.picker
                        end
                        if colorpicker.holding.huepicker then
                            colorpicker.holding.huepicker = not colorpicker.holding.huepicker
                        end
                        if colorpicker.holding.transparency then
                            colorpicker.holding.transparency = not colorpicker.holding.transparency
                        end
                    end
                end
                --
                library.changed[#library.changed + 1] = function()
                    if colorpicker.open and colorpicker.holding.picker or colorpicker.holding.huepicker or colorpicker.holding.transparency then
                        if window.isVisible then
                            colorpicker:Refresh()
                        else
                            if colorpicker.holding.picker then
                                colorpicker.holding.picker = not colorpicker.holding.picker
                            end
                            if colorpicker.holding.huepicker then
                                colorpicker.holding.huepicker = not colorpicker.holding.huepicker
                            end
                            if colorpicker.holding.transparency then
                                colorpicker.holding.transparency = not colorpicker.holding.transparency
                            end
                        end
                    end
                end
                --
                if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                    library.pointers[tostring(pointer)] = colorpicker
                end
                --
                toggle.addedAxis = toggle.addedAxis + 30 + 4 + 2
                toggle.colorpickers = toggle.colorpickers + 1
                --
                return colorpicker, toggle
            end
            --
            function toggle:Keybind(info)
                local info = info or {}
                local def = info.def or info.Def or info.default or info.Default or nil
                local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
                local mode = info.mode or info.Mode or "Always"
                local keybindname = info.keybindname or info.keybindName or info.KeybindName or info.Keybindname or nil
                local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
                --
                toggle.addedaxis = toggle.addedAxis + 40 + 4 + 2
                --
                local keybind = {keybindname = keybindname or name, axis = toggle.axis, current = {}, selecting = false, mode = mode, open = false, modemenu = {buttons = {}, drawings = {}}, active = false}
                --
                toggle.keybind = keybind
                --
                local allowedKeyCodes = {"Q","W","E","R","T","Y","U","I","O","P","A","S","D","F","G","H","J","K","L","Z","X","C","V","B","N","M","One","Two","Three","Four","Five","Six","Seveen","Eight","Nine","Zero", "Minus", "Equals","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","Insert","Tab","Home","End","LeftAlt","LeftControl","LeftShift","RightAlt","RightControl","RightShift","CapsLock"}
                local allowedInputTypes = {"MouseButton1","MouseButton2","MouseButton3"}
                local shortenedInputs = {["MouseButton1"] = "MB1", ["MouseButton2"] = "MB2", ["MouseButton3"] = "MB3", ["Insert"] = "Ins", ["Minus"] = "-", ["Equals"] = "=", ["LeftAlt"] = "LAlt", ["LeftControl"] = "LC", ["LeftShift"] = "LS", ["RightAlt"] = "RAlt", ["RightControl"] = "RC", ["RightShift"] = "RS", ["CapsLock"] = "Caps"}
                --
                local keybind_outline = utility:Create("Frame", {Vector2.new(section.section_frame.Size.X-(40+4),keybind.axis), section.section_frame}, {
                    Size = utility:Size(0, 40, 0, 17),
                    Position = utility:Position(1, -(40+4), 0, keybind.axis, section.section_frame),
                    Color = theme.outline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[keybind_outline] = {
                    Color = "outline"
                }
                --
                local keybind_inline = utility:Create("Frame", {Vector2.new(1,1), keybind_outline}, {
                    Size = utility:Size(1, -2, 1, -2, keybind_outline),
                    Position = utility:Position(0, 1, 0, 1, keybind_outline),
                    Color = theme.inline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[keybind_inline] = {
                    Color = "inline"
                }
                --
                local keybind_frame = utility:Create("Frame", {Vector2.new(1,1), keybind_inline}, {
                    Size = utility:Size(1, -2, 1, -2, keybind_inline),
                    Position = utility:Position(0, 1, 0, 1, keybind_inline),
                    Color = theme.lightcontrast,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[keybind_frame] = {
                    Color = "lightcontrast"
                }
                --
                local keybind__gradient = utility:Create("Image", {Vector2.new(0,0), keybind_frame}, {
                    Size = utility:Size(1, 0, 1, 0, keybind_frame),
                    Position = utility:Position(0, 0, 0 , 0, keybind_frame),
                    Transparency = 0.5,
                    Visible = page.open
                }, section.visibleContent)
                --
                local keybind_value = utility:Create("TextLabel", {Vector2.new(keybind_outline.Size.X/2,1), keybind_outline}, {
                    Text = "...",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder, 
                    Center = true,
                    Position = utility:Position(0.5, 0, 1, 0, keybind_outline),
                    Visible = page.open
                }, section.visibleContent);keybind["keybind_value"] = keybind_value
                --
                library.colors[keybind_value] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                utility:LoadImage(keybind__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                --
                function keybind:Shorten(string)
                    for i,v in pairs(shortenedInputs) do
                        string = Gsub(string, i, v)
                    end
                    return string
                end
                --
                function keybind:Change(input)
                    input = input or "..."
                    local inputTable = {}
                    --
                    if input.EnumType then
                        if input.EnumType == Enum.KeyCode or input.EnumType == Enum.UserInputType then
                            if Find(allowedKeyCodes, input.Name) or Find(allowedInputTypes, input.Name) then
                                inputTable = {input.EnumType == Enum.KeyCode and "KeyCode" or "UserInputType", input.Name}
                                --
                                keybind.current = inputTable
                                keybind_value.Text = #keybind.current > 0 and keybind:Shorten(keybind.current[2]) or "..."
                                --
                                return true
                            end
                        end
                    end
                    --
                    return false
                end
                --
                function keybind:Get()
                    return keybind.current
                end
                --
                function keybind:Set(tbl)
                    keybind.current = {tbl[1], tbl[2]}
                    keybind_value.Text = #keybind.current > 0 and keybind:Shorten(keybind.current[2]) or "..."
                    --
                    if tbl[3] then
                        keybind.mode = tbl[3]
                        keybind.active = (keybind.mode == "Always" or keybind.mode == "Off Hold") and (toggle.current) or false
                        --
                        if keybind.mode == "Off Hold" then
                            window.keybindslist:Add(keybindname or name, keybind_value.Text)
                        else
                            window.keybindslist:Remove(keybindname or name)
                        end
                    end
                    --
                    if keybind.current[1] and keybind.current[2] then
                        if not GetFocusedTextBox() then
                            --callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                        end
                    end
                end
                --
                function keybind:Active()
                    return keybind.active
                end
                --
                function keybind:Reset()
                    for i,v in pairs(keybind.modemenu.buttons) do
                        v.Color = v.Text == keybind.mode and theme.accent or theme.textcolor
                        --
                        library.colors[v] = {
                            Color = v.Text == keybind.mode and "accent" or "textcolor"
                        }
                    end
                    --
                    keybind.active = (keybind.mode == "Always" or keybind.mode == "Off Hold")
                    --
                    if keybind.mode == "Off Hold" then
                        window.keybindslist:Add(keybindname or name, keybind_value.Text)
                    else
                        window.keybindslist:Remove(keybindname or name)
                    end
                    --
                    if keybind.current[1] and keybind.current[2] then
                        if not GetFocusedTextBox() then
                            callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                        end
                    end
                end
                --
                function keybind:Callback()
                    if keybind.current[1] and keybind.current[2] then
                        if not GetFocusedTextBox() then
                            callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                        end
                    end
                end
                --
                keybind:Change(def)
                --
                library.began[#library.began + 1] = function(Input)
                    if keybind.current[1] and keybind.current[2] and not GetFocusedTextBox() then
                        if Input.KeyCode == Enum[keybind.current[1]][keybind.current[2]] or Input.UserInputType == Enum[keybind.current[1]][keybind.current[2]] then
                            if keybind.mode == "On Hold" then
                                local old = keybind.active
                                keybind.active = toggle:Get()
                                if keybind.active then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                                    if keybind.active ~= old then  if not GetFocusedTextBox() then
                                        callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                                    end
                                end
                            elseif keybind.mode == "Off Hold" then
                                local old = keybind.active
                                keybind.active = false
                                if keybind.active then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                                    if keybind.active ~= old then  if not GetFocusedTextBox() then
                                    callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                                end
                            end
                            elseif keybind.mode == "Toggle" then
                                local old = keybind.active
                                keybind.active = not keybind.active == true and toggle:Get() or false
                                if keybind.active then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                                    if keybind.active ~= old then 
                                        if not GetFocusedTextBox() then
                                        callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                                    end                
                                end
                            end
                        end
                    end
                    --
                    if keybind.selecting and window.isVisible then
                        local done = keybind:Change(Input.KeyCode.Name ~= "Unknown" and Input.KeyCode or Input.UserInputType)
                        if done and not GetFocusedTextBox() then
                            keybind.selecting = false
                            keybind.active = (keybind.mode == "Always" or keybind.mode == "Off Hold") and true or false
                            keybind_frame.Color = theme.lightcontrast
                            --
                            library.colors[keybind_frame] = {
                                Color = "lightcontrast"
                            }
                            --
                            window.keybindslist:Remove(keybindname or name)
                            if keybind.active then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                            if not GetFocusedTextBox() then
                                callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                            end
                        end
                    end
                    --
                    if not window.isVisible and keybind.selecting then
                        keybind.selecting = false
                        keybind_frame.Color = theme.lightcontrast
                        --
                        library.colors[keybind_frame] = {
                            Color = "lightcontrast"
                        }
                    end
                    --
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and keybind_outline.Visible then
                        if utility:MouseOverDrawing({section.section_frame.Position.X + (section.section_frame.Size.X - (40+4+2)), section.section_frame.Position.Y + keybind.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + keybind.axis + 17}) and not window:IsOverContent() and not keybind.selecting then
                            keybind.selecting = true
                            keybind_frame.Color = theme.darkcontrast
                            --
                            library.colors[keybind_frame] = {
                                Color = "darkcontrast"
                            }
                        end
                        if keybind.open and keybind.modemenu.frame then
                            if utility:MouseOverDrawing({keybind.modemenu.frame.Position.X, keybind.modemenu.frame.Position.Y, keybind.modemenu.frame.Position.X + keybind.modemenu.frame.Size.X, keybind.modemenu.frame.Position.Y + keybind.modemenu.frame.Size.Y}) then
                                local changed = false
                                --
                                for i,v in pairs(keybind.modemenu.buttons) do
                                    if utility:MouseOverDrawing({keybind.modemenu.frame.Position.X, keybind.modemenu.frame.Position.Y + (15 * (i - 1)), keybind.modemenu.frame.Position.X + keybind.modemenu.frame.Size.X, keybind.modemenu.frame.Position.Y + (15 * (i - 1)) + 15}) then
                                        keybind.mode = v.Text
                                        changed = true
                                    end
                                end
                                --
                                if changed then keybind:Reset() end
                            else
                                keybind.open = not keybind.open
                                --
                                for i,v in pairs(keybind.modemenu.drawings) do
                                    utility:Remove(v)
                                end
                                --
                                keybind.modemenu.drawings = {}
                                keybind.modemenu.buttons = {}
                                keybind.modemenu.frame = nil
                                --
                                window.currentContent.frame = nil
                                window.currentContent.keybind = nil
                            end
                        end
                    end
                    --
                    if Input.UserInputType == Enum.UserInputType.MouseButton2 and window.isVisible and keybind_outline.Visible then
                        if utility:MouseOverDrawing({section.section_frame.Position.X  + (section.section_frame.Size.X - (40+4+2)), section.section_frame.Position.Y + keybind.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + keybind.axis + 17}) and not window:IsOverContent() and not keybind.selecting then
                            window:CloseContent()
                            keybind.open = not keybind.open
                            --
                            local modemenu = utility:Create("Frame", {Vector2.new(keybind_outline.Size.X + 2,0), keybind_outline}, {
                                Size = utility:Size(0, 68, 0, 64),
                                Position = utility:Position(1, 2, 0, 0, keybind_outline),
                                Color = theme.outline,
                                Visible = page.open
                            }, keybind.modemenu.drawings);keybind.modemenu.frame = modemenu
                            --
                            library.colors[modemenu] = {
                                Color = "outline"
                            }
                            --
                            local modemenu_inline = utility:Create("Frame", {Vector2.new(1,1), modemenu}, {
                                Size = utility:Size(1, -2, 1, -2, modemenu),
                                Position = utility:Position(0, 1, 0, 1, modemenu),
                                Color = theme.inline,
                                Visible = page.open
                            }, keybind.modemenu.drawings)
                            --
                            library.colors[modemenu_inline] = {
                                Color = "inline"
                            }
                            --
                            local modemenu_frame = utility:Create("Frame", {Vector2.new(1,1), modemenu_inline}, {
                                Size = utility:Size(1, -2, 1, -2, modemenu_inline),
                                Position = utility:Position(0, 1, 0, 1, modemenu_inline),
                                Color = theme.lightcontrast,
                                Visible = page.open
                            }, keybind.modemenu.drawings)
                            --
                            library.colors[modemenu_frame] = {
                                Color = "lightcontrast"
                            }
                            --
                            local keybind__gradient = utility:Create("Image", {Vector2.new(0,0), modemenu_frame}, {
                                Size = utility:Size(1, 0, 1, 0, modemenu_frame),
                                Position = utility:Position(0, 0, 0 , 0, modemenu_frame),
                                Transparency = 0.5,
                                Visible = page.open
                            }, keybind.modemenu.drawings)
                            --
                            utility:LoadImage(keybind__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                            --
                            for i,v in pairs({"Always", "Toggle", "On Hold", "Off Hold"}) do
                                local button_title = utility:Create("TextLabel", {Vector2.new(modemenu_frame.Size.X/2,15 * (i-1)), modemenu_frame}, {
                                    Text = v,
                                    Size = theme.textsize,
                                    Font = theme.font,
                                    Color = v == keybind.mode and theme.accent or theme.textcolor,
                                    Center = true,
                                    OutlineColor = theme.textborder,
                                    Position = utility:Position(0.5, 0, 0, 15 * (i-1), modemenu_frame),
                                    Visible = page.open
                                }, keybind.modemenu.drawings);keybind.modemenu.buttons[#keybind.modemenu.buttons + 1] = button_title
                                --
                                library.colors[button_title] = {
                                    OutlineColor = "textborder",
                                    Color = v == keybind.mode and "accent" or "textcolor"
                                }
                            end
                            --
                            window.currentContent.frame = modemenu
                            window.currentContent.keybind = keybind
                        end
                    end
                end
                --
                library.ended[#library.ended + 1] = function(Input)
                    if keybind.mode == "On Hold" or keybind.mode == "Off Hold" then
                        if keybind.current[1] and keybind.current[2] then
                            if Input.KeyCode == Enum[keybind.current[1]][keybind.current[2]] or Input.UserInputType == Enum[keybind.current[1]][keybind.current[2]] then
                                if keybind.mode == "On Hold" and keybind.active then
                                    keybind.active = false
                                    window.keybindslist:Remove(keybindname or name)
                                    if not GetFocusedTextBox() then
                                        callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                                    end
                                elseif keybind.mode == "Off Hold" and not keybind.active then
                                    keybind.active = toggle:Get()
                                    if keybind.active then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                                    if not GetFocusedTextBox() then
                                        callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                                    end
                                end
                            end
                        end
                    end
                end
                --
                if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                    library.pointers[tostring(pointer)] = keybind
                end
                --
                toggle.addedAxis = 40+4+2
                --
                return keybind
            end
            --
            return toggle
        end
        --
        function sections:Slider(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "Title"
            local def = info.def or info.Def or info.default or info.Default or 10
            local min = info.min or info.Min or info.minimum or info.Minimum or 0
            local max = info.max or info.Max or info.maximum or info.Maximum or 100
            local maxtext = info.maximumtext or info.Maximumtext or info.maximumText or info.MaximumText or max
            local sub = info.suffix or info.Suffix or info.ending or info.Ending or info.prefix or info.Prefix or info.measurement or info.Measurement or ""
            local disable = info.disable or info.Disable or info.disabled or info.disabled or false
            local decimals = info.decimals or info.Decimals or 1
            decimals = 1 / decimals
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            def = Clamp(def, min, max)
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local slider = {min = min, max = max, Disabled = false, sub = sub, decimals = decimals, axis = section.currentAxis, current = -99999, holding = false}
            --
            local slider_title = utility:Create("TextLabel", {Vector2.new(4,slider.axis), section.section_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 4, 0, slider.axis, section.section_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[slider_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            local slider_outline = utility:Create("Frame", {Vector2.new(4,slider.axis + (name and 15 or 0)), section.section_frame}, {
                Size = utility:Size(1, -8, 0, 14, section.section_frame),
                Position = utility:Position(0, 4, 0, slider.axis + (name and 15 or 0), section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[slider_outline] = {
                Color = "outline"
            }
            --
            local slider_inline = utility:Create("Frame", {Vector2.new(1,1), slider_outline}, {
                Size = utility:Size(1, -2, 1, -2, slider_outline),
                Position = utility:Position(0, 1, 0, 1, slider_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[slider_inline] = {
                Color = "inline"
            }
            --
            local slider_frame = utility:Create("Frame", {Vector2.new(1,1), slider_inline}, {
                Size = utility:Size(1, -2, 1, -2, slider_inline),
                Position = utility:Position(0, 1, 0, 1, slider_inline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[slider_frame] = {
                Color = "lightcontrast"
            }
            --
            local slider_slide = utility:Create("Frame", {Vector2.new(1,1), slider_inline}, {
                Size = utility:Size(0, (slider_frame.Size.X / (slider.max - slider.min) * (slider.current - slider.min)), 1, -2, slider_inline),
                Position = utility:Position(0, 1, 0, 1, slider_inline),
                Color = theme.accent,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[slider_slide] = {
                Color = "accent"
            }
            --
            local slider__gradient = utility:Create("Image", {Vector2.new(0,0), slider_frame}, {
                Size = utility:Size(1, 0, 1, 0, slider_frame),
                Position = utility:Position(0, 0, 0 , 0, slider_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            local textBounds = utility:GetTextBounds(name, theme.textsize, theme.font)
            local slider_value = utility:Create("TextLabel", {Vector2.new(slider_outline.Size.X/2,(slider_outline.Size.Y/2) - (textBounds.Y/2)), slider_outline}, {
                Text = slider.current..slider.sub.."/"..maxtext..slider.sub,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                Center = true,
                OutlineColor = theme.textborder,
                Position = utility:Position(0.5, 0, 0, (slider_outline.Size.Y/2) - (textBounds.Y/2), slider_outline),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[slider_value] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            utility:LoadImage(slider__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function slider:Set(value)
                local oldval = slider.current
                --
                slider.current = Clamp(Round(value * slider.decimals) / slider.decimals, slider.min, slider.max)
                --
                if slider.current ~= oldval then
                    local disabledtext = disable and ((slider.current <= disable[2] or slider.current >= disable[3]) and disable[1])
                    local percent = 1 - ((slider.max - slider.current) / (slider.max - slider.min))
                    slider_value.Text = disabledtext or (slider.current..slider.sub.."/"..maxtext..slider.sub)
                    slider_slide.Size = utility:Size(0, percent * slider_frame.Size.X, 1, -2, slider_inline)
                    slider.Disabled = disabledtext ~= nil and disabledtext ~= false
                    callback(slider.current)
                end
            end
            --
            function slider:SetName(Value)
                slider_title.Text = Value
            end
            --
            function slider:Refresh()
                local mouseLocation = utility:MouseLocation()
                local percent = Clamp(mouseLocation.X - slider_slide.Position.X, 0, slider_frame.Size.X) / slider_frame.Size.X
                local value = Round((slider.min + (slider.max - slider.min) * percent) * slider.decimals) / slider.decimals
                value = Clamp(value, slider.min, slider.max)
                slider:Set(value)
            end
            --
            function slider:Get()
                return slider.current
            end
            --
            slider:Set(def)
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and slider_outline.Visible and window.isVisible and page.open and utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + slider.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + slider.axis + (name and 29 or 14)}) and not window:IsOverContent() then
                    slider.holding = true
                    slider:Refresh()
                end
            end
            --
            library.ended[#library.ended + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and slider.holding and window.isVisible then
                    slider.holding = false
                end
            end
            --
            library.changed[#library.changed + 1] = function(Input)
                if slider.holding and window.isVisible then
                    slider:Refresh()
                end
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = slider
            end
            --
            section.currentAxis = section.currentAxis + (name and 29 or 14) + 4
            --
            return slider
        end
        --
        function sections:Button(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "New Button"
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local button = {axis = section.currentAxis}
            --
            local button_outline = utility:Create("Frame", {Vector2.new(4,button.axis), section.section_frame}, {
                Size = utility:Size(1, -8, 0, 20, section.section_frame),
                Position = utility:Position(0, 4, 0, button.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[button_outline] = {
                Color = "outline"
            }
            --
            local button_inline = utility:Create("Frame", {Vector2.new(1,1), button_outline}, {
                Size = utility:Size(1, -2, 1, -2, button_outline),
                Position = utility:Position(0, 1, 0, 1, button_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[button_inline] = {
                Color = "inline"
            }
            --
            local button_frame = utility:Create("Frame", {Vector2.new(1,1), button_inline}, {
                Size = utility:Size(1, -2, 1, -2, button_inline),
                Position = utility:Position(0, 1, 0, 1, button_inline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[button_frame] = {
                Color = "lightcontrast"
            }
            --
            local button_gradient = utility:Create("Image", {Vector2.new(0,0), button_frame}, {
                Size = utility:Size(1, 0, 1, 0, button_frame),
                Position = utility:Position(0, 0, 0 , 0, button_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            local button_title = utility:Create("TextLabel", {Vector2.new(button_frame.Size.X/2,1), button_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Center = true,
                Position = utility:Position(0.5, 0, 0, 1, button_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[button_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            utility:LoadImage(button_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and button_outline.Visible and window.isVisible and utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + button.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + button.axis + 20}) and not window:IsOverContent() then
                    Spawn(function()
                        utility:LoadImage(button_gradient, "gradientdown", "https://i.imgur.com/DzrzUt3.png") 
                        --
                        Wait(0.15)
                        --
                        utility:LoadImage(button_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png") 
                    end)
                    --
                    callback()
                end
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = button
            end
            --
            section.currentAxis = section.currentAxis + 20 + 4
            --
            return button
        end
        --
        function sections:TextBox(info)
            local info = info or {}
            local def = info.def or info.Def or info.default or info.Default or ""
            local max = info.max or info.Max or info.maximum or info.Maximum or 200
            local placeholder = info.placeholder or info.Placeholder or info.placeHolder or info.PlaceHolder
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local reactive = info.reactive or info.Reactive;reactive = reactive == nil or reactive
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            local identifier = tostring(Random(500, 500000)) .. "-" .. tostring(Random(500, 500000)) .. "-" .. tostring(Random(500, 500000))
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local textbox = {axis = section.currentAxis, max = max, current = def, oldenter = "", callback = callback}
            --
            local textbox_outline = utility:Create("Frame", {Vector2.new(4,textbox.axis), section.section_frame}, {
                Size = utility:Size(1, -8, 0, 20, section.section_frame),
                Position = utility:Position(0, 4, 0, textbox.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[textbox_outline] = {
                Color = "outline"
            }
            --
            local textbox_inline = utility:Create("Frame", {Vector2.new(1,1), textbox_outline}, {
                Size = utility:Size(1, -2, 1, -2, textbox_outline),
                Position = utility:Position(0, 1, 0, 1, textbox_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[textbox_inline] = {
                Color = "inline"
            }
            --
            local textbox_inneroutline = utility:Create("Frame", {Vector2.new(1,1), textbox_inline}, {
                Size = utility:Size(1, -2, 1, -2, textbox_inline),
                Position = utility:Position(0, 1, 0, 1, textbox_inline),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[textbox_inneroutline] = {
                Color = "outline"
            }
            --
            local textbox_frame = utility:Create("Frame", {Vector2.new(1,1), textbox_inneroutline}, {
                Size = utility:Size(1, -2, 1, -2, textbox_inneroutline),
                Position = utility:Position(0, 1, 0, 1, textbox_inneroutline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[textbox_frame] = {
                Color = "lightcontrast"
            }
            --
            local textbox_gradient = utility:Create("Image", {Vector2.new(0,0), textbox_frame}, {
                Size = utility:Size(1, 0, 1, 0, textbox_frame),
                Position = utility:Position(0, 0, 0 , 0, textbox_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            local textbox_value = utility:Create("TextLabel", {Vector2.new(textbox_frame.Size.X/2,0), textbox_frame}, {
                Text = textbox.current == "" and placeholder or textbox.current,
                Size = theme.textsize,
                Font = theme.font,
                Color = textbox.current == "" and (placeholder and theme.textdark) or theme.textcolor,
                OutlineColor = theme.textborder,
                Center = true,
                Position = utility:Position(0.5, 0, 0, 0, textbox_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[textbox_value] = {
                OutlineColor = "textborder",
                Color = textbox.current == "" and (placeholder and "textdark") or "textcolor"
            }
            --
            utility:LoadImage(textbox_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function textbox:Get()
                return textbox.current
            end
            --
            function textbox:Set(state, first)
                textbox.current = state or ""
                --
                local newtext = utility:WrapText(textbox.current == "" and placeholder or textbox.current, textbox_frame.Size.X - 30)
                textbox_value.Text = (textbox.current == "" and placeholder or textbox.current) ~= newtext and (newtext .. "...") or newtext
                textbox_value.Color = textbox.current == "" and (placeholder and theme.textdark) or theme.textcolor
                --
                library.colors[textbox_value] = {
                    OutlineColor = "textborder",
                    Color = textbox.current == "" and (placeholder and "textdark") or "textcolor"
                }
                --
                if not first then
                    callback(textbox.current)
                end
            end
            --
            textbox:Set(textbox.current, true)
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and textbox_outline.Visible and window.isVisible then
                    if reactive and utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + textbox.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + textbox.axis + 20}) and not window:IsOverContent() then
                        Spawn(function()
                            utility:LoadImage(textbox_gradient, "gradientdown", "https://i.imgur.com/DzrzUt3.png") 
                            --
                            Wait(0.15)
                            --
                            utility:LoadImage(textbox_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png") 
                        end)
                        --
                        if not (window.currentContent.textbox and window.currentContent.textbox.Name == identifier) then
                            window:CloseContent()
                            --
                            textbox_value.Color = theme.accent
                            --
                            library.colors[textbox_value] = {
                                OutlineColor = "textborder",
                                Color = "accent"
                            }
                            --
                            ContextActionService:BindActionAtPriority("DisableKeyboard", function() return Enum.ContextActionResult.Sink end, false, 3000, Enum.UserInputType.Keyboard)
                            --
                            window.currentContent.textbox = {
                                Name = identifier,
                                Item = textbox,
                                Fire = function(Text)
                                    textbox.current = (Text == "Backspace" and textbox.current:sub(0, #textbox.current - 1) or (textbox.current .. Text)):sub(0, textbox.max)
                                    --
                                    local newtext = utility:WrapText(textbox.current == "" and placeholder or textbox.current, textbox_frame.Size.X - 30)
                                    textbox_value.Text = (textbox.current == "" and placeholder or textbox.current) ~= newtext and (newtext .. "...") or newtext
                                    textbox.callback(textbox.current)
                                end,
                                Disconnect = function()
                                    ContextActionService:UnbindAction('DisableKeyboard')
                                    --
                                    textbox_value.Color = textbox.current == "" and (placeholder and theme.textdark) or theme.textcolor
                                    --
                                    library.colors[textbox_value] = {
                                        OutlineColor = "textborder",
                                        Color = textbox.current == "" and (placeholder and "textdark") or "textcolor"
                                    }
                                end
                            }
                        else
                            if window.currentContent.textbox.Name == identifier then
                                window:CloseContent()
                            end
                        end
                    elseif reactive then
                        if window.currentContent.textbox and window.currentContent.textbox.Name == identifier then
                            window:CloseContent()
                        end
                    end
                    --
                    if Uis:IsKeyDown(Enum.KeyCode.LeftControl) and utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + textbox.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + textbox.axis + 20}) and not window:IsOverContent() then
                        Spawn(function()
                            textbox_value.Color = theme.accent
                            --
                            library.colors[textbox_value] = {
                                OutlineColor = "textborder",
                                Color = "accent"
                            }
                            --
                            utility:LoadImage(textbox_gradient, "gradientdown", "https://i.imgur.com/DzrzUt3.png") 
                            --
                            Wait(0.15)
                            --
                            textbox_value.Color = textbox.current == "" and (placeholder and theme.textdark) or theme.textcolor
                            --
                            library.colors[textbox_value] = {
                                OutlineColor = "textborder",
                                Color = textbox.current == "" and (placeholder and "textdark") or "textcolor"
                            }
                            --
                            utility:LoadImage(textbox_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                        end)
                        --
                        setclipboard(textbox.current)
                    end
                elseif Input.KeyCode and Input.KeyCode == Enum.KeyCode.Return then
                    if window.currentContent.textbox and window.currentContent.textbox.Name == identifier then
                        window:CloseContent()
                    end
                end
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = textbox
            end
            --
            section.currentAxis = section.currentAxis + 20 + 4
            --
            return textbox
        end
        --
        function sections:ButtonHolder(info)
            local info = info or {}
            local buttons = info.buttons or info.Buttons or {}
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local buttonHolder = {buttons = {}}
            --
            for i=1, 2 do
                local button = {axis = section.currentAxis}
                --
                local button_outline = utility:Create("Frame", {Vector2.new(i == 2 and ((section.section_frame.Size.X / 2) + 2) or 4,button.axis), section.section_frame}, {
                    Size = utility:Size(0.5, -6, 0, 20, section.section_frame),
                    Position = utility:Position(0, i == 2 and 2 or 4, 0, button.axis, section.section_frame),
                    Color = theme.outline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[button_outline] = {
                    Color = "outline"
                }
                --
                local button_inline = utility:Create("Frame", {Vector2.new(1,1), button_outline}, {
                    Size = utility:Size(1, -2, 1, -2, button_outline),
                    Position = utility:Position(0, 1, 0, 1, button_outline),
                    Color = theme.inline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[button_inline] = {
                    Color = "inline"
                }
                --
                local button_frame = utility:Create("Frame", {Vector2.new(1,1), button_inline}, {
                    Size = utility:Size(1, -2, 1, -2, button_inline),
                    Position = utility:Position(0, 1, 0, 1, button_inline),
                    Color = theme.lightcontrast,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[button_frame] = {
                    Color = "lightcontrast"
                }
                --
                local button_gradient = utility:Create("Image", {Vector2.new(0,0), button_frame}, {
                    Size = utility:Size(1, 0, 1, 0, button_frame),
                    Position = utility:Position(0, 0, 0 , 0, button_frame),
                    Transparency = 0.5,
                    Visible = page.open
                }, section.visibleContent)
                --
                local button_title = utility:Create("TextLabel", {Vector2.new(button_frame.Size.X/2,1), button_frame}, {
                    Text = buttons[i][1],
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Center = true,
                    Position = utility:Position(0.5, 0, 0, 1, button_frame),
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[button_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
                --
                utility:LoadImage(button_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                --
                library.began[#library.began + 1] = function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 and button_outline.Visible and window.isVisible and utility:MouseOverDrawing({section.section_frame.Position.X + (i == 2 and (section.section_frame.Size.X/2) or 0), section.section_frame.Position.Y + button.axis, section.section_frame.Position.X + section.section_frame.Size.X - (i == 1 and (section.section_frame.Size.X/2) or 0), section.section_frame.Position.Y + button.axis + 20}) and not window:IsOverContent() then
                        Spawn(function()
                            utility:LoadImage(button_gradient, "gradientdown", "https://i.imgur.com/DzrzUt3.png") 
                            --
                            Wait(0.15)
                            --
                            utility:LoadImage(button_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png") 
                        end)
                        --
                        buttons[i][2]()
                    end
                end
            end
            --
            section.currentAxis = section.currentAxis + 20 + 4
        end
        --
        function sections:Dropdown(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title
            local max = info.max or info.Max
            local options = info.options or info.Options or {"1", "2", "3"}
            local def = info.def or info.Def or info.default or info.Default or options[1]
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local dropdown = {open = false, scrollindex = max and 0, scrolling = max and {false, nil}, current = tostring(def), options = options, holder = {buttons = {}, drawings = {}}, axis = section.currentAxis}
            --
            local dropdown_outline = utility:Create("Frame", {Vector2.new(4,name and (dropdown.axis + 15) or dropdown.axis), section.section_frame}, {
                Size = utility:Size(1, -8, 0, 20, section.section_frame),
                Position = utility:Position(0, 4, 0, name and (dropdown.axis + 15) or dropdown.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[dropdown_outline] = {
                Color = "outline"
            }
            --
            local dropdown_inline = utility:Create("Frame", {Vector2.new(1,1), dropdown_outline}, {
                Size = utility:Size(1, -2, 1, -2, dropdown_outline),
                Position = utility:Position(0, 1, 0, 1, dropdown_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[dropdown_inline] = {
                Color = "inline"
            }
            --
            local dropdown_frame = utility:Create("Frame", {Vector2.new(1,1), dropdown_inline}, {
                Size = utility:Size(1, -2, 1, -2, dropdown_inline),
                Position = utility:Position(0, 1, 0, 1, dropdown_inline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[dropdown_frame] = {
                Color = "lightcontrast"
            }
            --
            if name then
                local dropdown_title = utility:Create("TextLabel", {Vector2.new(4,dropdown.axis), section.section_frame}, {
                    Text = name,
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Position = utility:Position(0, 4, 0, dropdown.axis, section.section_frame),
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[dropdown_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
            end
            --
            local dropdown__gradient = utility:Create("Image", {Vector2.new(0,0), dropdown_frame}, {
                Size = utility:Size(1, 0, 1, 0, dropdown_frame),
                Position = utility:Position(0, 0, 0 , 0, dropdown_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            local dropdown_value = utility:Create("TextLabel", {Vector2.new(3,dropdown_frame.Size.Y/2 - 7), dropdown_frame}, {
                Text = dropdown.current,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 3, 0, (dropdown_frame.Size.Y/2) - 7, dropdown_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[dropdown_value] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            local dropdown_image = utility:Create("Image", {Vector2.new(dropdown_frame.Size.X - 15,dropdown_frame.Size.Y/2 - 3), dropdown_frame}, {
                Size = utility:Size(0, 9, 0, 6, dropdown_frame),
                Position = utility:Position(1, -15, 0.5, -3, dropdown_frame),
                Visible = page.open
            }, section.visibleContent);dropdown["dropdown_image"] = dropdown_image
            --
            utility:LoadImage(dropdown_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
            utility:LoadImage(dropdown__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            if max then
                local lastupdate = dropdown.scrollindex
                --
                function dropdown:UpdateScroll()
                    if dropdown.scrollindex ~= lastupdate then
                        if max and dropdown.bar and dropdown.scroll then
                            lastupdate = dropdown.scrollindex
                            --
                            if (#dropdown.options - max) > 0 then
                                dropdown.bar.Size = utility:Size(1, 0, (max / #dropdown.options), 0, dropdown.scroll)
                                dropdown.bar.Position = utility:Position(0, 0, 0, (((dropdown.scroll.Size.Y - dropdown.bar.Size.Y) / (#dropdown.options - max)) * dropdown.scrollindex), dropdown.scroll)
                                utility:UpdateTransparency(dropdown.bar, 1)
                                utility:UpdateOffset(dropdown.bar, {Vector2.new(1, (((dropdown.scroll.Size.Y - dropdown.bar.Size.Y) / (#dropdown.options - max)) * dropdown.scrollindex)), dropdown.scroll})
                            else
                                dropdown.scrollindex = 0
                                dropdown.bar.Transparency = 0
                                utility:UpdateTransparency(dropdown.bar, 0)
                            end
                            --
                            dropdown:Update()
                        end
                    end
                end
            end
            --
            function dropdown:Update(lo)
                if dropdown.open and dropdown.holder.inline then
                    for i,v in pairs(dropdown.holder.buttons) do
                        local value = max and dropdown.options[i + dropdown.scrollindex] or dropdown.options[i]
                        --
                        options = lo
                        v[1].Text = value
                        v[1].Color = value == tostring(dropdown.current) and theme.accent or theme.textcolor
                        v[1].Position = utility:Position(0, value == tostring(dropdown.current) and 8 or 6, 0, 2, v[2])
                        library.colors[v[1]] = {
                            Color = v[1].Text == tostring(dropdown.current) and "accent" or "textcolor"
                        }
                        utility:UpdateOffset(v[1], {Vector2.new(v[1].Text == tostring(dropdown.current) and 8 or 6, 2), v[2]})
                    end
                end
            end
            --
            function dropdown:Set(value)
                if typeof(value) == "string" and Find(dropdown.options, value) then
                    dropdown.current = value
                    dropdown_value.Text = value
                    callback(value)
                end
            end
            --
            function dropdown:Get()
                return dropdown.current
            end
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and dropdown_outline.Visible then
                    if dropdown.open and dropdown.holder.inline and utility:MouseOverDrawing({dropdown.holder.inline.Position.X, dropdown.holder.inline.Position.Y, dropdown.holder.inline.Position.X + dropdown.holder.inline.Size.X, dropdown.holder.inline.Position.Y + dropdown.holder.inline.Size.Y}) then
                        if max and dropdown.bar and utility:MouseOverDrawing({dropdown.bar.Position.X - 1, dropdown.bar.Position.Y - 1, dropdown.bar.Position.X - 1 + dropdown.bar.Size.X + 2, dropdown.bar.Position.Y - 1 + dropdown.bar.Size.Y + 2}) then
                            dropdown.scrolling = {true, (utility:MouseLocation().Y - dropdown.bar.Position.Y)}
                        else
                            for i,v in pairs(dropdown.holder.buttons) do
                                local value = max and dropdown.options[(i + dropdown.scrollindex)] or dropdown.options[i]
                                --
                                if utility:MouseOverDrawing({v[2].Position.X, v[2].Position.Y, v[2].Position.X + v[2].Size.X, v[2].Position.Y + v[2].Size.Y}) and v[1].Text ~= dropdown.current then
                                    dropdown.current = value
                                    dropdown_value.Text = dropdown.current
                                    callback(value)
                                    dropdown:Update()
                                end
                            end
                        end
                    elseif utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + dropdown.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + dropdown.axis + (name and (15 + 20) or (20))}) and not window:IsOverContent() then
                        Spawn(function()
                            utility:LoadImage(dropdown__gradient, "gradientdown", "https://i.imgur.com/DzrzUt3.png") 
                            --
                            Wait(0.15)
                            --
                            utility:LoadImage(dropdown__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png") 
                        end)
                        --
                        if not dropdown.open then
                            window:CloseContent()
                            dropdown.open = not dropdown.open
                            utility:LoadImage(dropdown_image, "arrow_up", "https://i.imgur.com/SL9cbQp.png")
                            --
                            local dropdown_open_outline = utility:Create("Frame", {Vector2.new(0,19), dropdown_outline}, {
                                Size = utility:Size(1, 0, 0, 3 + ((max and max or #dropdown.options) * 19), dropdown_outline),
                                Position = utility:Position(0, 0, 0, 19, dropdown_outline),
                                Color = theme.outline,
                                Visible = page.open
                            }, dropdown.holder.drawings);dropdown.holder.outline = dropdown_open_outline
                            --
                            library.colors[dropdown_open_outline] = {
                                Color = "outline"
                            }
                            --
                            local dropdown_open_inline = utility:Create("Frame", {Vector2.new(1,1), dropdown_open_outline}, {
                                Size = utility:Size(1, -2, 1, -2, dropdown_open_outline),
                                Position = utility:Position(0, 1, 0, 1, dropdown_open_outline),
                                Color = theme.inline,
                                Visible = page.open
                            }, dropdown.holder.drawings);dropdown.holder.inline = dropdown_open_inline
                            --
                            library.colors[dropdown_open_inline] = {
                                Color = "inline"
                            }
                            --
                            if max then
                                local dropdown_open_scroll = utility:Create("Frame", {Vector2.new(dropdown_open_inline.Size.X - 5,1), dropdown_open_inline}, {
                                    Size = utility:Size(0, 4, 1, -2, dropdown_open_inline),
                                    Position = utility:Position(1, -5, 0, 1, dropdown_open_inline),
                                    Color = theme.darkcontrast,
                                    Visible = page.open
                                }, dropdown.holder.drawings);dropdown.scroll = dropdown_open_scroll
                                --
                                library.colors[dropdown_open_scroll] = {
                                    Color = "darkcontrast"
                                }
                                --
                                local dropdown_open_bar = utility:Create("Frame", {Vector2.new(0, (((dropdown_open_scroll.Size.Y - ((max / #dropdown.options) * dropdown_open_scroll.Size.Y)) / (#dropdown.options - max)) * dropdown.scrollindex)), dropdown_open_scroll}, {
                                    Size = utility:Size(1, 0, (max / #dropdown.options), 0, dropdown_open_scroll),
                                    Position = utility:Position(0, 0, 0, (((dropdown_open_scroll.Size.Y - ((max / #dropdown.options) * dropdown_open_scroll.Size.Y)) / (#dropdown.options - max)) * dropdown.scrollindex), dropdown_open_scroll),
                                    Color = theme.accent,
                                    Visible = page.open
                                }, dropdown.holder.drawings);dropdown.bar = dropdown_open_bar
                                --
                                library.colors[dropdown_open_bar] = {
                                    Color = "accent"
                                }
                            end
                            --
                            for Index = 1, (max and max or #dropdown.options) do
                                local Value = max and dropdown.options[Index + dropdown.scrollindex] or dropdown.options[Index]
                                --
                                if Value then
                                    local dropdown_value_frame = utility:Create("Frame", {Vector2.new(1,1 + (19 * (Index-1))), dropdown_open_inline}, {
                                        Size = utility:Size(1, -(max and 7 or 2), 0, 18, dropdown_open_inline),
                                        Position = utility:Position(0, 1, 0, 1 + (19 * (Index-1)), dropdown_open_inline),
                                        Color = theme.lightcontrast,
                                        Visible = page.open
                                    }, dropdown.holder.drawings)
                                    --
                                    library.colors[dropdown_value_frame] = {
                                        Color = "lightcontrast"
                                    }
                                    --
                                    local dropdown_value = utility:Create("TextLabel", {Vector2.new(Value == tostring(dropdown.current) and 8 or 6,2), dropdown_value_frame}, {
                                        Text = Value,
                                        Size = theme.textsize,
                                        Font = theme.font,
                                        Color = Value == tostring(dropdown.current) and theme.accent or theme.textcolor,
                                        OutlineColor = theme.textborder,
                                        Position = utility:Position(0, Value == tostring(dropdown.current) and 8 or 6, 0, 2, dropdown_value_frame),
                                        Visible = page.open
                                    }, dropdown.holder.drawings)
                                    --
                                    dropdown.holder.buttons[#dropdown.holder.buttons + 1] = {dropdown_value, dropdown_value_frame}
                                    --
                                    library.colors[dropdown_value] = {
                                        OutlineColor = "textborder",
                                        Color = Value == tostring(dropdown.current) and "accent" or "textcolor"
                                    }
                                end
                            end
                            --
                            window.currentContent.frame = dropdown_open_inline
                            window.currentContent.dropdown = dropdown
                        else
                            dropdown.open = not dropdown.open
                            utility:LoadImage(dropdown_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                            --
                            for i,v in pairs(dropdown.holder.drawings) do
                                utility:Remove(v)
                            end
                            --
                            dropdown.holder.drawings = {}
                            dropdown.holder.buttons = {}
                            dropdown.holder.inline = nil
                            --
                            window.currentContent.frame = nil
                            window.currentContent.dropdown = nil
                        end
                    else
                        if dropdown.open then
                            dropdown.open = not dropdown.open
                            utility:LoadImage(dropdown_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                            --
                            for i,v in pairs(dropdown.holder.drawings) do
                                utility:Remove(v)
                            end
                            --
                            dropdown.holder.drawings = {}
                            dropdown.holder.buttons = {}
                            dropdown.holder.inline = nil
                            --
                            window.currentContent.frame = nil
                            window.currentContent.dropdown = nil
                        end
                    end
                elseif Input.UserInputType == Enum.UserInputType.MouseButton1 and dropdown.open then
                    dropdown.open = not dropdown.open
                    utility:LoadImage(dropdown_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                    --
                    for i,v in pairs(dropdown.holder.drawings) do
                        utility:Remove(v)
                    end
                    --
                    dropdown.holder.drawings = {}
                    dropdown.holder.buttons = {}
                    dropdown.holder.inline = nil
                    --
                    window.currentContent.frame = nil
                    window.currentContent.dropdown = nil
                end
            end
            --
            if max then
                library.ended[#library.ended + 1] = function(Input)
                    if dropdown.scrolling and dropdown.scrolling[1] and Input.UserInputType == Enum.UserInputType.MouseButton1 then
                        dropdown.scrolling = {false, nil}
                    end
                end
                --
                library.changed[#library.changed + 1] = function(Input)
                    if dropdown.scrolling and dropdown.scrolling[1] then
                        local MouseLocation = utility:MouseLocation()
                        local Position = Clamp((MouseLocation.Y - dropdown.scroll.Position.Y - dropdown.scrolling[2]), 0, ((dropdown.scroll.Size.Y - dropdown.bar.Size.Y)))
                        --
                        dropdown.scrollindex = Round((((Position + dropdown.scroll.Position.Y) - dropdown.scroll.Position.Y) / ((dropdown.scroll.Size.Y - dropdown.bar.Size.Y))) * (#dropdown.options - max))
                        dropdown:UpdateScroll()
                    end
                end
                --
                utility:Connection(Mouse.WheelForward, (function()
                    if page.open and dropdown.open and dropdown.bar and dropdown.bar.Visible and utility:MouseOverDrawing({dropdown.holder.inline.Position.X, dropdown.holder.inline.Position.Y, dropdown.holder.inline.Position.X + dropdown.holder.inline.Size.X, dropdown.holder.inline.Position.Y + dropdown.holder.inline.Size.Y}) then
                        dropdown.scrollindex = Clamp(dropdown.scrollindex - 1, 0, #dropdown.options - max)
                        dropdown:UpdateScroll()
                    end
                end))
                --
                utility:Connection(Mouse.WheelBackward, (function()
                    if page.open and dropdown.open and dropdown.bar and dropdown.bar.Visible and utility:MouseOverDrawing({dropdown.holder.inline.Position.X, dropdown.holder.inline.Position.Y, dropdown.holder.inline.Position.X + dropdown.holder.inline.Size.X, dropdown.holder.inline.Position.Y + dropdown.holder.inline.Size.Y}) then
                        dropdown.scrollindex = Clamp(dropdown.scrollindex + 1, 0, #dropdown.options - max)
                        dropdown:UpdateScroll()
                    end
                end))
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = dropdown
            end
            --
            section.currentAxis = section.currentAxis + (name and 35 or 20) + 4
            --
            return dropdown
        end
        --
        function sections:Multibox(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title
            local options = info.options or info.Options or {"1", "2", "3"}
            local def = info.def or info.Def or info.default or info.Default or {options[1]}
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            local min = info.min or info.Min or info.minimum or info.Minimum or 0
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local multibox = {open = false, current = def, options = options, holder = {buttons = {}, drawings = {}}, axis = section.currentAxis}
            --
            local multibox_outline = utility:Create("Frame", {Vector2.new(4, name and (multibox.axis + 15) or multibox.axis), section.section_frame}, {
                Size = utility:Size(1, -8, 0, 20, section.section_frame),
                Position = utility:Position(0, 4, 0, name and (multibox.axis + 15) or multibox.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[multibox_outline] = {
                Color = "outline"
            }
            --
            local multibox_inline = utility:Create("Frame", {Vector2.new(1,1), multibox_outline}, {
                Size = utility:Size(1, -2, 1, -2, multibox_outline),
                Position = utility:Position(0, 1, 0, 1, multibox_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[multibox_inline] = {
                Color = "inline"
            }
            --
            local multibox_frame = utility:Create("Frame", {Vector2.new(1,1), multibox_inline}, {
                Size = utility:Size(1, -2, 1, -2, multibox_inline),
                Position = utility:Position(0, 1, 0, 1, multibox_inline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[multibox_frame] = {
                Color = "lightcontrast"
            }
            --
            if name then
                local multibox_title = utility:Create("TextLabel", {Vector2.new(4,multibox.axis), section.section_frame}, {
                    Text = name,
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = theme.textcolor,
                    OutlineColor = theme.textborder,
                    Position = utility:Position(0, 4, 0, multibox.axis, section.section_frame),
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[multibox_title] = {
                    OutlineColor = "textborder",
                    Color = "textcolor"
                }
            end
            --
            local multibox__gradient = utility:Create("Image", {Vector2.new(0,0), multibox_frame}, {
                Size = utility:Size(1, 0, 1, 0, multibox_frame),
                Position = utility:Position(0, 0, 0 , 0, multibox_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            local multibox_value = utility:Create("TextLabel", {Vector2.new(3,multibox_frame.Size.Y/2 - 7), multibox_frame}, {
                Text = "",
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 3, 0, (multibox_frame.Size.Y/2) - 7, multibox_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[multibox_value] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            local multibox_image = utility:Create("Image", {Vector2.new(multibox_frame.Size.X - 15,multibox_frame.Size.Y/2 - 3), multibox_frame}, {
                Size = utility:Size(0, 9, 0, 6, multibox_frame),
                Position = utility:Position(1, -15, 0.5, -3, multibox_frame),
                Visible = page.open
            }, section.visibleContent);multibox["multibox_image"] = multibox_image
            --
            utility:LoadImage(multibox_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
            utility:LoadImage(multibox__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function multibox:Update()
                if multibox.open and multibox.holder.inline then
                    for i,v in pairs(multibox.holder.buttons) do
                        v[1].Color = Find(multibox.current, v[1].Text) and theme.accent or theme.textcolor
                        v[1].Position = utility:Position(0, Find(multibox.current, v[1].Text) and 8 or 6, 0, 2, v[2])
                        --
                        library.colors[v[1]] = {
                            Color = Find(multibox.current, v[1].Text) and "accent" or "textcolor"
                        }
                        --
                        utility:UpdateOffset(v[1], {Vector2.new(Find(multibox.current, v[1].Text) and 8 or 6, 2), v[2]})
                    end
                end
            end
            --
            function multibox:Serialize(tbl)
                local str = ""
                --
                for i,v in pairs(tbl) do
                    str = str..v..", "
                end
                --
                return Sub(str, 0, #str - 2)
            end
            --
            function multibox:Resort(tbl,original)
                local newtbl = {}
                --
                for i,v in pairs(original) do
                    if Find(tbl, v) then
                        newtbl[#newtbl + 1] = v
                    end
                end
                --
                return newtbl
            end
            --
            function multibox:Set(tbl)
                if typeof(tbl) == "table" then
                    multibox.current = tbl
                    --
                    local text = multibox:Serialize(multibox:Resort(multibox.current, multibox.options))
                    multibox_value.Text = utility:WrapText(text, multibox_frame.Size.X - 25)
                end
            end
            --
            function multibox:Get()
                return multibox.current
            end
            --
            multibox_value.Text = utility:WrapText(multibox:Serialize(multibox:Resort(multibox.current, multibox.options)), multibox_frame.Size.X - 25)
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and multibox_outline.Visible then
                    if multibox.open and multibox.holder.inline and utility:MouseOverDrawing({multibox.holder.inline.Position.X, multibox.holder.inline.Position.Y, multibox.holder.inline.Position.X + multibox.holder.inline.Size.X, multibox.holder.inline.Position.Y + multibox.holder.inline.Size.Y}) then
                        for i,v in pairs(multibox.holder.buttons) do
                            if utility:MouseOverDrawing({v[2].Position.X, v[2].Position.Y, v[2].Position.X + v[2].Size.X, v[2].Position.Y + v[2].Size.Y}) and v[1].Text ~= multibox.current then
                                if not Find(multibox.current, v[1].Text) then
                                    multibox.current[#multibox.current + 1] = v[1].Text
                                    multibox_value.Text = utility:WrapText(multibox:Serialize(multibox:Resort(multibox.current, multibox.options)), multibox_frame.Size.X - 25)
                                    multibox:Update()
                                else
                                    if #multibox.current > min then
                                        Remove(multibox.current, Find(multibox.current, v[1].Text))
                                        multibox_value.Text = utility:WrapText(multibox:Serialize(multibox:Resort(multibox.current, multibox.options)), multibox_frame.Size.X - 25)
                                        multibox:Update()
                                    end
                                end
                            end
                        end
                    elseif utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + multibox.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + multibox.axis + (name and 15 or 0) + 20}) and not window:IsOverContent() then
                        Spawn(function()
                            utility:LoadImage(multibox__gradient, "gradientdown", "https://i.imgur.com/DzrzUt3.png") 
                            --
                            Wait(0.15)
                            --
                            utility:LoadImage(multibox__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png") 
                        end)
                        --
                        if not multibox.open then
                            window:CloseContent()
                            multibox.open = not multibox.open
                            utility:LoadImage(multibox_image, "arrow_up", "https://i.imgur.com/SL9cbQp.png")
                            --
                            local multibox_open_outline = utility:Create("Frame", {Vector2.new(0,19), multibox_outline}, {
                                Size = utility:Size(1, 0, 0, 3 + (#multibox.options * 19), multibox_outline),
                                Position = utility:Position(0, 0, 0, 19, multibox_outline),
                                Color = theme.outline,
                                Visible = page.open
                            }, multibox.holder.drawings);multibox.holder.outline = multibox_open_outline
                            --
                            library.colors[multibox_open_outline] = {
                                Color = "outline"
                            }
                            --
                            local multibox_open_inline = utility:Create("Frame", {Vector2.new(1,1), multibox_open_outline}, {
                                Size = utility:Size(1, -2, 1, -2, multibox_open_outline),
                                Position = utility:Position(0, 1, 0, 1, multibox_open_outline),
                                Color = theme.inline,
                                Visible = page.open
                            }, multibox.holder.drawings);multibox.holder.inline = multibox_open_inline
                            --
                            library.colors[multibox_open_inline] = {
                                Color = "inline"
                            }
                            --
                            for i,v in pairs(multibox.options) do
                                local multibox_value_frame = utility:Create("Frame", {Vector2.new(1,1 + (19 * (i-1))), multibox_open_inline}, {
                                    Size = utility:Size(1, -2, 0, 18, multibox_open_inline),
                                    Position = utility:Position(0, 1, 0, 1 + (19 * (i-1)), multibox_open_inline),
                                    Color = theme.lightcontrast,
                                    Visible = page.open
                                }, multibox.holder.drawings)
                                --
                                library.colors[multibox_value_frame] = {
                                    Color = "lightcontrast"
                                }
                                --[[
                                local multibox_value_gradient = utility:Create("Image", {Vector2.new(0,0), multibox_value_frame}, {
                                    Size = utility:Size(1, 0, 1, 0, multibox_value_frame),
                                    Position = utility:Position(0, 0, 0 , 0, multibox_value_frame),
                                    Transparency = 0.5,
                                    Visible = page.open
                                }, multibox.holder.drawings)
                                --
                                utility:LoadImage(multibox_value_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")]]
                                --
                                local multibox_value = utility:Create("TextLabel", {Vector2.new(Find(multibox.current, v) and 8 or 6,2), multibox_value_frame}, {
                                    Text = v,
                                    Size = theme.textsize,
                                    Font = theme.font,
                                    Color = Find(multibox.current, v) and theme.accent or theme.textcolor,
                                    OutlineColor = theme.textborder,
                                    Position = utility:Position(0, Find(multibox.current, v) and 8 or 6, 0, 2, multibox_value_frame),
                                    Visible = page.open
                                }, multibox.holder.drawings);multibox.holder.buttons[#multibox.holder.buttons + 1] = {multibox_value, multibox_value_frame}
                                --
                                library.colors[multibox_value] = {
                                    OutlineColor = "textborder",
                                    Color = Find(multibox.current, v) and "accent" or "textcolor"
                                }
                            end
                            --
                            window.currentContent.frame = multibox_open_inline
                            window.currentContent.multibox = multibox
                        else
                            multibox.open = not multibox.open
                            utility:LoadImage(multibox_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                            --
                            for i,v in pairs(multibox.holder.drawings) do
                                utility:Remove(v)
                            end
                            --
                            multibox.holder.drawings = {}
                            multibox.holder.buttons = {}
                            multibox.holder.inline = nil
                            --
                            window.currentContent.frame = nil
                            window.currentContent.multibox = nil
                        end
                    else
                        if multibox.open then
                            multibox.open = not multibox.open
                            utility:LoadImage(multibox_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                            --
                            for i,v in pairs(multibox.holder.drawings) do
                                utility:Remove(v)
                            end
                            --
                            multibox.holder.drawings = {}
                            multibox.holder.buttons = {}
                            multibox.holder.inline = nil
                            --
                            window.currentContent.frame = nil
                            window.currentContent.multibox = nil
                        end
                    end
                elseif Input.UserInputType == Enum.UserInputType.MouseButton1 and multibox.open then
                    multibox.open = not multibox.open
                    utility:LoadImage(multibox_image, "arrow_down", "https://i.imgur.com/tVqy0nL.png")
                    --
                    for i,v in pairs(multibox.holder.drawings) do
                        utility:Remove(v)
                    end
                    --
                    multibox.holder.drawings = {}
                    multibox.holder.buttons = {}
                    multibox.holder.inline = nil
                    --
                    window.currentContent.frame = nil
                    window.currentContent.multibox = nil
                end
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = multibox
            end
            --
            section.currentAxis = section.currentAxis + (name and 35 or 20) + 4
            --
            return multibox
        end
        --
        function sections:Keybind(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "New Keybind"
            local def = info.def or info.Def or info.default or info.Default or nil
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local mode = info.mode or info.Mode or "Always"
            local keybindname = info.keybindname or info.keybindName or info.Keybindname or info.KeybindName or nil
            local donotaddtolist = info.nothanks or false
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local keybind = {keybindname = keybindname or name, axis = section.currentAxis, current = {}, selecting = false, mode = mode, open = false, modemenu = {buttons = {}, drawings = {}}, active = false}
            --
            local allowedKeyCodes = {"Q","W","E","R","T","Y","U","I","O","P","A","S","D","F","G","H","J","K","L","Z","X","C","V","B","N","M","One","Two","Three","Four","Five","Six","Seveen","Eight","Nine","Zero", "Minus", "Equals","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","Insert","Tab","Home","End","LeftAlt","LeftControl","LeftShift","RightAlt","RightControl","RightShift","CapsLock"}
            local allowedInputTypes = {"MouseButton1","MouseButton2","MouseButton3"}
            local shortenedInputs = {["MouseButton1"] = "MB1", ["MouseButton2"] = "MB2", ["MouseButton3"] = "MB3", ["Insert"] = "Ins", ["LeftAlt"] = "LAlt", ["LeftControl"] = "LC", ["LeftShift"] = "LS", ["RightAlt"] = "RAlt", ["RightControl"] = "RC", ["RightShift"] = "RS", ["CapsLock"] = "Caps"}
            --
            local keybind_outline = utility:Create("Frame", {Vector2.new(section.section_frame.Size.X-(40+4),keybind.axis), section.section_frame}, {
                Size = utility:Size(0, 40, 0, 17),
                Position = utility:Position(1, -(40+4), 0, keybind.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[keybind_outline] = {
                Color = "outline"
            }
            --
            local keybind_inline = utility:Create("Frame", {Vector2.new(1,1), keybind_outline}, {
                Size = utility:Size(1, -2, 1, -2, keybind_outline),
                Position = utility:Position(0, 1, 0, 1, keybind_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[keybind_inline] = {
                Color = "inline"
            }
            --
            local keybind_frame = utility:Create("Frame", {Vector2.new(1,1), keybind_inline}, {
                Size = utility:Size(1, -2, 1, -2, keybind_inline),
                Position = utility:Position(0, 1, 0, 1, keybind_inline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[keybind_frame] = {
                Color = "lightcontrast"
            }
            --
            local keybind_title = utility:Create("TextLabel", {Vector2.new(4,keybind.axis + (17/2) - (utility:GetTextBounds(name, theme.textsize, theme.font).Y/2)), section.section_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 4, 0, keybind.axis + (17/2) - (utility:GetTextBounds(name, theme.textsize, theme.font).Y/2), section.section_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[keybind_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            local keybind__gradient = utility:Create("Image", {Vector2.new(0,0), keybind_frame}, {
                Size = utility:Size(1, 0, 1, 0, keybind_frame),
                Position = utility:Position(0, 0, 0 , 0, keybind_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            local keybind_value = utility:Create("TextLabel", {Vector2.new(keybind_outline.Size.X/2,1), keybind_outline}, {
                Text = "...",
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder, 
                Center = true,
                Position = utility:Position(0.5, 0, 1, 0, keybind_outline),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[keybind_value] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            utility:LoadImage(keybind__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function keybind:Shorten(string)
                for i,v in pairs(shortenedInputs) do
                    string = Gsub(string, i, v)
                end
                return string
            end
            --
            function keybind:Change(input)
                input = input or "..."
                local inputTable = {}
                --
                if input.EnumType then
                    if input.EnumType == Enum.KeyCode or input.EnumType == Enum.UserInputType then
                        if Find(allowedKeyCodes, input.Name) or Find(allowedInputTypes, input.Name) then
                            inputTable = {input.EnumType == Enum.KeyCode and "KeyCode" or "UserInputType", input.Name}
                            --
                            keybind.current = inputTable
                            keybind_value.Text = #keybind.current > 0 and keybind:Shorten(keybind.current[2]) or "..."
                            --
                            return true
                        end
                    end
                end
                --
                return false
            end
            --
            function keybind:Get()
                return keybind.Current
            end
            --
            function keybind:Set(tbl)
                keybind.current = {tbl[1], tbl[2]}
                keybind_value.Text = #keybind.current > 0 and keybind:Shorten(keybind.current[2]) or "..."
                --
                if tbl[3] then
                    keybind.mode = tbl[3]
                end
                --
                keybind.active = (keybind.mode == "Always" or keybind.mode == "Off Hold") and true or false
                --
                if keybind.mode == "Off Hold" and not donotaddtolist then
                    window.keybindslist:Add(keybindname or name, keybind_value.Text)
                else
                    window.keybindslist:Remove(keybindname or name)
                end
                --
            end
            --
            function keybind:Active()
                return keybind.active
            end
            --
            function keybind:Reset()
                for i,v in pairs(keybind.modemenu.buttons) do
                    v.Color = v.Text == keybind.mode and theme.accent or theme.textcolor
                    --
                    library.colors[v] = {
                        Color = v.Text == keybind.mode and "accent" or "textcolor"
                    }
                end
                --
                keybind.active = (keybind.mode == "Always" or keybind.mode == "Off Hold") and true or false
                --
                if keybind.mode == "Off Hold" and not donotaddtolist then
                    window.keybindslist:Add(keybindname or name, keybind_value.Text)
                else
                    window.keybindslist:Remove(keybindname or name)
                end
                --
                if keybind.current[1] and keybind.current[2] then
                        if not GetFocusedTextBox() then
                        callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                    end
                end
            end
            --
            keybind:Change(def)
            --
            library.began[#library.began + 1] = function(Input)
                if keybind.current[1] and keybind.current[2] and not GetFocusedTextBox() then
                    if Input.KeyCode == Enum[keybind.current[1]][keybind.current[2]] or Input.UserInputType == Enum[keybind.current[1]][keybind.current[2]] then
                        if keybind.mode == "On Hold" then
                            keybind.active = true
                            if keybind.active and not donotaddtolist then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                            if not GetFocusedTextBox() then
                                callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                            end
                        elseif keybind.mode == "Off Hold" then
                            keybind.active = false
                            if keybind.active and not donotaddtolist then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                            if not GetFocusedTextBox() then
                                callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                            end
                        elseif keybind.mode == "Toggle" then
                            keybind.active = not keybind.active
                            if keybind.active and not donotaddtolist then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                            if not GetFocusedTextBox() then
                                callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                            end
                        end
                    end
                end
                --
                if keybind.selecting and window.isVisible then
                    local done = keybind:Change(Input.KeyCode.Name ~= "Unknown" and Input.KeyCode or Input.UserInputType)
                    if done  then
                        keybind.selecting = false
                        keybind.active = keybind.mode == "Always" and true or false
                        keybind_frame.Color = theme.lightcontrast
                        --
                        library.colors[keybind_frame] = {
                            Color = "lightcontrast"
                        }
                        --
                        if keybind.mode == "Off Hold" and not donotaddtolist and not GetFocusedTextBox() then
                            window.keybindslist:Add(keybindname or name, keybind_value.Text)
                        else
                            window.keybindslist:Remove(keybindname or name)
                        end
                        --
                        if not GetFocusedTextBox() then
                            callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                        end
                    end
                end
                --
                if not window.isVisible and keybind.selecting then
                    keybind.selecting = false
                    keybind_frame.Color = theme.lightcontrast
                    --
                    library.colors[keybind_frame] = {
                        Color = "lightcontrast"
                    }
                end
                --
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and keybind_outline.Visible then
                    if utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + keybind.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + keybind.axis + 17}) and not window:IsOverContent() and not keybind.selecting then
                        keybind.selecting = true
                        keybind_frame.Color = theme.darkcontrast
                        --
                        library.colors[keybind_frame] = {
                            Color = "darkcontrast"
                        }
                    end
                    if keybind.open and keybind.modemenu.frame then
                        if utility:MouseOverDrawing({keybind.modemenu.frame.Position.X, keybind.modemenu.frame.Position.Y, keybind.modemenu.frame.Position.X + keybind.modemenu.frame.Size.X, keybind.modemenu.frame.Position.Y + keybind.modemenu.frame.Size.Y}) then
                            local changed = false
                            --
                            for i,v in pairs(keybind.modemenu.buttons) do
                                if utility:MouseOverDrawing({keybind.modemenu.frame.Position.X, keybind.modemenu.frame.Position.Y + (15 * (i - 1)), keybind.modemenu.frame.Position.X + keybind.modemenu.frame.Size.X, keybind.modemenu.frame.Position.Y + (15 * (i - 1)) + 15}) then
                                    keybind.mode = v.Text
                                    changed = true
                                end
                            end
                            --
                            if changed then keybind:Reset() end
                        else
                            keybind.open = not keybind.open
                            --
                            for i,v in pairs(keybind.modemenu.drawings) do
                                utility:Remove(v)
                            end
                            --
                            keybind.modemenu.drawings = {}
                            keybind.modemenu.buttons = {}
                            keybind.modemenu.frame = nil
                            --
                            window.currentContent.frame = nil
                            window.currentContent.keybind = nil
                        end
                    end
                end
                --
                if Input.UserInputType == Enum.UserInputType.MouseButton2 and window.isVisible and keybind_outline.Visible then
                    if utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + keybind.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + keybind.axis + 17}) and not window:IsOverContent() and not keybind.selecting then
                        window:CloseContent()
                        keybind.open = not keybind.open
                        --
                        local modemenu = utility:Create("Frame", {Vector2.new(keybind_outline.Size.X + 2,0), keybind_outline}, {
                            Size = utility:Size(0, 68, 0, 64),
                            Position = utility:Position(1, 2, 0, 0, keybind_outline),
                            Color = theme.outline,
                            Visible = page.open
                        }, keybind.modemenu.drawings);keybind.modemenu.frame = modemenu
                        --
                        library.colors[modemenu] = {
                            Color = "outline"
                        }
                        --
                        local modemenu_inline = utility:Create("Frame", {Vector2.new(1,1), modemenu}, {
                            Size = utility:Size(1, -2, 1, -2, modemenu),
                            Position = utility:Position(0, 1, 0, 1, modemenu),
                            Color = theme.inline,
                            Visible = page.open
                        }, keybind.modemenu.drawings)
                        --
                        library.colors[modemenu_inline] = {
                            Color = "inline"
                        }
                        --
                        local modemenu_frame = utility:Create("Frame", {Vector2.new(1,1), modemenu_inline}, {
                            Size = utility:Size(1, -2, 1, -2, modemenu_inline),
                            Position = utility:Position(0, 1, 0, 1, modemenu_inline),
                            Color = theme.lightcontrast,
                            Visible = page.open
                        }, keybind.modemenu.drawings)
                        --
                        library.colors[modemenu_frame] = {
                            Color = "lightcontrast"
                        }
                        --
                        local keybind__gradient = utility:Create("Image", {Vector2.new(0,0), modemenu_frame}, {
                            Size = utility:Size(1, 0, 1, 0, modemenu_frame),
                            Position = utility:Position(0, 0, 0 , 0, modemenu_frame),
                            Transparency = 0.5,
                            Visible = page.open
                        }, keybind.modemenu.drawings)
                        --
                        utility:LoadImage(keybind__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                        --
                        for i,v in pairs({"Always", "Toggle", "On Hold", "Off Hold"}) do
                            local button_title = utility:Create("TextLabel", {Vector2.new(modemenu_frame.Size.X/2,15 * (i-1)), modemenu_frame}, {
                                Text = v,
                                Size = theme.textsize,
                                Font = theme.font,
                                Color = v == keybind.mode and theme.accent or theme.textcolor,
                                Center = true,
                                OutlineColor = theme.textborder,
                                Position = utility:Position(0.5, 0, 0, 15 * (i-1), modemenu_frame),
                                Visible = page.open
                            }, keybind.modemenu.drawings);keybind.modemenu.buttons[#keybind.modemenu.buttons + 1] = button_title
                            --
                            library.colors[button_title] = {
                                OutlineColor = "textborder",
                                Color = v == keybind.mode and "accent" or "textcolor"
                            }
                        end
                        --
                        window.currentContent.frame = modemenu
                        window.currentContent.keybind = keybind
                    end
                end
            end
            --
            library.ended[#library.ended + 1] = function(Input)
                if keybind.mode == "On Hold" or keybind.mode == "Off Hold" then
                    if keybind.current[1] and keybind.current[2] then
                        if Input.KeyCode == Enum[keybind.current[1]][keybind.current[2]] or Input.UserInputType == Enum[keybind.current[1]][keybind.current[2]] then
                            if keybind.mode == "On Hold" then
                                if keybind.active then
                                    keybind.active = false
                                    window.keybindslist:Remove(keybindname or name)
                                    if not GetFocusedTextBox() then
                                        callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                                    end
                                end
                            else
                                keybind.active = true
                                if keybind.active and not donotaddtolist then window.keybindslist:Add(keybindname or name, keybind_value.Text) else window.keybindslist:Remove(keybindname or name) end
                                if not GetFocusedTextBox() then
                                    callback(Enum[keybind.current[1]][keybind.current[2]], keybind.active)
                                end
                            end
                        end
                    end
                end
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = keybind
            end
            --
            section.currentAxis = section.currentAxis + 17 + 4
            --
            return keybind
        end
        --
        function sections:Colorpicker(info)
            local info = info or {}
            local name = info.name or info.Name or info.title or info.Title or "New Colorpicker"
            local cpinfo = info.info or info.Info or name
            local def = info.def or info.Def or info.default or info.Default or Color3.fromRGB(92, 72, 112)
            local transp = info.transparency or info.Transparency or info.transp or info.Transp or info.alpha or info.Alpha or 0.2
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
            --
            local window = self.window
            local page = self.page
            local section = self
            --
            local hh, ss, vv = def:ToHSV()
            local colorpicker = {axis = section.currentAxis, secondColorpicker = false, current = {hh, ss, vv , (transp or 0)}, holding = {picker = false, huepicker = false, transparency = false}, holder = {inline = nil, picker = nil, picker_cursor = nil, huepicker = nil, huepicker_cursor = {}, transparency = nil, transparencybg = nil, transparency_cursor = {}, drawings = {}}}
            --
            local colorpicker_outline = utility:Create("Frame", {Vector2.new(section.section_frame.Size.X-(30+4),colorpicker.axis), section.section_frame}, {
                Size = utility:Size(0, 30, 0, 15),
                Position = utility:Position(1, -(30+4), 0, colorpicker.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[colorpicker_outline] = {
                Color = "outline"
            }
            --
            local colorpicker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_outline}, {
                Size = utility:Size(1, -2, 1, -2, colorpicker_outline),
                Position = utility:Position(0, 1, 0, 1, colorpicker_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[colorpicker_inline] = {
                Color = "inline"
            }
            --
            local colorpicker__transparency
            if transp then
                colorpicker__transparency = utility:Create("Image", {Vector2.new(1,1), colorpicker_inline}, {
                    Size = utility:Size(1, -2, 1, -2, colorpicker_inline),
                    Position = utility:Position(0, 1, 0 , 1, colorpicker_inline),
                    Visible = page.open
                }, section.visibleContent)
            end
            --
            local colorpicker_frame = utility:Create("Frame", {Vector2.new(1,1), colorpicker_inline}, {
                Size = utility:Size(1, -2, 1, -2, colorpicker_inline),
                Position = utility:Position(0, 1, 0, 1, colorpicker_inline),
                Color = def,
                Transparency = transp and (1 - transp) or 1,
                Visible = page.open
            }, section.visibleContent)
            --
            local colorpicker__gradient = utility:Create("Image", {Vector2.new(0,0), colorpicker_frame}, {
                Size = utility:Size(1, 0, 1, 0, colorpicker_frame),
                Position = utility:Position(0, 0, 0 , 0, colorpicker_frame),
                Transparency = .65,
                Visible = page.open
            }, section.visibleContent)
            --
            local colorpicker_title = utility:Create("TextLabel", {Vector2.new(4,colorpicker.axis + (15/2) - (utility:GetTextBounds(name, theme.textsize, theme.font).Y/2)), section.section_frame}, {
                Text = name,
                Size = theme.textsize,
                Font = theme.font,
                Color = theme.textcolor,
                OutlineColor = theme.textborder,
                Position = utility:Position(0, 4, 0, colorpicker.axis + (15/2) - (utility:GetTextBounds(name, theme.textsize, theme.font).Y/2), section.section_frame),
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[colorpicker_title] = {
                OutlineColor = "textborder",
                Color = "textcolor"
            }
            --
            if transp then
                utility:LoadImage(colorpicker__transparency, "cptransp", "https://i.imgur.com/IIPee2A.png")
            end
            utility:LoadImage(colorpicker__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function colorpicker:Set(arg)
                local color, transp_val 
                if typeof(arg) == "Color3" then
                    color, transp_val = arg, 0
                elseif arg.Color and arg.Transparency then
                    color, transp_val = arg.Color, arg.Transparency
                else
                    color, transp_val = Color3.new(arg[1], arg[2], arg[3]), arg[4]
                end
                
                if typeof(color) == "table" then
                    colorpicker.current = color
                    colorpicker_frame.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                    colorpicker_frame.Transparency = 1 - colorpicker.current[4]
                    callback(Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), colorpicker.current[4])
                elseif typeof(color) == "Color3" then
                    local h, s, v = color:ToHSV()
                    colorpicker.current = {h, s, v, (transp_val or 0)}
                    colorpicker_frame.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                    colorpicker_frame.Transparency = 1 - colorpicker.current[4]
                    callback(Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), colorpicker.current[4])
                end
            end
            
            --
            function colorpicker:Refresh()
                local mouseLocation = utility:MouseLocation()
                if colorpicker.open and colorpicker.holder.picker and colorpicker.holding.picker then
                    colorpicker.current[2] = Clamp(mouseLocation.X - colorpicker.holder.picker.Position.X, 0, colorpicker.holder.picker.Size.X) / colorpicker.holder.picker.Size.X
                    --
                    colorpicker.current[3] = 1-(Clamp(mouseLocation.Y - colorpicker.holder.picker.Position.Y, 0, colorpicker.holder.picker.Size.Y) / colorpicker.holder.picker.Size.Y)
                    --
                    colorpicker.holder.picker_cursor.Position = utility:Position(colorpicker.current[2], -3, 1-colorpicker.current[3] , -3, colorpicker.holder.picker)
                    --
                    utility:UpdateOffset(colorpicker.holder.picker_cursor, {Vector2.new((colorpicker.holder.picker.Size.X*colorpicker.current[2])-3,(colorpicker.holder.picker.Size.Y*(1-colorpicker.current[3]))-3), colorpicker.holder.picker})
                    --
                    if colorpicker.holder.transparencybg then
                        colorpicker.holder.transparencybg.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                    end
                elseif colorpicker.open and colorpicker.holder.huepicker and colorpicker.holding.huepicker then
                    colorpicker.current[1] = (Clamp(mouseLocation.Y - colorpicker.holder.huepicker.Position.Y, 0, colorpicker.holder.huepicker.Size.Y) / colorpicker.holder.huepicker.Size.Y)
                    --
                    colorpicker.holder.huepicker_cursor[1].Position = utility:Position(0, -3, colorpicker.current[1], -3, colorpicker.holder.huepicker)
                    colorpicker.holder.huepicker_cursor[2].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.huepicker_cursor[1])
                    colorpicker.holder.huepicker_cursor[3].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.huepicker_cursor[2])
                    colorpicker.holder.huepicker_cursor[3].Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                    --
                    utility:UpdateOffset(colorpicker.holder.huepicker_cursor[1], {Vector2.new(-3,(colorpicker.holder.huepicker.Size.Y*colorpicker.current[1])-3), colorpicker.holder.huepicker})
                    --
                    colorpicker.holder.background.Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                    --
                    if colorpicker.holder.transparency_cursor and colorpicker.holder.transparency_cursor[3] then
                        colorpicker.holder.transparency_cursor[3].Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4])
                    end
                    --
                    if colorpicker.holder.transparencybg then
                        colorpicker.holder.transparencybg.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                    end
                elseif colorpicker.open and colorpicker.holder.transparency and colorpicker.holding.transparency then
                    colorpicker.current[4] = 1 - (Clamp(mouseLocation.X - colorpicker.holder.transparency.Position.X, 0, colorpicker.holder.transparency.Size.X) / colorpicker.holder.transparency.Size.X)
                    --
                    colorpicker.holder.transparency_cursor[1].Position = utility:Position(1-colorpicker.current[4], -3, 0, -3, colorpicker.holder.transparency)
                    colorpicker.holder.transparency_cursor[2].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.transparency_cursor[1])
                    colorpicker.holder.transparency_cursor[3].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.transparency_cursor[2])
                    colorpicker.holder.transparency_cursor[3].Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4])
                    colorpicker_frame.Transparency = (1 - colorpicker.current[4])
                    --
                    utility:UpdateTransparency(colorpicker_frame, (1 - colorpicker.current[4]))
                    utility:UpdateOffset(colorpicker.holder.transparency_cursor[1], {Vector2.new((colorpicker.holder.transparency.Size.X*(1-colorpicker.current[4]))-3,-3), colorpicker.holder.transparency})
                    --
                    colorpicker.holder.background.Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                end
                --
                colorpicker:Set(colorpicker.current)
            end
            --
            function colorpicker:Get()
                return {Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), Transparency = colorpicker.current[4]}
            end
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and colorpicker_outline.Visible then
                    if colorpicker.open and colorpicker.holder.inline and utility:MouseOverDrawing({colorpicker.holder.inline.Position.X, colorpicker.holder.inline.Position.Y, colorpicker.holder.inline.Position.X + colorpicker.holder.inline.Size.X, colorpicker.holder.inline.Position.Y + colorpicker.holder.inline.Size.Y}) then
                        if colorpicker.holder.picker and utility:MouseOverDrawing({colorpicker.holder.picker.Position.X - 2, colorpicker.holder.picker.Position.Y - 2, colorpicker.holder.picker.Position.X - 2 + colorpicker.holder.picker.Size.X + 4, colorpicker.holder.picker.Position.Y - 2 + colorpicker.holder.picker.Size.Y + 4}) then
                            colorpicker.holding.picker = true
                            colorpicker:Refresh()
                        elseif colorpicker.holder.huepicker and utility:MouseOverDrawing({colorpicker.holder.huepicker.Position.X - 2, colorpicker.holder.huepicker.Position.Y - 2, colorpicker.holder.huepicker.Position.X - 2 + colorpicker.holder.huepicker.Size.X + 4, colorpicker.holder.huepicker.Position.Y - 2 + colorpicker.holder.huepicker.Size.Y + 4}) then
                            colorpicker.holding.huepicker = true
                            colorpicker:Refresh()
                        elseif colorpicker.holder.transparency and utility:MouseOverDrawing({colorpicker.holder.transparency.Position.X - 2, colorpicker.holder.transparency.Position.Y - 2, colorpicker.holder.transparency.Position.X - 2 + colorpicker.holder.transparency.Size.X + 4, colorpicker.holder.transparency.Position.Y - 2 + colorpicker.holder.transparency.Size.Y + 4}) then
                            colorpicker.holding.transparency = true
                            colorpicker:Refresh()
                        end
                    elseif utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + colorpicker.axis, section.section_frame.Position.X + section.section_frame.Size.X - (colorpicker.secondColorpicker and (30+4) or 0), section.section_frame.Position.Y + colorpicker.axis + 15}) and not window:IsOverContent() then
                        if not colorpicker.open then
                            window:CloseContent()
                            colorpicker.open = not colorpicker.open
                            --
                            local colorpicker_open_outline = utility:Create("Frame", {Vector2.new(4,colorpicker.axis + 19), section.section_frame}, {
                                Size = utility:Size(1, -8, 0, transp and 219 or 200, section.section_frame),
                                Position = utility:Position(0, 4, 0, colorpicker.axis + 19, section.section_frame),
                                Color = theme.outline
                            }, colorpicker.holder.drawings);colorpicker.holder.inline = colorpicker_open_outline
                            --
                            library.colors[colorpicker_open_outline] = {
                                Color = "outline"
                            }
                            --
                            local colorpicker_open_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_outline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_outline),
                                Position = utility:Position(0, 1, 0, 1, colorpicker_open_outline),
                                Color = theme.inline
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_open_inline] = {
                                Color = "inline"
                            }
                            --
                            local colorpicker_open_frame = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_inline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_inline),
                                Position = utility:Position(0, 1, 0, 1, colorpicker_open_inline),
                                Color = theme.darkcontrast
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_open_frame] = {
                                Color = "darkcontrast"
                            }
                            --
                            local colorpicker_open_accent = utility:Create("Frame", {Vector2.new(0,0), colorpicker_open_frame}, {
                                Size = utility:Size(1, 0, 0, 2, colorpicker_open_frame),
                                Position = utility:Position(0, 0, 0, 0, colorpicker_open_frame),
                                Color = theme.accent
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_open_accent] = {
                                Color = "accent"
                            }
                            --
                            local colorpicker_title = utility:Create("TextLabel", {Vector2.new(4,2), colorpicker_open_frame}, {
                                Text = cpinfo,
                                Size = theme.textsize,
                                Font = theme.font,
                                Color = theme.textcolor,
                                OutlineColor = theme.textborder,
                                Position = utility:Position(0, 4, 0, 2, colorpicker_open_frame),
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_title] = {
                                OutlineColor = "textborder",
                                Color = "textcolor"
                            }
                            --
                            local colorpicker_open_picker_outline = utility:Create("Frame", {Vector2.new(4,17), colorpicker_open_frame}, {
                                Size = utility:Size(1, -27, 1, transp and -40 or -21, colorpicker_open_frame),
                                Position = utility:Position(0, 4, 0, 17, colorpicker_open_frame),
                                Color = theme.outline
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_open_picker_outline] = {
                                Color = "outline"
                            }
                            --
                            local colorpicker_open_picker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_picker_outline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_picker_outline),
                                Position = utility:Position(0, 1, 0, 1, colorpicker_open_picker_outline),
                                Color = theme.inline
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_open_picker_inline] = {
                                Color = "inline"
                            }
                            --
                            local colorpicker_open_picker_bg = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_picker_inline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_picker_inline),
                                Position = utility:Position(0, 1, 0, 1, colorpicker_open_picker_inline),
                                Color = Color3.fromHSV(colorpicker.current[1],1,1)
                            }, colorpicker.holder.drawings);colorpicker.holder.background = colorpicker_open_picker_bg
                            --
                            local colorpicker_open_picker_image = utility:Create("Image", {Vector2.new(0,0), colorpicker_open_picker_bg}, {
                                Size = utility:Size(1, 0, 1, 0, colorpicker_open_picker_bg),
                                Position = utility:Position(0, 0, 0 , 0, colorpicker_open_picker_bg),
                            }, colorpicker.holder.drawings);colorpicker.holder.picker = colorpicker_open_picker_image
                            --
                            local colorpicker_open_picker_cursor = utility:Create("Image", {Vector2.new((colorpicker_open_picker_image.Size.X*colorpicker.current[2])-3,(colorpicker_open_picker_image.Size.Y*(1-colorpicker.current[3]))-3), colorpicker_open_picker_image}, {
                                Size = utility:Size(0, 6, 0, 6, colorpicker_open_picker_image),
                                Position = utility:Position(colorpicker.current[2], -3, 1-colorpicker.current[3] , -3, colorpicker_open_picker_image),
                            }, colorpicker.holder.drawings);colorpicker.holder.picker_cursor = colorpicker_open_picker_cursor
                            --
                            local colorpicker_open_huepicker_outline = utility:Create("Frame", {Vector2.new(colorpicker_open_frame.Size.X-19,17), colorpicker_open_frame}, {
                                Size = utility:Size(0, 15, 1, transp and -40 or -21, colorpicker_open_frame),
                                Position = utility:Position(1, -19, 0, 17, colorpicker_open_frame),
                                Color = theme.outline
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_open_huepicker_outline] = {
                                Color = "outline"
                            }
                            --
                            local colorpicker_open_huepicker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_outline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_outline),
                                Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_outline),
                                Color = theme.inline
                            }, colorpicker.holder.drawings)
                            --
                            library.colors[colorpicker_open_huepicker_inline] = {
                                Color = "inline"
                            }
                            --
                            local colorpicker_open_huepicker_image = utility:Create("Image", {Vector2.new(1,1), colorpicker_open_huepicker_inline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_inline),
                                Position = utility:Position(0, 1, 0 , 1, colorpicker_open_huepicker_inline),
                            }, colorpicker.holder.drawings);colorpicker.holder.huepicker = colorpicker_open_huepicker_image
                            --
                            local colorpicker_open_huepicker_cursor_outline = utility:Create("Frame", {Vector2.new(-3,(colorpicker_open_huepicker_image.Size.Y*colorpicker.current[1])-3), colorpicker_open_huepicker_image}, {
                                Size = utility:Size(1, 6, 0, 6, colorpicker_open_huepicker_image),
                                Position = utility:Position(0, -3, colorpicker.current[1], -3, colorpicker_open_huepicker_image),
                                Color = theme.outline
                            }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[1] = colorpicker_open_huepicker_cursor_outline
                            --
                            library.colors[colorpicker_open_huepicker_cursor_outline] = {
                                Color = "outline"
                            }
                            --
                            local colorpicker_open_huepicker_cursor_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_cursor_outline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_cursor_outline),
                                Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_cursor_outline),
                                Color = theme.textcolor
                            }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[2] = colorpicker_open_huepicker_cursor_inline
                            --
                            library.colors[colorpicker_open_huepicker_cursor_inline] = {
                                Color = "textcolor"
                            }
                            --
                            local colorpicker_open_huepicker_cursor_color = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_cursor_inline}, {
                                Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_cursor_inline),
                                Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_cursor_inline),
                                Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                            }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[3] = colorpicker_open_huepicker_cursor_color
                            --
                            if transp then
                                local colorpicker_open_transparency_outline = utility:Create("Frame", {Vector2.new(4,colorpicker_open_frame.Size.Y-19), colorpicker_open_frame}, {
                                    Size = utility:Size(1, -27, 0, 15, colorpicker_open_frame),
                                    Position = utility:Position(0, 4, 1, -19, colorpicker_open_frame),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_transparency_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_transparency_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_outline),
                                    Color = theme.inline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_transparency_inline] = {
                                    Color = "inline"
                                }
                                --
                                local colorpicker_open_transparency_bg = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_inline),
                                    Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                                }, colorpicker.holder.drawings);colorpicker.holder.transparencybg = colorpicker_open_transparency_bg
                                --
                                local colorpicker_open_transparency_image = utility:Create("Image", {Vector2.new(1,1), colorpicker_open_transparency_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_inline),
                                    Position = utility:Position(0, 1, 0 , 1, colorpicker_open_transparency_inline),
                                }, colorpicker.holder.drawings);colorpicker.holder.transparency = colorpicker_open_transparency_image
                                --
                                local colorpicker_open_transparency_cursor_outline = utility:Create("Frame", {Vector2.new((colorpicker_open_transparency_image.Size.X*(1-colorpicker.current[4]))-3,-3), colorpicker_open_transparency_image}, {
                                    Size = utility:Size(0, 6, 1, 6, colorpicker_open_transparency_image),
                                    Position = utility:Position(1-colorpicker.current[4], -3, 0, -3, colorpicker_open_transparency_image),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[1] = colorpicker_open_transparency_cursor_outline
                                --
                                library.colors[colorpicker_open_transparency_cursor_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_transparency_cursor_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_cursor_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_cursor_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_cursor_outline),
                                    Color = theme.textcolor
                                }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[2] = colorpicker_open_transparency_cursor_inline
                                --
                                library.colors[colorpicker_open_transparency_cursor_inline] = {
                                    Color = "textcolor"
                                }
                                --
                                local colorpicker_open_transparency_cursor_color = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_cursor_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_cursor_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_cursor_inline),
                                    Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4]),
                                }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[3] = colorpicker_open_transparency_cursor_color
                                --
                                utility:LoadImage(colorpicker_open_transparency_image, "transp", "https://i.imgur.com/ncssKbH.png")
                            end
                            --
                            utility:LoadImage(colorpicker_open_picker_image, "valsat", "https://i.imgur.com/wpDRqVH.png")
                            utility:LoadImage(colorpicker_open_picker_cursor, "valsat_cursor", "https://raw.githubusercontent.com/mvonwalk/splix-assets/main/Images-cursor.png")
                            utility:LoadImage(colorpicker_open_huepicker_image, "hue", "https://i.imgur.com/iEOsHFv.png")
                            --
                            window.currentContent.frame = colorpicker_open_inline
                            window.currentContent.colorpicker = colorpicker
                        else
                            colorpicker.open = not colorpicker.open
                            --
                            for i,v in pairs(colorpicker.holder.drawings) do
                                utility:Remove(v)
                            end
                            --
                            colorpicker.holder.drawings = {}
                            colorpicker.holder.inline = nil
                            --
                            window.currentContent.frame = nil
                            window.currentContent.colorpicker = nil
                        end
                    else
                        if colorpicker.open then
                            colorpicker.open = not colorpicker.open
                            --
                            for i,v in pairs(colorpicker.holder.drawings) do
                                utility:Remove(v)
                            end
                            --
                            colorpicker.holder.drawings = {}
                            colorpicker.holder.inline = nil
                            --
                            window.currentContent.frame = nil
                            window.currentContent.colorpicker = nil
                        end
                    end
                elseif Input.UserInputType == Enum.UserInputType.MouseButton1 and colorpicker.open then
                    colorpicker.open = not colorpicker.open
                    --
                    for i,v in pairs(colorpicker.holder.drawings) do
                        utility:Remove(v)
                    end
                    --
                    colorpicker.holder.drawings = {}
                    colorpicker.holder.inline = nil
                    --
                    window.currentContent.frame = nil
                    window.currentContent.colorpicker = nil
                end
            end
            --
            library.ended[#library.ended + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                    if colorpicker.holding.picker then
                        colorpicker.holding.picker = not colorpicker.holding.picker
                    end
                    if colorpicker.holding.huepicker then
                        colorpicker.holding.huepicker = not colorpicker.holding.huepicker
                    end
                    if colorpicker.holding.transparency then
                        colorpicker.holding.transparency = not colorpicker.holding.transparency
                    end
                end
            end
            --
            library.changed[#library.changed + 1] = function()
                if colorpicker.open and colorpicker.holding.picker or colorpicker.holding.huepicker or colorpicker.holding.transparency then
                    if window.isVisible then
                        colorpicker:Refresh()
                    else
                        if colorpicker.holding.picker then
                            colorpicker.holding.picker = not colorpicker.holding.picker
                        end
                        if colorpicker.holding.huepicker then
                            colorpicker.holding.huepicker = not colorpicker.holding.huepicker
                        end
                        if colorpicker.holding.transparency then
                            colorpicker.holding.transparency = not colorpicker.holding.transparency
                        end
                    end
                end
            end
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = colorpicker
            end
            --
            section.currentAxis = section.currentAxis + 15 + 4
            --
            function colorpicker:Colorpicker(info)
                local info = info or {}
                local cpinfo = info.info or info.Info or name
                local def = info.def or info.Def or info.default or info.Default or Color3.fromRGB(92, 72, 112)
                local transp = info.transparency or info.Transparency or info.transp or info.Transp or info.alpha or info.Alpha or 0.2
                local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
                local callback = info.callback or info.callBack or info.Callback or info.CallBack or function()end
                --
                colorpicker.secondColorpicker = true
                --
                local hh, ss, vv = def:ToHSV()
                local colorpicker = {axis = colorpicker.axis, current = {hh, ss, vv , (transp or 0)}, holding = {picker = false, huepicker = false, transparency = false}, holder = {inline = nil, picker = nil, picker_cursor = nil, huepicker = nil, huepicker_cursor = {}, transparency = nil, transparencybg = nil, transparency_cursor = {}, drawings = {}}}
                --
                colorpicker_outline.Position = utility:Position(1, -(60+8), 0, colorpicker.axis, section.section_frame)
                utility:UpdateOffset(colorpicker_outline, {Vector2.new(section.section_frame.Size.X-(60+8),colorpicker.axis), section.section_frame})
                --
                local colorpicker_outline = utility:Create("Frame", {Vector2.new(section.section_frame.Size.X-(30+4),colorpicker.axis), section.section_frame}, {
                    Size = utility:Size(0, 30, 0, 15),
                    Position = utility:Position(1, -(30+4), 0, colorpicker.axis, section.section_frame),
                    Color = theme.outline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[colorpicker_outline] = {
                    Color = "outline"
                }
                --
                local colorpicker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_outline}, {
                    Size = utility:Size(1, -2, 1, -2, colorpicker_outline),
                    Position = utility:Position(0, 1, 0, 1, colorpicker_outline),
                    Color = theme.inline,
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[colorpicker_inline] = {
                    Color = "inline"
                }
                --
                local colorpicker__transparency
                if transp then
                    colorpicker__transparency = utility:Create("Image", {Vector2.new(1,1), colorpicker_inline}, {
                        Size = utility:Size(1, -2, 1, -2, colorpicker_inline),
                        Position = utility:Position(0, 1, 0 , 1, colorpicker_inline),
                        Visible = page.open
                    }, section.visibleContent)
                end
                --
                local colorpicker_frame = utility:Create("Frame", {Vector2.new(1,1), colorpicker_inline}, {
                    Size = utility:Size(1, -2, 1, -2, colorpicker_inline),
                    Position = utility:Position(0, 1, 0, 1, colorpicker_inline),
                    Color = def,
                    Transparency = transp and (1 - transp) or 1,
                    Visible = page.open
                }, section.visibleContent)
                --
                local colorpicker__gradient = utility:Create("Image", {Vector2.new(0,0), colorpicker_frame}, {
                    Size = utility:Size(1, 0, 1, 0, colorpicker_frame),
                    Position = utility:Position(0, 0, 0 , 0, colorpicker_frame),
                    Transparency = 0.5,
                    Visible = page.open
                }, section.visibleContent)
                --
                if transp then
                    utility:LoadImage(colorpicker__transparency, "cptransp", "https://i.imgur.com/IIPee2A.png")
                end
                utility:LoadImage(colorpicker__gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
                --
                function colorpicker:Set(arg)
                    local color, transp_val 
                    if typeof(arg) == "Color3" then
                        color, transp_val = arg, 0
                    elseif arg.Color and arg.Transparency then
                        color, transp_val = arg.Color, arg.Transparency
                    else
                        color, transp_val = Color3.new(arg[1], arg[2], arg[3]), arg[4]
                    end
                    if typeof(color) == "table" then
                        colorpicker.current = color
                        colorpicker_frame.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                        colorpicker_frame.Transparency = 1 - colorpicker.current[4]
                        callback(Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), colorpicker.current[4])
                    elseif typeof(color) == "Color3" then
                        local h, s, v = color:ToHSV()
                        colorpicker.current = {h, s, v, (transp_val or 0)}
                        colorpicker_frame.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                        colorpicker_frame.Transparency = 1 - colorpicker.current[4]
                        callback(Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), colorpicker.current[4]) 
                    end
                end
                --
                function colorpicker:Refresh()
                    local mouseLocation = utility:MouseLocation()
                    if colorpicker.open and colorpicker.holder.picker and colorpicker.holding.picker then
                        colorpicker.current[2] = Clamp(mouseLocation.X - colorpicker.holder.picker.Position.X, 0, colorpicker.holder.picker.Size.X) / colorpicker.holder.picker.Size.X
                        --
                        colorpicker.current[3] = 1-(Clamp(mouseLocation.Y - colorpicker.holder.picker.Position.Y, 0, colorpicker.holder.picker.Size.Y) / colorpicker.holder.picker.Size.Y)
                        --
                        colorpicker.holder.picker_cursor.Position = utility:Position(colorpicker.current[2], -3, 1-colorpicker.current[3] , -3, colorpicker.holder.picker)
                        --
                        utility:UpdateOffset(colorpicker.holder.picker_cursor, {Vector2.new((colorpicker.holder.picker.Size.X*colorpicker.current[2])-3,(colorpicker.holder.picker.Size.Y*(1-colorpicker.current[3]))-3), colorpicker.holder.picker})
                        --
                        if colorpicker.holder.transparencybg then
                            colorpicker.holder.transparencybg.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                        end
                    elseif colorpicker.open and colorpicker.holder.huepicker and colorpicker.holding.huepicker then
                        colorpicker.current[1] = (Clamp(mouseLocation.Y - colorpicker.holder.huepicker.Position.Y, 0, colorpicker.holder.huepicker.Size.Y) / colorpicker.holder.huepicker.Size.Y)
                        --
                        colorpicker.holder.huepicker_cursor[1].Position = utility:Position(0, -3, colorpicker.current[1], -3, colorpicker.holder.huepicker)
                        colorpicker.holder.huepicker_cursor[2].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.huepicker_cursor[1])
                        colorpicker.holder.huepicker_cursor[3].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.huepicker_cursor[2])
                        colorpicker.holder.huepicker_cursor[3].Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                        --
                        utility:UpdateOffset(colorpicker.holder.huepicker_cursor[1], {Vector2.new(-3,(colorpicker.holder.huepicker.Size.Y*colorpicker.current[1])-3), colorpicker.holder.huepicker})
                        --
                        colorpicker.holder.background.Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                        --
                        if colorpicker.holder.transparency_cursor and colorpicker.holder.transparency_cursor[3] then
                            colorpicker.holder.transparency_cursor[3].Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4])
                        end
                        --
                        if colorpicker.holder.transparencybg then
                            colorpicker.holder.transparencybg.Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                        end
                    elseif colorpicker.open and colorpicker.holder.transparency and colorpicker.holding.transparency then
                        colorpicker.current[4] = 1 - (Clamp(mouseLocation.X - colorpicker.holder.transparency.Position.X, 0, colorpicker.holder.transparency.Size.X) / colorpicker.holder.transparency.Size.X)
                        --
                        colorpicker.holder.transparency_cursor[1].Position = utility:Position(1-colorpicker.current[4], -3, 0, -3, colorpicker.holder.transparency)
                        colorpicker.holder.transparency_cursor[2].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.transparency_cursor[1])
                        colorpicker.holder.transparency_cursor[3].Position = utility:Position(0, 1, 0, 1, colorpicker.holder.transparency_cursor[2])
                        colorpicker.holder.transparency_cursor[3].Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4])
                        colorpicker_frame.Transparency = (1 - colorpicker.current[4])
                        --
                        utility:UpdateTransparency(colorpicker_frame, (1 - colorpicker.current[4]))
                        utility:UpdateOffset(colorpicker.holder.transparency_cursor[1], {Vector2.new((colorpicker.holder.transparency.Size.X*(1-colorpicker.current[4]))-3,-3), colorpicker.holder.transparency})
                        --
                        colorpicker.holder.background.Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                    end
                    --
                    colorpicker:Set(colorpicker.current)
                end
                --
                function colorpicker:Get()
                    return {Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3]), Transparency = colorpicker.current[4]}
                end
                --
                library.began[#library.began + 1] = function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 and window.isVisible and colorpicker_outline.Visible then
                        if colorpicker.open and colorpicker.holder.inline and utility:MouseOverDrawing({colorpicker.holder.inline.Position.X, colorpicker.holder.inline.Position.Y, colorpicker.holder.inline.Position.X + colorpicker.holder.inline.Size.X, colorpicker.holder.inline.Position.Y + colorpicker.holder.inline.Size.Y}) then
                            if colorpicker.holder.picker and utility:MouseOverDrawing({colorpicker.holder.picker.Position.X - 2, colorpicker.holder.picker.Position.Y - 2, colorpicker.holder.picker.Position.X - 2 + colorpicker.holder.picker.Size.X + 4, colorpicker.holder.picker.Position.Y - 2 + colorpicker.holder.picker.Size.Y + 4}) then
                                colorpicker.holding.picker = true
                                colorpicker:Refresh()
                            elseif colorpicker.holder.huepicker and utility:MouseOverDrawing({colorpicker.holder.huepicker.Position.X - 2, colorpicker.holder.huepicker.Position.Y - 2, colorpicker.holder.huepicker.Position.X - 2 + colorpicker.holder.huepicker.Size.X + 4, colorpicker.holder.huepicker.Position.Y - 2 + colorpicker.holder.huepicker.Size.Y + 4}) then
                                colorpicker.holding.huepicker = true
                                colorpicker:Refresh()
                            elseif colorpicker.holder.transparency and utility:MouseOverDrawing({colorpicker.holder.transparency.Position.X - 2, colorpicker.holder.transparency.Position.Y - 2, colorpicker.holder.transparency.Position.X - 2 + colorpicker.holder.transparency.Size.X + 4, colorpicker.holder.transparency.Position.Y - 2 + colorpicker.holder.transparency.Size.Y + 4}) then
                                colorpicker.holding.transparency = true
                                colorpicker:Refresh()
                            end
                        elseif utility:MouseOverDrawing({section.section_frame.Position.X + (section.section_frame.Size.X - (30 + 4 + 2)), section.section_frame.Position.Y + colorpicker.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + colorpicker.axis + 15}) and not window:IsOverContent() then
                            if not colorpicker.open then
                                window:CloseContent()
                                colorpicker.open = not colorpicker.open
                                --
                                local colorpicker_open_outline = utility:Create("Frame", {Vector2.new(4,colorpicker.axis + 19), section.section_frame}, {
                                    Size = utility:Size(1, -8, 0, transp and 219 or 200, section.section_frame),
                                    Position = utility:Position(0, 4, 0, colorpicker.axis + 19, section.section_frame),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings);colorpicker.holder.inline = colorpicker_open_outline
                                --
                                library.colors[colorpicker_open_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_outline),
                                    Color = theme.inline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_inline] = {
                                    Color = "inline"
                                }
                                --
                                local colorpicker_open_frame = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_inline),
                                    Color = theme.darkcontrast
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_frame] = {
                                    Color = "darkcontrast"
                                }
                                --
                                local colorpicker_open_accent = utility:Create("Frame", {Vector2.new(0,0), colorpicker_open_frame}, {
                                    Size = utility:Size(1, 0, 0, 2, colorpicker_open_frame),
                                    Position = utility:Position(0, 0, 0, 0, colorpicker_open_frame),
                                    Color = theme.accent
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_accent] = {
                                    Color = "accent"
                                }
                                --
                                local colorpicker_title = utility:Create("TextLabel", {Vector2.new(4,2), colorpicker_open_frame}, {
                                    Text = cpinfo,
                                    Size = theme.textsize,
                                    Font = theme.font,
                                    Color = theme.textcolor,
                                    OutlineColor = theme.textborder,
                                    Position = utility:Position(0, 4, 0, 2, colorpicker_open_frame),
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_title] = {
                                    OutlineColor = "textborder",
                                    Color = "textcolor"
                                }
                                --
                                local colorpicker_open_picker_outline = utility:Create("Frame", {Vector2.new(4,17), colorpicker_open_frame}, {
                                    Size = utility:Size(1, -27, 1, transp and -40 or -21, colorpicker_open_frame),
                                    Position = utility:Position(0, 4, 0, 17, colorpicker_open_frame),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_picker_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_picker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_picker_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_picker_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_picker_outline),
                                    Color = theme.inline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_picker_inline] = {
                                    Color = "inline"
                                }
                                --
                                local colorpicker_open_picker_bg = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_picker_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_picker_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_picker_inline),
                                    Color = Color3.fromHSV(colorpicker.current[1],1,1)
                                }, colorpicker.holder.drawings);colorpicker.holder.background = colorpicker_open_picker_bg
                                --
                                local colorpicker_open_picker_image = utility:Create("Image", {Vector2.new(0,0), colorpicker_open_picker_bg}, {
                                    Size = utility:Size(1, 0, 1, 0, colorpicker_open_picker_bg),
                                    Position = utility:Position(0, 0, 0 , 0, colorpicker_open_picker_bg),
                                }, colorpicker.holder.drawings);colorpicker.holder.picker = colorpicker_open_picker_image
                                --
                                local colorpicker_open_picker_cursor = utility:Create("Image", {Vector2.new((colorpicker_open_picker_image.Size.X*colorpicker.current[2])-3,(colorpicker_open_picker_image.Size.Y*(1-colorpicker.current[3]))-3), colorpicker_open_picker_image}, {
                                    Size = utility:Size(0, 6, 0, 6, colorpicker_open_picker_image),
                                    Position = utility:Position(colorpicker.current[2], -3, 1-colorpicker.current[3] , -3, colorpicker_open_picker_image),
                                }, colorpicker.holder.drawings);colorpicker.holder.picker_cursor = colorpicker_open_picker_cursor
                                --
                                local colorpicker_open_huepicker_outline = utility:Create("Frame", {Vector2.new(colorpicker_open_frame.Size.X-19,17), colorpicker_open_frame}, {
                                    Size = utility:Size(0, 15, 1, transp and -40 or -21, colorpicker_open_frame),
                                    Position = utility:Position(1, -19, 0, 17, colorpicker_open_frame),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_huepicker_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_huepicker_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_outline),
                                    Color = theme.inline
                                }, colorpicker.holder.drawings)
                                --
                                library.colors[colorpicker_open_huepicker_inline] = {
                                    Color = "inline"
                                }
                                --
                                local colorpicker_open_huepicker_image = utility:Create("Image", {Vector2.new(1,1), colorpicker_open_huepicker_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_inline),
                                    Position = utility:Position(0, 1, 0 , 1, colorpicker_open_huepicker_inline),
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker = colorpicker_open_huepicker_image
                                --
                                local colorpicker_open_huepicker_cursor_outline = utility:Create("Frame", {Vector2.new(-3,(colorpicker_open_huepicker_image.Size.Y*colorpicker.current[1])-3), colorpicker_open_huepicker_image}, {
                                    Size = utility:Size(1, 6, 0, 6, colorpicker_open_huepicker_image),
                                    Position = utility:Position(0, -3, colorpicker.current[1], -3, colorpicker_open_huepicker_image),
                                    Color = theme.outline
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[1] = colorpicker_open_huepicker_cursor_outline
                                --
                                library.colors[colorpicker_open_huepicker_cursor_outline] = {
                                    Color = "outline"
                                }
                                --
                                local colorpicker_open_huepicker_cursor_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_cursor_outline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_cursor_outline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_cursor_outline),
                                    Color = theme.textcolor
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[2] = colorpicker_open_huepicker_cursor_inline
                                --
                                library.colors[colorpicker_open_huepicker_cursor_inline] = {
                                    Color = "textcolor"
                                }
                                --
                                local colorpicker_open_huepicker_cursor_color = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_huepicker_cursor_inline}, {
                                    Size = utility:Size(1, -2, 1, -2, colorpicker_open_huepicker_cursor_inline),
                                    Position = utility:Position(0, 1, 0, 1, colorpicker_open_huepicker_cursor_inline),
                                    Color = Color3.fromHSV(colorpicker.current[1], 1, 1)
                                }, colorpicker.holder.drawings);colorpicker.holder.huepicker_cursor[3] = colorpicker_open_huepicker_cursor_color
                                --
                                if transp then
                                    local colorpicker_open_transparency_outline = utility:Create("Frame", {Vector2.new(4,colorpicker_open_frame.Size.Y-19), colorpicker_open_frame}, {
                                        Size = utility:Size(1, -27, 0, 15, colorpicker_open_frame),
                                        Position = utility:Position(0, 4, 1, -19, colorpicker_open_frame),
                                        Color = theme.outline
                                    }, colorpicker.holder.drawings)
                                    --
                                    library.colors[colorpicker_open_transparency_outline] = {
                                        Color = "outline"
                                    }
                                    --
                                    local colorpicker_open_transparency_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_outline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_outline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_outline),
                                        Color = theme.inline
                                    }, colorpicker.holder.drawings)
                                    --
                                    library.colors[colorpicker_open_transparency_inline] = {
                                        Color = "inline"
                                    }
                                    --
                                    local colorpicker_open_transparency_bg = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_inline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_inline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_inline),
                                        Color = Color3.fromHSV(colorpicker.current[1], colorpicker.current[2], colorpicker.current[3])
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparencybg = colorpicker_open_transparency_bg
                                    --
                                    local colorpicker_open_transparency_image = utility:Create("Image", {Vector2.new(1,1), colorpicker_open_transparency_inline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_inline),
                                        Position = utility:Position(0, 1, 0 , 1, colorpicker_open_transparency_inline),
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency = colorpicker_open_transparency_image
                                    --
                                    local colorpicker_open_transparency_cursor_outline = utility:Create("Frame", {Vector2.new((colorpicker_open_transparency_image.Size.X*(1-colorpicker.current[4]))-3,-3), colorpicker_open_transparency_image}, {
                                        Size = utility:Size(0, 6, 1, 6, colorpicker_open_transparency_image),
                                        Position = utility:Position(1-colorpicker.current[4], -3, 0, -3, colorpicker_open_transparency_image),
                                        Color = theme.outline
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[1] = colorpicker_open_transparency_cursor_outline
                                    --
                                    library.colors[colorpicker_open_transparency_cursor_outline] = {
                                        Color = "outline"
                                    }
                                    --
                                    local colorpicker_open_transparency_cursor_inline = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_cursor_outline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_cursor_outline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_cursor_outline),
                                        Color = theme.textcolor
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[2] = colorpicker_open_transparency_cursor_inline
                                    --
                                    library.colors[colorpicker_open_transparency_cursor_inline] = {
                                        Color = "textcolor"
                                    }
                                    --
                                    local colorpicker_open_transparency_cursor_color = utility:Create("Frame", {Vector2.new(1,1), colorpicker_open_transparency_cursor_inline}, {
                                        Size = utility:Size(1, -2, 1, -2, colorpicker_open_transparency_cursor_inline),
                                        Position = utility:Position(0, 1, 0, 1, colorpicker_open_transparency_cursor_inline),
                                        Color = Color3.fromHSV(0, 0, 1 - colorpicker.current[4]),
                                    }, colorpicker.holder.drawings);colorpicker.holder.transparency_cursor[3] = colorpicker_open_transparency_cursor_color
                                    --
                                    utility:LoadImage(colorpicker_open_transparency_image, "transp", "https://i.imgur.com/ncssKbH.png")
                                    --utility:LoadImage(colorpicker_open_transparency_image, "transp", "https://i.imgur.com/VcMAYjL.png")
                                end
                                --
                                utility:LoadImage(colorpicker_open_picker_image, "valsat", "https://i.imgur.com/wpDRqVH.png")
                                utility:LoadImage(colorpicker_open_picker_cursor, "valsat_cursor", "https://raw.githubusercontent.com/mvonwalk/splix-assets/main/Images-cursor.png")
                                utility:LoadImage(colorpicker_open_huepicker_image, "hue", "https://i.imgur.com/iEOsHFv.png")
                                --
                                window.currentContent.frame = colorpicker_open_inline
                                window.currentContent.colorpicker = colorpicker
                            else
                                colorpicker.open = not colorpicker.open
                                --
                                for i,v in pairs(colorpicker.holder.drawings) do
                                    utility:Remove(v)
                                end
                                --
                                colorpicker.holder.drawings = {}
                                colorpicker.holder.inline = nil
                                --
                                window.currentContent.frame = nil
                                window.currentContent.colorpicker = nil
                            end
                        else
                            if colorpicker.open then
                                colorpicker.open = not colorpicker.open
                                --
                                for i,v in pairs(colorpicker.holder.drawings) do
                                    utility:Remove(v)
                                end
                                --
                                colorpicker.holder.drawings = {}
                                colorpicker.holder.inline = nil
                                --
                                window.currentContent.frame = nil
                                window.currentContent.colorpicker = nil
                            end
                        end
                    elseif Input.UserInputType == Enum.UserInputType.MouseButton1 and colorpicker.open then
                        colorpicker.open = not colorpicker.open
                        --
                        for i,v in pairs(colorpicker.holder.drawings) do
                            utility:Remove(v)
                        end
                        --
                        colorpicker.holder.drawings = {}
                        colorpicker.holder.inline = nil
                        --
                        window.currentContent.frame = nil
                        window.currentContent.colorpicker = nil
                    end
                end
                --
                library.ended[#library.ended + 1] = function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                        if colorpicker.holding.picker then
                            colorpicker.holding.picker = not colorpicker.holding.picker
                        end
                        if colorpicker.holding.huepicker then
                            colorpicker.holding.huepicker = not colorpicker.holding.huepicker
                        end
                        if colorpicker.holding.transparency then
                            colorpicker.holding.transparency = not colorpicker.holding.transparency
                        end
                    end
                end
                --
                library.changed[#library.changed + 1] = function()
                    if colorpicker.open and colorpicker.holding.picker or colorpicker.holding.huepicker or colorpicker.holding.transparency then
                        if window.isVisible then
                            colorpicker:Refresh()
                        else
                            if colorpicker.holding.picker then
                                colorpicker.holding.picker = not colorpicker.holding.picker
                            end
                            if colorpicker.holding.huepicker then
                                colorpicker.holding.huepicker = not colorpicker.holding.huepicker
                            end
                            if colorpicker.holding.transparency then
                                colorpicker.holding.transparency = not colorpicker.holding.transparency
                            end
                        end
                    end
                end
                --
                if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                    library.pointers[tostring(pointer)] = keybind
                end
                --
                return colorpicker
            end
            --
            return colorpicker
        end
        --
        function sections:List(info)
            local info = info or {}
            local max = info.max or info.Max or info.maximum or info.Maximum or 8
            local current = info.def or info.Default or info.current or info.Current or 1
            local options = info.options or info.Options or {"1", "2", "3"}
            --
            local window = self.window
            local page = self.page
            local section = self
            local pointer = info.pointer or info.Pointer or info.flag or info.Flag or nil
            --
            local list = {axis = section.currentAxis, options = options, max = max, current = current, scrollingindex = 0, scrolling = {false, nil}, buttons = {}}
            --
            local list_outline = utility:Create("Frame", {Vector2.new(4,list.axis), section.section_frame}, {
                Size = utility:Size(1, -8, 0, ((list.max * 20) + 4), section.section_frame),
                Position = utility:Position(0, 4, 0, list.axis, section.section_frame),
                Color = theme.outline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[list_outline] = {
                Color = "outline"
            }
            --
            local list_inline = utility:Create("Frame", {Vector2.new(1,1), list_outline}, {
                Size = utility:Size(1, -2, 1, -2, list_outline),
                Position = utility:Position(0, 1, 0, 1, list_outline),
                Color = theme.inline,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[list_inline] = {
                Color = "inline"
            }
            --
            local list_frame = utility:Create("Frame", {Vector2.new(1,1), list_inline}, {
                Size = utility:Size(1, -2, 1, -2, list_inline),
                Position = utility:Position(0, 1, 0, 1, list_inline),
                Color = theme.lightcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[list_frame] = {
                Color = "lightcontrast"
            }
            --
            local list_scroll = utility:Create("Frame", {Vector2.new(list_frame.Size.X - 8,0), list_frame}, {
                Size = utility:Size(0, 8, 1, 0, list_frame),
                Position = utility:Position(1, -8, 0, 0, list_frame),
                Color = theme.darkcontrast,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[list_scroll] = {
                Color = "darkcontrast"
            }
            --
            local list_bar = utility:Create("Frame", {Vector2.new(1,1), list_scroll}, {
                Size = utility:Size(1, -2, (list.max / #list.options), -2, list_scroll),
                Position = utility:Position(0, 1, 0, 1, list_scroll),
                Color = theme.accent,
                Visible = page.open
            }, section.visibleContent)
            --
            library.colors[list_bar] = {
                Color = "accent"
            }
            --
            local list_gradient = utility:Create("Image", {Vector2.new(0,0), list_frame}, {
                Size = utility:Size(1, 0, 1, 0, list_frame),
                Position = utility:Position(0, 0, 0 , 0, list_frame),
                Transparency = 0.5,
                Visible = page.open
            }, section.visibleContent)
            --
            for i=1, list.max do
                local config_title = utility:Create("TextLabel", {Vector2.new(list_frame.Size.X/2,2 + (20 * (i-1))), list_frame}, {
                    Text = list.options[i] or "",
                    Size = theme.textsize,
                    Font = theme.font,
                    Color = i == 1 and theme.accent or theme.textcolor,
                    OutlineColor = theme.textborder,
                    Center = true,
                    Position = utility:Position(0.5, 0, 0, 2 + (20 * (i-1)), list_frame),
                    Visible = page.open
                }, section.visibleContent)
                --
                library.colors[config_title] = {
                    OutlineColor = "textborder",
                    Color = i == 1 and "accent" or "textcolor"
                }
                --
                list.buttons[i] = config_title
            end
            --
            utility:LoadImage(list_gradient, "gradient", "https://raw.githubusercontent.com/portallol/luna/main/modules/gradient45.png")
            --
            function list:UpdateScroll()
                if (#list.options - list.max) > 0 then
                    list_bar.Size = utility:Size(1, -2, (list.max / #list.options), -2, list_scroll)
                    list_bar.Position = utility:Position(0, 1, 0, 1 + ((((list_scroll.Size.Y - 2) - list_bar.Size.Y) / (#list.options - list.max)) * list.scrollingindex), list_scroll)
                    list_bar.Transparency = 1
                    utility:UpdateTransparency(list_bar, 1)
                    utility:UpdateOffset(list_bar, {Vector2.new(1, 1 + ((((list_scroll.Size.Y - 2) - list_bar.Size.Y) / (#list.options - list.max)) * list.scrollingindex)), list_scroll})
                else
                    list.scrollingindex = 0
                    list_bar.Transparency = 0
                    utility:UpdateTransparency(list_bar, 0)
                end
                --
                list:Refresh()
            end
            --
            function list:Refresh()
                for Index, Value in pairs(list.buttons) do
                    Value.Text = list.options[Index + list.scrollingindex] or ""
                    Value.Color = (Index + list.scrollingindex) == list.current and theme.accent or theme.textcolor
                    --
                    library.colors[Value] = {
                        OutlineColor = "textborder",
                        Color = (Index + list.scrollingindex) == list.current and "accent" or "textcolor"
                    }
                end
            end
            --
            function list:Get()
                return list.options[list.current + list.scrollingindex]
            end
            --
            function list:Set(current)
                list.current = current
                list:Refresh()
            end
            --
            library.began[#library.began + 1] = function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and list_outline.Visible and window.isVisible then
                    if utility:MouseOverDrawing({list_bar.Position.X, list_bar.Position.Y, list_bar.Position.X + list_bar.Size.X, list_bar.Position.Y + list_bar.Size.Y}) then
                        list.scrolling = {true, (utility:MouseLocation().Y - list_bar.Position.Y)}
                    elseif utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + list.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + list.axis + ((list.max * 20) + 4)}) and not window:IsOverContent() then
                        for i=1, list.max do
                            if utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + list.axis + 2 + (20 * (i-1)), section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + list.axis + 2 + (20 * (i-1)) + 20}) then
                                list.current = (i + list.scrollingindex)
                                list:Refresh()
                            end
                        end
                    end
                end
            end
            --
            library.ended[#library.ended + 1] = function(Input)
                if list.scrolling[1] and Input.UserInputType == Enum.UserInputType.MouseButton1 then
                    list.scrolling = {false, nil}
                end
            end
            --
            library.changed[#library.changed + 1] = function(Input)
                if list.scrolling[1] then
                    local MouseLocation = utility:MouseLocation()
                    local Position = Clamp((MouseLocation.Y - list_scroll.Position.Y - list.scrolling[2]), 0, ((list_scroll.Size.Y - list_bar.Size.Y)))
                    --
                    list.scrollingindex = Round((((Position + list_scroll.Position.Y) - list_scroll.Position.Y) / ((list_scroll.Size.Y - list_bar.Size.Y))) * (#list.options - list.max))
                    list:UpdateScroll()
                end
            end
            --
            utility:Connection(Mouse.WheelForward, (function()
                if page.open and list_bar.Visible and utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + list.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + list.axis + ((list.max * 20) + 4)}) and not window:IsOverContent() then
                    list.scrollingindex = Clamp(list.scrollingindex - 1, 0, #list.options - list.max)
                    list:UpdateScroll()
                end
            end))
            --
            utility:Connection(Mouse.WheelBackward, (function()
                if page.open and list_bar.Visible and utility:MouseOverDrawing({section.section_frame.Position.X, section.section_frame.Position.Y + list.axis, section.section_frame.Position.X + section.section_frame.Size.X, section.section_frame.Position.Y + list.axis + ((list.max * 20) + 4)}) and not window:IsOverContent() then
                    list.scrollingindex = Clamp(list.scrollingindex + 1, 0, #list.options - list.max)
                    list:UpdateScroll()
                end
            end))
            --
            if pointer and tostring(pointer) ~= "" and tostring(pointer) ~= " " and not library.pointers[tostring(pointer)] then
                library.pointers[tostring(pointer)] = list
            end
            --
            list:UpdateScroll()
            --
            section.currentAxis = section.currentAxis + ((list.max * 20) + 4) + 4
            --
            return list
        end
    end
end
local function GetDictionaryLength(Dictionary: table)
    local Length = 0
    for _ in pairs(Dictionary) do
        Length += 1
    end
    return Length
end
local protect_gui = function(Gui, Parent)
    if gethui and syn and syn.protect_gui then 
        Gui.Parent = gethui() 
    elseif not gethui and syn and syn.protect_gui then 
        syn.protect_gui(Gui)
        Gui.Parent = Parent 
    else 
        Gui.Parent = Parent 
    end
end
local Notifications = {}
local Menu = {}
Menu.Screen = Instance.new("ScreenGui")
Menu.Screen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
protect_gui(Menu.Screen, CoreGui)
Menu.ScreenSize = Menu.Screen.AbsoluteSize

local Notifications_Frame = Instance.new("Frame")
Notifications_Frame.Name = "Notifications"
Notifications_Frame.BackgroundTransparency = 1
Notifications_Frame.Size = UDim2.new(1, 0, 1, 36)
Notifications_Frame.Position = UDim2.fromOffset(0, -36)
Notifications_Frame.ZIndex = 5
Notifications_Frame.Parent = Menu.Screen

function Notify(Content: string, Delay: number)
    assert(typeof(Content) == "string", "missing argument #1, (string expected got " .. typeof(Content) .. ")")
    local Delay = typeof(Delay) == "number" and Delay or 3

    local Text = Instance.new("TextLabel")
    local Notification = {
        self = Text,
        Class = "Notification"
    }

    Text.Name = "Notification"
    Text.BackgroundTransparency = 1
    Text.Position = UDim2.new(0.5, -100, 1, -150 - (GetDictionaryLength(Notifications) * 15))
    Text.Size = UDim2.new(0, 0, 0, 15)
    Text.Text = Content
    Text.Font = Enum.Font.SourceSans
    Text.TextSize = 17
    Text.TextColor3 = Color3.new(1, 1, 1)
    Text.TextStrokeTransparency = 0.2
    Text.TextTransparency = 1
    Text.RichText = true
    Text.ZIndex = 4
    Text.Parent = Notifications_Frame

    local function CustomTweenOffset(Offset: number)
        spawn(function()
            local Steps = 33
            for i = 1, Steps do
                Text.Position += UDim2.fromOffset(Offset / Steps, 0)
                RS.RenderStepped:Wait()
            end
        end)
    end

    function Notification:Update()
        
    end

    function Notification:Destroy()
        Notifications[self] = nil
        Text:Destroy()

        local Index = 1
        for _, v in pairs(Notifications) do
            local self = v.self
            self.Position += UDim2.fromOffset(0, 15)
            Index += 1
        end
    end

    Notifications[Notification] = Notification
    
    local TweenIn  = TweenService:Create(Text, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), {TextTransparency = 0})
    local TweenOut = TweenService:Create(Text, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), {TextTransparency = 1})
    
    TweenIn:Play()
    CustomTweenOffset(100)
    
    TweenIn.Completed:Connect(function()
        delay(Delay, function()
            TweenOut:Play()
            CustomTweenOffset(100)

            TweenOut.Completed:Connect(function()
                Notification:Destroy()
            end)
        end)
    end)
end

do --// notification library
    do --// Notifications 
        local NotificationContainer = Instance.new("ScreenGui", gethui());
        do  --// Functions
            function Notificationslib:UpdateNotifications()
                local i = 0
                for v in next, Notificationslib do
                    if v.Holder then
                        local tween = utility:Tween(v.Holder, TweenInfo.new(0.8, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(0, 20, 0, 75 + (i * 25))})
                        i = i + 1
                    end
                end
            end;

            function Notificationslib:UpdateNotifications2(Item)
                for i,v in pairs(Item) do
                    if typeof(v) == "Instance" then
                        Spawn(function()
                            local tween = utility:Tween(v, TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundTransparency = 1});

                            tween.Completed:Connect(function()
                                if v.Name == "Holder" then
                                    v:Destroy();
                                end
                            end)
                        end);
                        if v.ClassName == "TextLabel" then
                            local tween = utility:Tween(v, TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {TextTransparency = 1})
                        end
                    end
                end
            end

            function Notificationslib:New(Text, Time, Color)
                Time = Time or 2;
                Color = Color or theme.Accent;
                Text = Text or "No text provided? retard? "..tostring(Random());

                local Notification = {};

                local Holder = Instance.new("Frame")
                Holder.Position = UDim2.new(0, -30, 0, 75);
                Holder.Size = UDim2.new(0, 0, 0, 23);
                Holder.BackgroundTransparency = 0;
                Holder.Parent = NotificationContainer;
                Holder.BackgroundColor3 = Color3.fromRGB(37, 37, 37);
                Holder.BorderSizePixel = 1
                Holder.BorderColor3 = Color3.fromRGB(0, 0, 0)
                Notification.Holder = Holder;

                local Background = Instance.new("Frame");
                Background.Parent = Holder;
                Background.Size = UDim2.new(1, -4, 1, -4);
                Background.BackgroundColor3 = Color3.fromRGB(17, 17, 17);
                Background.Position = UDim2.new(0, 2, 0, 2);
                Background.BorderSizePixel = 1
                Background.BorderColor3 = Color3.fromRGB(0, 0, 0)
                Notification.Background = Background;

                local AccentBar = Instance.new("Frame");
                AccentBar.Size = UDim2.new(0, 1, 1, 0);
                AccentBar.Parent = Background;
                AccentBar.BackgroundColor3 = Color;
                AccentBar.Position = UDim2.new(0, 0, 0, 0);
                AccentBar.BorderSizePixel = 0
                Notification.AccentBar = AccentBar;

                local AccentBar2 = Instance.new("Frame");
                AccentBar2.Size = UDim2.new(0, 0, 0, 1);
                AccentBar2.Position = UDim2.new(0, 0, 0, 15);
                AccentBar2.Parent = Background;
                AccentBar2.BackgroundColor3 = Color;
                AccentBar2.BorderSizePixel = 0

                Notification.AccentBar2 = AccentBar2
                local NotifText = Instance.new("TextLabel");
                NotifText.TextXAlignment = Enum.TextXAlignment.Left;
                NotifText.Position = UDim2.new(0, 3, 0, 0);
                NotifText.Size = UDim2.new(1, 0, 1, 0)
                NotifText.Parent = Background;
                NotifText.Font = Enum.Font.Ubuntu;
                NotifText.TextColor3 = Color3.new(1,1,1);
                NotifText.BackgroundTransparency = 1;
                NotifText.TextSize = 12.00;
                NotifText.Text = Text;

                Notification.NotifText = NotifText;
                Notification.Holder.Size = UDim2.new(0, NotifText.TextBounds.X + 10, 0, 19);

                AccentBar2.Size = UDim2.new(0, 1, 0, 1)

                Notificationslib[Notification] = true

                local Connection
                function Notification:Remove()
                    Notificationslib[Notification] = nil
                    Notificationslib:UpdateNotifications();
                end;
                Spawn(function()
                    Notification.Holder.Size = UDim2.new(0, NotifText.TextBounds.X + 10, 0, 19);
                    Notificationslib:UpdateNotifications()
                    Notification.AccentBar2:TweenSize(UDim2.new(0, Background.AbsoluteSize.X - 1, 0, 1), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, Time, false);
                    Wait(Time)

                    Notificationslib:UpdateNotifications2(Notification)
                    Wait(1.2)
                    Notification:Remove()
                end);
            end;
        end;
    end;

    do
        function utility:Tween(...)
            local NewTween = TweenService:Create(...)
            NewTween:Play();
            return NewTween;
        end;
        
    end
end
end)()

--
library.PerformConfigAction = (function(ConfigName, Action)
    if ConfigName then
        local ConfigFilePath = ("ethh.lol/Configs/%s/%s"):format(ETHH.Version, ConfigName .. ".lua")
        if Action == "Delete" then
            local Found = Find(ETHH.Configs, ConfigName)
            if Found then
                Remove(ETHH.Configs, Found)
                library:RefreshConfigList()
            end
            delfile(ConfigFilePath)
        elseif Action == "Save" then
            local Config = {}
            local pointers = library.pointers
            for Index, Pointer in pairs(pointers) do
                if Index ~= "ConfigConfiguration_Box" and Index ~= "ConfigConfiguration_Name" and Index ~= "Aimview" and Index ~= "Spectate" and Index ~= "Whitelisted" then
                    if Pointer.mode then
                        local Values = Pointer.current
                        Config[Index] = {Values[1] or "nil", Values[2] or "nil", Pointer.mode}
                    else
                        Config[Index] = Pointer:Get()
                    end
                end
            end
            if Config then
                local serializedConfig = serializer(Config)
                if not Find(ETHH.Configs, ConfigName) then
                    ETHH.Configs[#ETHH.Configs + 1] = ConfigName
                    library:RefreshConfigList()
                end
                writefile(ConfigFilePath, serializedConfig)
            end
        elseif Action == "Load" then
            local ConfigData = loadstring(readfile(ConfigFilePath))()
            if ConfigData then
                library:LoadConfig(ConfigData)
                Notificationslib:New(("Completed loading config '" .. ConfigName .. "'."), 1.5, theme.Accent)
            end
        end
    end
end)

local Script = {Functions = {}, Variables = {}, EspPlayers = {}, Connections = {}, StoredHealth = {}, Desync = {} , Whitelisted = {}}
local aimviewed = {}

local Resolver = {}

local Target,lastValidCFrame, EndPoint,oldmsg
local STOPSHIT = false
local lastmsgtick = tick()

-- // Fov Drawing
local SilentFovCircle = Drawing.new("Circle")
SilentFovCircle.Transparency = 1
SilentFovCircle.NumSides = 128
SilentFovCircle.Visible = false

local AimbotLine = Drawing.new("Line")
-- // Clone
local bodyClone = game:GetObjects("rbxassetid://8246626421")[1]; bodyClone.Humanoid:Destroy(); bodyClone.Head.Face:Destroy(); bodyClone.Parent = game.Workspace; bodyClone.HumanoidRootPart.Velocity = Vector3.new(); bodyClone.HumanoidRootPart.CFrame = CFrame.new(9999,9999,9999); bodyClone.HumanoidRootPart.Transparency = 1; bodyClone.HumanoidRootPart.CanCollide = false 
for i,v in pairs(bodyClone:GetDescendants()) do 
    if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then 
        v.CanCollide = false 
        v.Transparency = 0
    end 
end 
local visualizeChams = Instance.new("Highlight"); visualizeChams.Enabled = true; visualizeChams.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop; visualizeChams.FillColor = Color3.fromRGB(102, 60, 153); visualizeChams.OutlineColor =  Color3.fromRGB(0, 0, 0); visualizeChams.Adornee = bodyClone; visualizeChams.OutlineTransparency = 0.2; visualizeChams.FillTransparency = 0.5; visualizeChams.Parent = CoreGui

local targetHighlight = Instance.new("Highlight", CoreGui)
targetHighlight.Enabled = true
targetHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
targetHighlight.FillColor = Color3.fromRGB(0,0,0)
targetHighlight.OutlineColor = Color3.fromRGB(255,255,255)
targetHighlight.OutlineTransparency = 0.5
targetHighlight.FillTransparency = 0

local HitChams = Instance.new("Folder", Workspace)
local antiCheattick = 0
local crosshair_SpinAngle = 0
local crosshair_Lines = {}
local crosshair_Outlines = {}
local Tween = {}
local CursorSize = 0
Script.Functions.NewDrawing = LPH_NO_VIRTUALIZE(function(Type, Properties)
    local NewDrawing = Drawing.new(Type)
    for i, v in next, Properties or {} do
        NewDrawing[i] = v
    end
    return NewDrawing
end)

local function generateAngles(numLines)
    local angles = {}
    local angleIncrement = 2 * Pi / numLines
    
    for i = 1, numLines do
        local angle = (i - 1) * angleIncrement
        Insert(angles, angle)
    end
    
    return angles
end


-- // Tweens 
LPH_NO_VIRTUALIZE(function()
    Tween.EasingStyles = {
        [Enum.EasingStyle.Linear] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Delta
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                return Delta
            end
        },
        [Enum.EasingStyle.Cubic] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 3
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 3) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (4 * Delta ^ 3)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (4 * (Delta - 1) ^ 3) + 1
                end
            end
        },
        [Enum.EasingStyle.Quad] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 2
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (-(Delta - 1) ^ 2) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (2 * Delta ^ 2)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return -(2 * (Delta - 1) ^ 2) + 1
                end
            end
        },
        [Enum.EasingStyle.Quart] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 4
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (-(Delta - 1) ^ 4) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (8 * Delta ^ 4)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return -(8 * (Delta - 1) ^ 4) + 1
                end
            end
        },
        [Enum.EasingStyle.Quint] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 5
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 5) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (16 * Delta ^ 5)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (16 * (Delta - 1) ^ 5) + 1
                end
            end
        },
        [Enum.EasingStyle.Sine] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Sin(((Pi / 2) * Delta) - (Pi / 2)) + 1
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Sin((Pi / 2) * Delta)
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                return (0.5 * Sin((Pi * Delta) - (Pi / 2))) + 0.5
            end
        },
        [Enum.EasingStyle.Exponential] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (2 ^ ((10 * Delta) - 10)) - 0.001
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return 1.001 * (-2 ^ -(10 * Delta)) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return 0.5 * (2 ^ ((20 * Delta) - 10)) - 0.0005
                elseif 0.5 <= Delta and Delta <= 1 then
                    return 0.50025 * (-2 ^ (-(20 * Delta) + 10)) + 1
                end
            end
        },
        [Enum.EasingStyle.Back] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (Delta * Delta) * (Delta * (1.70158 + 1) - 1.70158)
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 2) * ((Delta - 1) * (1.70158 + 1) + 1.70158) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (2 * (Delta * Delta)) * ((2 * Delta) * (2.5949095 + 1) - 2.5949095)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (0.5 * ((2 * Delta) - 2) ^ 2) * (((2 * Delta) - 2) * (2.5949095 + 1) + 2.5949095) + 1
                end
            end
        },
        [Enum.EasingStyle.Bounce] = {
            [Enum.EasingDirection.In] = function(Delta)
                if 0 <= Delta and Delta <= (1 / 2.75) then
                    return 7.5625 * (Delta * Delta)
                elseif (1 / 2.75) <= Delta and Delta <= (2 / 2.75) then
                    return 7.5625 * (Delta - (1.5 / 2.75)) ^ 2 + 0.75
                elseif (2 / 2.75) <= Delta and Delta <= (2.5 / 2.75) then
                    return 7.5625 * (Delta - (2.25 / 2.75)) ^ 2 + 0.9375
                elseif (2.5 / 2.75) <= Delta and Delta <= 1 then
                    return 7.5625 * (Delta - (2.625 / 2.75)) ^ 2 + 0.984375
                end
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                if 0 <= Delta and Delta <= (0.25 / 2.75) then
                    return -7.5625 * (1 - Delta - (2.625 / 2.75)) ^ 2 + 0.015625
                elseif (0.25 / 2.75) <= Delta and Delta <= (0.75 / 2.75) then
                    return -7.5625 * (1 - Delta - (2.25 / 2.75)) ^ 2 + 0.0625
                elseif (0.75 / 2.75) <= Delta and Delta <= (1.75 / 2.75) then
                    return -7.5625 * (1 - Delta - (1.5 / 2.75)) ^ 2 + 0.25
                elseif (1.75 / 2.75) <= Delta and Delta <= 1 then
                    return 1 - 7.5625 * (1 - Delta) ^ 2
                end
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= (0.125 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (2.625 / 2.75)) ^ 2 + 0.015625)
                elseif (0.125 / 2.75) <= Delta and Delta <= (0.375 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (2.25 / 2.75)) ^ 2 + 0.0625)
                elseif (0.375 / 2.75) <= Delta and Delta <= (0.875 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (1.5 / 2.75)) ^ 2 + 0.25)
                elseif (0.875 / 2.75) <= Delta and Delta <= 0.5 then
                    return 0.5 * (1 - 7.5625 * (1 - (2 * Delta)) ^ 2)
                elseif 0.5 <= Delta and Delta <= (1.875 / 2.75) then
                    return 0.5 + 3.78125 * ((2 * Delta) - 1) ^ 2
                elseif (1.875 / 2.75) <= Delta and Delta <= (2.375 / 2.75) then
                    return 3.78125 * ((2 * Delta) - (4.25 / 2.75)) ^ 2 + 0.875
                elseif (2.375 / 2.75) <= Delta and Delta <= (2.625 / 2.75) then
                    return 3.78125 * ((2 * Delta) - (5 / 2.75)) ^ 2 + 0.96875
                elseif (2.625 / 2.75) <= Delta and Delta <= 1 then
                    return 3.78125 * ((2 * Delta) - (5.375 / 2.75)) ^ 2 + 0.9921875
                end
            end
        },
        [Enum.EasingStyle.Elastic] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (-2 ^ (10 * (Delta - 1))) * Sin(((2 * Pi) * (Delta - 1 - (0.3 / 4))) / 0.3)
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (2 ^ (-10 * Delta)) * Sin(((2 * Pi) * (Delta - (0.3 / 4))) / 0.3) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return -0.5 * (2 ^ ((20 * Delta) - 10)) * Sin(((2 * Pi) * ((2 * Delta) - 1.1125)) / 0.45)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return 0.5 * (2 ^ ((-20 * Delta) + 10)) * Sin(((2 * Pi) * ((2 * Delta) - 1.1125)) / 0.45) + 1
                end
            end
        },
        [Enum.EasingStyle.Circular] = {
            [Enum.EasingDirection.In] = function(Delta)
                return -Sqrt(1 - Delta ^ 2) + 1
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Sqrt(-(Delta - 1) ^ 2 + 1)
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return -Sqrt(-Delta ^ 2 + 0.25) + 0.5
                elseif 0.5 <= Delta and Delta <= 1 then
                    return Sqrt(-(Delta - 1) ^ 2 + 0.25) + 0.5
                end
            end
        }
    }
end)()

local crosshair_lineOffsets = generateAngles(4)
local Domain1 = Script.Functions.NewDrawing("Text", {Visible = false, Outline = true, Text = "ethh", Size = 13, Color = Color3.new(1, 1, 1)})
local Domain = Script.Functions.NewDrawing("Text", {Visible = false, Outline = true, Text = ".lol", Size = 13, Color = Color3.fromRGB(132, 108, 188)})

-- drawing lines for crosshair
do    
    for Index = 1, 4 do
        local line = Script.Functions.NewDrawing("Line",{
            Visible = false,
            Color = Color3.fromRGB(255,255,255),
            Thickness = 1,
            ZIndex = 2,
            Transparency = 1
        })
        --
        crosshair_Lines[Index] = line
        -- 
        local line_1 = Script.Functions.NewDrawing("Line",{
            Visible = false,
            Color = Color3.fromRGB(0, 0, 0),
            Thickness = 2.5,
            ZIndex = 1,
            Transparency = 1
        })
        --
        crosshair_Outlines[Index] = line_1
    end
end 

local Priority = {
    Current = 0,
    AutoArmor = 5,
    FireArmor = 4,
    Strafe = 3,
    Stomp = 2,
    CFDesync = 1,
}
local orbitAngle = 0

Script.Functions.TargetStrafe = LPH_NO_VIRTUALIZE(function()
    if not library.pointers["TargetStrafe"]:Active() then return end
    if Priority.Current > Priority.Strafe then
        return
    end
    if not Target then return end
    local hrp = Client.Character.HumanoidRootPart
    if not hrp then return end
    local char = Target.Character
    if not char then return end
    local target_hrp = char:FindFirstChild("HumanoidRootPart")
    if not target_hrp then return end
    Script.Desync["Old_CFrame"] = hrp.CFrame
    local mode = library.pointers["StrafeMode"]:Get()
    local newvector

    if mode == "Random" then
        newvector = Vector3.new(
            Random(-library.pointers["Minimum Distance"]:Get(), library.pointers["Maximum Distance"]:Get()), 
            Random(-library.pointers["Minimum height"]:Get(), library.pointers["Minimum height"]:Get()), 
            Random(-library.pointers["Minimum Distance"]:Get(), library.pointers["Maximum Distance"]:Get())
        )
    elseif mode == "Circle" then
        orbitAngle = orbitAngle + library.pointers["Maximum Distance"]:Get()
        local radius = library.pointers["Maximum height"]:Get()
        newvector = Vector3.new(
            radius * math.cos(orbitAngle), 
            library.pointers["Minimum Distance"]:Get(), 
            radius * math.sin(orbitAngle)
        )
    end

    if not Resolver:isValidPosition(Target) then
        Script.Desync["Target Strafe"] = Resolver:GetResolverData(Target).lastValidCFrame + (newvector + ((Resolver:GetResolverData(Target).Velocity * Script.Functions.GetPred())))
    else
        Script.Desync["Target Strafe"] = target_hrp.CFrame + (newvector + ((Resolver:GetResolverData(Target).Velocity * Script.Functions.GetPred())))
    end
    local Is_On_FFlags = Script.Functions.Fflags_Manager()
    Priority.Current = Priority.Strafe
    hrp.CFrame = Script.Desync["Target Strafe"]
    Script.Desync["Real_Pos"] = Client.Character.HumanoidRootPart.CFrame
    
    if library.pointers["Server_sided"]:Get() then
        if library.pointers["Visualize_Server_sided"]:Get() then
            bodyClone:SetPrimaryPartCFrame(target_hrp.CFrame + newvector)
            if library.pointers['LookATTarget']:Get() then
                local hrp2 = bodyClone.HumanoidRootPart
                local targetPosition = Target.Character.HumanoidRootPart.Position
                hrp2.CFrame = CFrame.lookAt(hrp2.Position, Vector3.new(targetPosition.X, (targetPosition.Y + newvector.Y), targetPosition.Z))
            end	
            visualizeChams.FillColor = library.pointers["CloneCOlor"]:Get().Color
            visualizeChams.FillTransparency =  library.pointers["CloneCOlor"]:Get().Transparency
            visualizeChams.OutlineColor = library.pointers["CloneCOlor"]:Get().Color
            visualizeChams.OutlineTransparency = library.pointers["CloneCOlor"]:Get().Transparency 
        else
            visualizeChams.Enabled = false
        end
        RS.PreRender:Wait()
        Client.Character.HumanoidRootPart.CFrame = Script.Desync["Old_CFrame"]
    end
    Script.Functions.Fflags_Manager(Is_On_FFlags)
    Priority.Current = 0
end)

Script.Functions.stomptarget = LPH_NO_VIRTUALIZE(function()
    if Priority.Current > Priority.Stomp then
        return
    end

    Priority.Current = Priority.Stomp

    local chosenpart = "UpperTorso"
    local curheight = 2.7
    chosenpart = Target.Character and Target.Character:FindFirstChild(chosenpart) or nil
    if not Target or not Target.Character or not chosenpart then
        return
    end
    
    Script.Desync["Old_CFrame"] = Client.Character.HumanoidRootPart.CFrame
    Client.Character.HumanoidRootPart.CFrame = CFrame.new(chosenpart.Position.X, chosenpart.Position.Y + curheight, chosenpart.Position.Z)
    local args = {
        [1] = "Stomp"
    }
    ReplicatedStorage.MainEvent:FireServer(unpack(args))
    if library.pointers["Server_sided"]:Get() and library.pointers["TargetStrafe"]:Active() then
        bodyClone:SetPrimaryPartCFrame(CFrame.new(chosenpart.Position.X, chosenpart.Position.Y + curheight, chosenpart.Position.Z))
        RS.PreRender:Wait()
        Client.Character.HumanoidRootPart.CFrame = Script.Desync["Old_CFrame"]
    end
    Priority.Current = 0
end)

Script.Functions.RayCastCheck = LPH_NO_VIRTUALIZE(function(Part, PartDescendant)
    local Character = Client.Character or Client.CharacterAdded.Wait(Client.CharacterAdded)
    local cam = Camera
    local Origin = cam.CFrame.Position

    local RayCastParams = RaycastParams.new()
    RayCastParams.FilterType = Enum.RaycastFilterType.Blacklist
    RayCastParams.FilterDescendantsInstances = {Character, cam}

    local Result = Workspace.Raycast(Workspace, Origin, Part.Position - Origin, RayCastParams)
    
    if (Result) then
        local PartHit = Result.Instance
        local Visible = (not PartHit or Instance.new("Part").IsDescendantOf(PartHit, PartDescendant))
        
        return Visible
    end
    return false
end)

Script.Functions.Knocked_Check = LPH_NO_VIRTUALIZE(function(Plr)
    local Grabbed = Plr.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    local KoCheck = true
    if Plr.Character.BodyEffects:FindFirstChild("K.O") then
        KoCheck = Plr.Character.BodyEffects:FindFirstChild("K.O").Value
    elseif Plr.Character.BodyEffects:FindFirstChild("KO") then
        KoCheck = Plr.Character.BodyEffects:FindFirstChild("KO").Value
    end
    if KoCheck or Grabbed then
        return false
    end
    return true
end)

Script.Functions.Death_Check = LPH_NO_VIRTUALIZE(function(Plr)
    return Plr and Plr.Character and Plr.Character:FindFirstChild("BodyEffects") and Plr.Character.BodyEffects:FindFirstChild("SDeath") and Plr.Character.BodyEffects:FindFirstChild("SDeath").Value or false
end)

Script.Functions.OnScreen = LPH_NO_VIRTUALIZE(function(Object)
    local _, OnScreen = Camera:WorldToScreenPoint(Object.Position)
    return OnScreen
end)

Script.Functions.GetMagnitudeFromMouse = LPH_NO_VIRTUALIZE(function(Part)
    local PartPos, OnScreen = Camera:WorldToScreenPoint(Part.Position)
    if OnScreen then
        local Magnitude = (Vector2.new(PartPos.X, PartPos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
        return Magnitude
    end
    return Huge
end)

Script.Functions.FindCrew = LPH_NO_VIRTUALIZE(function(Player)
	if Player:FindFirstChild("DataFolder") and Player.DataFolder:FindFirstChild("Information") and Player.DataFolder.Information:FindFirstChild("Crew") and Client:FindFirstChild("DataFolder") and Client.DataFolder:FindFirstChild("Information") and Client.DataFolder.Information:FindFirstChild("Crew") then
        if Client.DataFolder.Information:FindFirstChild("Crew").Value ~= nil and Player.DataFolder.Information:FindFirstChild("Crew").Value ~= nil and Player.DataFolder.Information:FindFirstChild("Crew").Value ~= "" and Client.DataFolder.Information:FindFirstChild("Crew").Value ~= "" then 
			return true
		end
	end
	return false
end)

local stopblyat = LPH_NO_VIRTUALIZE(function()
    local hasTool = Client.Character:FindFirstChildWhichIsA("Tool")
    if hasTool then
        hasTool:Deactivate()
    end
end)

Script.Functions.GetTarget = LPH_NO_VIRTUALIZE(function()
    local ClosestTarget = nil
    local Closest = Huge
    for _, v in pairs(Players:GetPlayers()) do
        if v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart") then
            
            if Find(Script.Whitelisted, v) then
                continue
            end
            if not Script.Functions.OnScreen(v.Character.HumanoidRootPart) then 
                continue 
            end
            if Find(library.pointers["Checks"]:Get(),"Crew Check") and Script.Functions.FindCrew(v) and v.DataFolder.Information:FindFirstChild("Crew").Value == Client.DataFolder.Information:FindFirstChild("Crew").Value then
                continue
            end
            if Find(library.pointers["Checks"]:Get(),"Dead Check") and Script.Functions.Death_Check(v) then
                continue
            end

            if Find(library.pointers["Checks"]:Get(),"Knocked Check") and not Script.Functions.Knocked_Check(v) then
                continue
            end
            if Find(library.pointers["Checks"]:Get(),"Wall Check") and not Script.Functions.RayCastCheck(v.Character.HumanoidRootPart, v.Character) then 
                continue 
            end
            local Distance = Script.Functions.GetMagnitudeFromMouse(v.Character.HumanoidRootPart)
            if library.pointers["Use Fov"]:Get() and (SilentFovCircle.Radius < Distance) then continue end
            if (Distance < Closest) then
                Closest = Distance
                ClosestTarget = v
            end
        end
    end
    Target = ClosestTarget
    if not library.pointers["AutoSelection"]:Get() then 
        Notificationslib:New("[ethh.lol] Locked on " .. Target.Name, 1.5, Color3.fromRGB(255, 102, 204))
    end
end)

Script.Functions.GetPred = LPH_NO_VIRTUALIZE(function()
    local pingvalue = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
    local split = Split(pingvalue,'(')
    local ping = tonumber(split[1])
    if ping < 10 then
        return 0.1112873
    elseif ping < 20 then
        return 0.1211928
    elseif ping < 30 then
        return 0.1254263
    elseif ping < 40 then
        return 0.1314356
    elseif ping < 50 then
        return 0.1368384
    elseif ping < 60 then
        return 0.12671983
    elseif ping < 70 then
        return 0.12862974
    elseif ping < 80 then
        return 0.13581963
    elseif ping < 90 then
        return 0.13873952
    elseif ping < 100 then
        return 0.14173456
    elseif ping < 110 then
        return 0.14362652
    elseif ping < 120 then
        return 0.14683943
    elseif ping < 130 then
        return 0.15175864
    elseif ping < 140 then
        return 0.15382643
    elseif ping < 150 then
        return 0.15873582
    end
    return 0.135
end)

Script.Functions.autoreload = LPH_NO_VIRTUALIZE(function()
    if Client.Character:FindFirstChildWhichIsA("Tool") and not Client.Character.BodyEffects.Reload.Value then
        local ammo = Client.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo")
        if ammo and ammo.Value <= 0 then
            ReplicatedStorage:FindFirstChild("MainEvent"):FireServer("Reload", Client.Character:FindFirstChildWhichIsA("Tool"))
            Wait(1)
        end
    end
end)

-- // thanks to rick for this algorithm 
local stringsplit = LPH_NO_VIRTUALIZE(function(inputstr, sep)
    if sep == nil then
            sep = "%s"
    end
    local t={}
    for str in Gmatch(inputstr, "([^"..sep.."]+)") do
            Insert(t, str)
    end
    return t
end)

local fetchBracketText = LPH_NO_VIRTUALIZE(function(str)
    local texts = {}
    for text in str:gmatch("%[(.-)%]") do
        Insert(texts, text)
    end
    return texts
end)

local ToolName = LPH_NO_VIRTUALIZE(function(Name)
    local cfittestn = Huge
    local cfittest = nil

    for _, i in pairs(Workspace.Ignored.Shop:GetChildren()) do

        local nobrackets = Concat(fetchBracketText(i.Name), "") 
        local price = stringsplit(i.Name, "-")
        price = price[#price]
        if price then 
            price = stringsplit(price, "$")[2]
        end
        if Name == nobrackets and tonumber(price or Huge) < cfittestn then
            cfittestn = tonumber(price or Huge)
            cfittest = i
        end
    end
    return cfittest
end)

function getGunsWithAmmo()
    local gunsWithAmmo = {}
    local shopFolder = game.Workspace.Ignored:FindFirstChild("Shop")
    if shopFolder then
        for _, item in ipairs(shopFolder:GetChildren()) do
            local name = Match(item.Name, "%[(.-)%]")
            if name and SFind(name, "Ammo") then
                local gunName = Gsub(name, "Ammo", "")
                gunName = gunName:gsub("^%s*(.-)%s*$", "%1")

                gunsWithAmmo[gunName] = {
                    Gun = ToolName(gunName),
                    Ammo = ToolName(name),
                }
            end
        end
    end
    
    return gunsWithAmmo
end
Script.Variables.Guns = getGunsWithAmmo()

local function hasToolInInventory(toolName)
    local backpack = Client.Backpack
    local character = Client.Character or Client.CharacterAdded:Wait()

    if backpack:FindFirstChild(toolName) then
        return true
    end

    if character:FindFirstChild(toolName) then
        return true
    end

    return false
end

local function unequipAllTools()
    local humanoid = Client.Character and Client.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        for _, tool in pairs(humanoid:GetAccessories()) do
            humanoid:UnequipTools()
        end
    end
end

Script.Functions.TProcket = LPH_NO_VIRTUALIZE(function()
    if library.pointers["BulletTP"]:Get() then
        local targetpos = CFrame.new(Workspace.Players[Target.Name].Head.CFrame.X,Workspace.Players[Target.Name].Head.CFrame.Y + 2,Workspace.Players[Target.Name].Head.CFrame.Z)
        local targetpos = targetpos + (Resolver:GetResolverData(Target).Velocity * Script.Functions.GetPred())
        for _, object in ipairs(Workspace.Ignored:GetChildren()) do
            if object:IsA("Model") and object:FindFirstChild("Launcher") then
                local launcher = object:FindFirstChild("Launcher")
                if launcher:IsA("BasePart") and isnetworkowner(launcher) then
                    if launcher:FindFirstChildOfClass("BodyVelocity") then
                        launcher.BodyVelocity:Destroy()
                    end
                    launcher.CFrame = targetpos
                end
            elseif object:IsA("BasePart") and object.Name == "Handle" and isnetworkowner(object) then
                if object:FindFirstChildOfClass("BodyVelocity") then
                    object.BodyVelocity:Destroy()
                end
                object.CFrame = targetpos
            elseif object:IsA("Model") and object.Name == "GrenadeLauncherAmmo" then
                local launcher = object:FindFirstChild("Main")
                if launcher:IsA("BasePart") and isnetworkowner(launcher) then
                    if launcher:FindFirstChildOfClass("BodyVelocity") then
                        launcher.BodyVelocity:Destroy()
                    end
                    launcher.CFrame = targetpos
                end
            end
        end
    end
end)

Script.Functions.BulletTp = LPH_NO_VIRTUALIZE(function()
    local character = Client.Character
    local Con1 = Script.Connections.BulletTP1
    local con2 = Script.Connections.BulletTP2

    if Con1 then
        Con1:Disconnect()
        Script.Connections.BulletTP1 = nil
    end

    if con2 then
        con2:Disconnect()
        Script.Connections.BulletTP2 = nil
    end

    local function refreshGrip(tool)
        tool.Parent = Client.Backpack;
        tool.Parent = Client.Character;
    end

    local function setPosition(tool, pos, oldPos)
        tool.GripPos = pos
        pcall(function()
            tool.Default.Transparency = 1
        end)
        refreshGrip(tool)
        RS.RenderStepped:Wait()
        tool.GripPos = oldPos
        pcall(function()
            tool.Default.Transparency = 0
        end)
        refreshGrip(tool)
    end
    
    local equipped, equippedtool, oldPos;

    local function toolActivated()
        if equippedtool then
            if Target then
                local getPos = Client.Character.HumanoidRootPart.CFrame:PointToObjectSpace(Target.Character.HumanoidRootPart.CFrame.Position);
                local setPos = Vector3.new(-getPos.Z, 0, getPos.X);
                setPosition(equippedtool, setPos, oldPos);
            end
        end
    end

    local function childAdded(tool)
        if tool:IsA("Tool") then
            equippedtool = tool;
            oldPos = tool.GripPos;
            equipped = tool.Activated:Connect(toolActivated);
        end
    end

    local function childRemoved(tool)
        if tool:IsA("Tool") then
            equippedtool = nil;
            if equipped then
                equipped:Disconnect();
            end
        end
    end

    Script.Connections.BulletTP1 = character.ChildAdded:Connect(childAdded);
    Script.Connections.BulletTP2 = character.ChildRemoved:Connect(childRemoved);
end)

Script.Functions.UpdateFov = LPH_NO_VIRTUALIZE(function()
    SilentFovCircle.Visible = library.pointers["Use Fov"]:Get()
    SilentFovCircle.Radius = library.pointers["FOV"]:Get() * 3
    SilentFovCircle.Color = library.pointers["FovColor"]:Get().Color
    SilentFovCircle.Transparency = library.pointers["FovColor"]:Get().Transparency
    SilentFovCircle.Position = Vector2.new(Mouse.X, Mouse.Y + GuiService:GetGuiInset().Y)
    SilentFovCircle.Filled = false
end)

Script.Functions.AutoBlock = LPH_NO_VIRTUALIZE(function()
    pcall(function()
        if library.pointers["AUTOBLOCK"]:Get() then
            local forbidden = {'Combat','[Pencil]','[Knife]','[Bat]','[SledgeHammer]','[Shovel]','[Pitchfork]','[StopSign]}'}
            local Found = false
            for _,v in pairs(game.Workspace.Players:GetChildren()) do
                if Script.Functions.FindCrew(Players[v.Name]) and Players[v.Name].DataFolder.Information:FindFirstChild("Crew").Value == Client.DataFolder.Information:FindFirstChild("Crew").Value then
                    continue
                end
                local position
                if library.pointers["TargetStrafe"]:Active() and library.pointers["Server_sided"]:Get() and Target and Script.Desync["Real_Pos"] then
                    position = Script.Desync["Real_Pos"].Position
                else
                    position = Client.Character.HumanoidRootPart.Position
                end
                if (v.UpperTorso.Position - position).Magnitude <= library.pointers["AUTOBLOCK VALUE"]:Get() then
                    if v.BodyEffects.Attacking.Value == true and Find(forbidden, v:FindFirstChildWhichIsA('Tool').Name) and v.Name ~= Client.Name then
                        Found = true
                        ReplicatedStorage.MainEvent:FireServer('Block', true)
                    end
                end
            end
            if Found == false and Client.Character.BodyEffects:FindFirstChild('Block') and not Uis:IsKeyDown(Enum.KeyCode.F) then
                ReplicatedStorage.MainEvent:FireServer("Block", false)
            end
        end
    end)
end)

local velMax = (128 ^ 2)
Script.Functions.Velocityaa = LPH_NO_VIRTUALIZE(function()
    if library.pointers["Velobool1"]:Get() and library.pointers["Velobool2"]:Active() then
        local SavedVelocity = Client.Character.HumanoidRootPart.Velocity
        local SaveVelocity = Client.Character.HumanoidRootPart.AssemblyLinearVelocity
        local SaveRotVelocity = Client.Character.HumanoidRootPart.AssemblyAngularVelocity
        if library.pointers["VeloType"]:Get() == "Max Velocity" then
            local rootOffset do
                local X = Random(-velMax, velMax);
                local Y = Random(0, velMax);
                local Z = Random(-velMax, velMax);
        
                rootOffset = Vector3.new(X, -Y, Z);
            end;
            Client.Character.HumanoidRootPart.Velocity = rootOffset
        elseif library.pointers["VeloType"]:Get() == "Underground" then
            Client.Character.HumanoidRootPart.Velocity = Vector3.new(Client.Character.HumanoidRootPart.Velocity.X, -800,Client.Character.HumanoidRootPart.Velocity.Z)
        elseif library.pointers["VeloType"]:Get() == "Sky" then
            Client.Character.HumanoidRootPart.Velocity = Vector3.new(Client.Character.HumanoidRootPart.Velocity.X, 800,Client.Character.HumanoidRootPart.Velocity.Z)
        elseif library.pointers["VeloType"]:Get() == "Pred breaker" then
            Client.Character.HumanoidRootPart.Velocity = Client.Character.HumanoidRootPart.Velocity * 2.5
        elseif library.pointers["VeloType"]:Get() == "Zero" then
            Client.Character.HumanoidRootPart.Velocity = Vector3.zero()
        end
        RS.RenderStepped:Wait()
        Client.Character.HumanoidRootPart.Velocity = SavedVelocity
        Client.Character.HumanoidRootPart.AssemblyLinearVelocity = SaveVelocity
        Client.Character.HumanoidRootPart.AssemblyAngularVelocity = SaveRotVelocity
    end
end)

Script.Functions.AntiStomp = function()
    if not Script.Functions.Knocked_Check(Client) and library.pointers["AntiStomp"]:Get() then
        Client.Character.Humanoid:ChangeState("Dead")
    end
end

Script.Functions.Trashtalk = LPH_NO_VIRTUALIZE(function()
    local function sendChatMessage(message)
        ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
    end

    local english_msgs = {
        "$$$ ethh.lol £££", 
        "Without ethh.lol the only thing you carry is an extra chromosome.",
        "uff ya$", 
        "Get rekt by ethh.lol", 
        "get ethh.lol pooron", 
        "ew another brokie without ethh.lol",  
        "Cashing in on your failure with ethh.lol", 
        "No ethh.lol? No chance!", 
        "Imagine being broke, couldn't be me. ethh.lol",
        "Broke and salty? ethh.lol is the cure!", 
        "Guess who’s laughing with ethh.lol? Not you!", 
        "Keep coping while we’re cashing in with ethh.lol",
        "Loser vibes? Not with ethh.lol", 
        "Dodge poverty with ethh.lol",
        "Guide on how to pull girls: 1. buy ethh.lol",
        "Cry harder, ethh.lol loves your tears",
        "Why aim when ethh.lol does it for you?",
        "Got aim? Nah, just got ethh.lol",
        "Outplayed? Nah, just out-cheated with ethh.lol",
        "Can't hit me? Blame ethh.lol",
        "Headshot! Compliments of ethh.lol",
        "ethh.lol invite? In your dreams",
        "Out of invites, out of luck",
        "No invite, no skill, no problem!",
        "Plez give me ethh.lol invite!",
        "Keep trying, ethh.lol already won this",
        "Keep begging, maybe you'll get an invite",
        "Oh, you thought? ethh.lol says nope!"
    }

    local russian_msgs = {
        "ethh.lol - всего X$ и ты лучший!",
        "ethh.lol - гайд по испечению 6 миллинов печенек",
        "ethh.lol пропенка",
        "ну ты чет нубик, мб ethh.lol поможет))",
        "$$$ ethh.lol £££", 
        "эх, давай уже!", 
        "Попал под ethh.lol", 
        "получи ethh.lol бедняжка", 
        "Фу, еще один без ethh.lol",  
        "Зарабатываю на твоем провале с ethh.lol", 
        "Нет ethh.lol? Нет шансов!", 
        "Представь быть бедным... Это не про меня с ethh.lol",
        "Сломался от бедности? ethh.lol - твое лекарство!", 
        "Угадай, кто смеется с ethh.lol? Точно не ты!", 
        "Продолжай оправдываться, пока мы зарабатываем с ethh.lol",
        "Проигрываешь? Не с ethh.lol", 
        "Обходи бедность с ethh.lol",
        "Гайд по привлечению девушек: 1. купи ethh.lol",
        "Плачь сильнее, ethh.lol наслаждается твоими слезами",
        "Зачем целиться, если ethh.lol делает это за тебя?",
        "Есть скилл? Нет, просто есть ethh.lol",
        "Переигран? Нет, просто обманут с ethh.lol",
        "Не можешь попасть? Вини ethh.lol",
        "Хедшот! Комплимент от ethh.lol",
        "ethh.lol приглашение? Только в мечтах",
        "Без приглашения, без удачи",
        "Нет инвайта, нет проблем!",
        "Пожалуйста, дайте мне приглашение на ethh.lol!",
        "Продолжай стараться, ethh.lol уже выиграл это",
        "Продолжай просить, может быть, получишь приглашение",
        "О, ты думал? ethh.lol сказал 'нет'!",
        "Ты еще без ethh.lol? Это провал", 
        "Играть честно? Нет, это не для ethh.lol", 
        "Забудь про скилл, ethh.lol все сделает", 
        "Кто победил? Конечно, тот, у кого есть ethh.lol", 
        "ethh.lol – твой новый уровень", 
        "Слишком медленный? Возьми ethh.lol и догоняй", 
        "Только с ethh.lol ты можешь быть настоящим профи", 
        "Твои проблемы? Решает ethh.lol", 
        "Побеждать легко, когда есть ethh.lol", 
        "Твоя игра – твоя победа с ethh.lol", 
        "ethh.lol – лучший выбор для тех, кто не любит проигрывать", 
        "Играй с умом, играй с ethh.lol", 
        "Хочешь быть на вершине? ethh.lol поможет", 
        "ethh.lol – для тех, кто всегда на шаг впереди", 
        "Забудь про поражения – ethh.lol на страже твоего успеха", 
        "Устал проигрывать? ethh.lol – твой выход", 
        "Сделай ход умнее – выбери ethh.lol", 
        "ethh.lol – ключ к легким победам", 
        "Не знаешь, как победить? Попробуй ethh.lol", 
        "ethh.lol – твой секретный план на успех", 
        "Больше не нужно стараться – ethh.lol все сделает сам", 
        "ethh.lol – твой путь к лидерству", 
        "С ethh.lol не существует проигрышей", 
        "Победа близко, когда у тебя есть ethh.lol", 
        "ethh.lol – для тех, кто не хочет терять время на пустое", 
        "Зачем тренироваться, если есть ethh.lol?"
    }


    if tick() - lastmsgtick >= (Random(300,1000) / 1000) then
        local msg_pool = {}

        if library.pointers["TRASHTALK"]:Get() == "Russian" then
            msg_pool = russian_msgs
        elseif library.pointers["TRASHTALK"]:Get() == "English" then
            msg_pool = english_msgs
        elseif library.pointers["TRASHTALK"]:Get() == "Both" then
            for _, v in ipairs(english_msgs) do Insert(msg_pool, v) end
            for _, v in ipairs(russian_msgs) do Insert(msg_pool, v) end
        end

        local chosen = Random(#msg_pool)

        if chosen ~= oldmsg then
            sendChatMessage(msg_pool[chosen])
            oldmsg = chosen
            lastmsgtick = tick()
        end
    end
end)

Script.Functions.ClientChams = function()
    if library.pointers["PlayerChams"]:Get() then
        for i, v in pairs(Client.Character:GetDescendants()) do

            if (v.Parent:IsA('Tool') and (v:IsA('MeshPart') or v:IsA('BasePart'))) then continue end 
            if v:IsA("Pants") then v:Destroy() end
            if v:IsA("Shirt") then v:Destroy() end
            if v:IsA('MeshPart') then
                v.Material = Enum.Material[library.pointers["PlayerCMaterial"]:Get()]
                v.Color = library.pointers["PlayerChamsColor"]:Get().Color
                v.Transparency = library.pointers["PlayerChamsColor"]:Get().Transparency
                v.TextureID = ''
            end

            if v:IsA('BasePart') then
                v.Material = Enum.Material[library.pointers["PlayerCMaterial"]:Get()]
                v.Color = library.pointers["PlayerChamsColor"]:Get().Color
            end
        end
    end
end

Script.Functions.WeaponChams = function()
    local tool = Client.Character:FindFirstChildWhichIsA("Tool")
    if library.pointers["WeaponChams"]:Get() and tool and tool:FindFirstChild("Ammo") then
        for i, v in pairs(tool:GetChildren()) do
            if v:IsA('MeshPart') then
                v.Material = Enum.Material[library.pointers["WeaponCMaterial"]:Get()]
                v.Color = library.pointers["WeaponCColor"]:Get().Color
                v.TextureID = ''
                v.Transparency = library.pointers["WeaponCColor"]:Get().Transparency
            end

            if v:IsA('BasePart') then
                v.Material = Enum.Material[library.pointers["WeaponCMaterial"]:Get()]
                v.Color = library.pointers["WeaponCColor"]:Get().Color
            end

        end
    end
end

Script.Functions.NewPlayer = LPH_NO_VIRTUALIZE(function(Plr)
    Script.EspPlayers[Plr] = {
        Name = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(255,2550, 255), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}), 
        BoxOutline = Script.Functions.NewDrawing("Square", {Color = Color3.fromRGB(0, 0, 0), Thickness = 3, Visible = false}),
        Box = Script.Functions.NewDrawing("Square", {Color = Color3.fromRGB(255, 255, 255), Thickness = 1, Visible = false}), 
        HealthBarOutline = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 0, 0), Thickness = 3, Visible = false}),
        HealthBar = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 255, 0), Thickness = 1, Visible = false}),
        HealthText = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(0, 255, 0), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        ArmorBarOutline = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 0, 0), Thickness = 3, Visible = false}),
        ArmorBar = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 255, 0), Thickness = 1, Visible = false}),
        ArmorText = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(0, 255, 0), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        Distance = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(255, 255, 255), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        Tool = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(255, 255, 255), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
    }
end)

Script.Functions.UpdateESP = LPH_NO_VIRTUALIZE(function()
    for i, v in pairs(Script.EspPlayers) do
        local character = i.Character
        local isValidCharacter = character and character:FindFirstChild("Humanoid") and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Head")

        if library.pointers["EnableESP"]:Get() and isValidCharacter then
            local Hum = character.Humanoid
            local Hrp = character.HumanoidRootPart

            local Vector, OnScreen = Camera:WorldToViewportPoint(Hrp.Position)

            if OnScreen then
                local Size = (Camera:WorldToViewportPoint(Hrp.Position - Vector3.new(0, 3, 0)).Y - Camera:WorldToViewportPoint(Hrp.Position + Vector3.new(0, 2.6, 0)).Y) / 2
                local BoxSize = Vector2.new(Floor(Size * 1.5), Floor(Size * 1.9))
                local BoxPos = Vector2.new(Floor(Vector.X - Size * 1.5 / 2), Floor(Vector.Y - Size * 1.6 / 2))
                local BottomOffset = BoxSize.Y + BoxPos.Y + 1

                v.Name.Visible = library.pointers["Name"]:Get()
                if v.Name.Visible then
                    v.Name.Position = Vector2.new(BoxSize.X / 2 + BoxPos.X, BoxPos.Y - 16)
                    v.Name.Text = Hum.DisplayName
                    v.Name.Color = library.pointers["NameColor"]:Get().Color
                end

                v.Distance.Visible = library.pointers["Distance"]:Get()
                if v.Distance.Visible then
                    v.Distance.Position = Vector2.new(BoxSize.X / 2 + BoxPos.X, BottomOffset)
                    v.Distance.Text = Floor((Hrp.Position - Client.Character.HumanoidRootPart.Position).Magnitude) .. "m"
                    v.Distance.Color = library.pointers["DistanceColor"]:Get().Color
                end

                local tool = character:FindFirstChildWhichIsA("Tool")
                v.Tool.Visible = library.pointers["Tool"]:Get() and tool
                if v.Tool.Visible then
                    v.Tool.Position = Vector2.new(BoxSize.X / 2 + BoxPos.X, library.pointers["Distance"]:Get() and BottomOffset + 13 or BottomOffset)
                    v.Tool.Text = tool.Name
                    v.Tool.Color = library.pointers["ToolColor"]:Get().Color
                end

                local boxEnabled = library.pointers["BOX"]:Get()
                v.BoxOutline.Visible = boxEnabled
                v.Box.Visible = boxEnabled
                if boxEnabled then
                    v.BoxOutline.Size = BoxSize
                    v.Box.Size = BoxSize
                    v.BoxOutline.Position = BoxPos
                    v.Box.Position = BoxPos
                    v.Box.Color = library.pointers["BoxColor"]:Get().Color
                    v.BoxOutline.Color = Color3.fromRGB(0, 0, 0)
                end

                local healthEnabled = library.pointers["Health"]:Get()
                v.HealthBar.Visible = healthEnabled
                v.HealthText.Visible = healthEnabled
                v.HealthBarOutline.Visible = healthEnabled
                if healthEnabled then
                    local healthPercentage = Hum.Health / Hum.MaxHealth
                    local Offset = library.pointers["Armor"]:Get() and 22 or 15
                    v.HealthText.Position = Vector2.new((BoxPos.X - Offset), BoxPos.Y - 1)
                    v.HealthText.Text = tostring(Floor(healthPercentage * 100 + 0.5))
                    v.HealthText.Color = library.pointers["HealthColor"]:Get().Color
                    
                    v.HealthBar.From = Vector2.new((BoxPos.X - 5), BoxPos.Y + BoxSize.Y)
                    v.HealthBar.To = Vector2.new(v.HealthBar.From.X, v.HealthBar.From.Y - healthPercentage * BoxSize.Y)
                    v.HealthBar.Color = Color3.fromRGB(255 - Floor(255 * healthPercentage), Floor(255 * healthPercentage), 0)
                    
                    v.HealthBarOutline.From = Vector2.new(v.HealthBar.From.X, BoxPos.Y + BoxSize.Y + 1)
                    v.HealthBarOutline.To = Vector2.new(v.HealthBar.From.X, (v.HealthBar.From.Y - BoxSize.Y) - 1)
                    v.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
                end

                local bodyEffects = character:FindFirstChild("BodyEffects")
                local armorEnabled = library.pointers["Armor"]:Get() and bodyEffects and bodyEffects:FindFirstChild("Armor")
                v.ArmorBar.Visible = armorEnabled
                v.ArmorText.Visible = armorEnabled
                if armorEnabled then
                    local armorValue = bodyEffects.Armor.Value
                    local armorPercentage = armorValue / 200
                    v.ArmorBar.From = Vector2.new((BoxPos.X - (healthEnabled and 9 or 5)), BoxPos.Y + BoxSize.Y)
                    v.ArmorBar.To = Vector2.new(v.ArmorBar.From.X, v.ArmorBar.From.Y - armorPercentage * BoxSize.Y)
                    v.ArmorBar.Color = library.pointers["ArmorColor"]:Get().Color
                    
                    v.ArmorBarOutline.From = Vector2.new(v.ArmorBar.From.X, BoxPos.Y + BoxSize.Y + 1)
                    v.ArmorBarOutline.To = Vector2.new(v.ArmorBar.From.X, (v.ArmorBar.From.Y - BoxSize.Y) - 1)
                    v.ArmorBarOutline.Visible = true
                    
                    v.ArmorText.Text = tostring(Floor(armorValue / 2 + 0.5))
                    v.ArmorText.Position = Vector2.new((BoxPos.X - 22), (BoxPos.Y + BoxSize.Y - BoxSize.Y) + 11)
                    v.ArmorText.Color = library.pointers["ArmorColor"]:Get().Color
                else
                    v.ArmorBarOutline.Visible = false
                end

            else
                for _, drawing in pairs(v) do
                    drawing.Visible = false
                end
            end
        else
            for _, drawing in pairs(v) do
                drawing.Visible = false
            end
        end
    end
end)

Script.Functions.HitSound = LPH_NO_VIRTUALIZE(function()
    local sounds = {
        ["Rust"] = "5043539486",
        ["GameSense"] = "4817809188", 
        ["Neverlose"] = "8679627751",
        ["Bow"] = "3442683707", 
        ["Minecraft"] = "4018616850",
        ["Fatality"] = "115982072912004"
    }
    local Sound = Instance.new("Sound", cloneref(game:GetService("SoundService"))); local PitchSound = Instance.new("PitchShiftSoundEffect", Sound)
    Sound.SoundId = "rbxassetid://".. sounds[library.pointers["Chosen sound"]:Get()] ..""
    Sound.Volume = 3
    PitchSound.Octave = 1
    Sound.PlayOnRemove = true
    Sound:Destroy()
end)

Script.Functions.UpdateAimbotVisual = LPH_NO_VIRTUALIZE(function()
    if Target and Target.Parent and Target.Character ~= nil and Client and Client.Parent then
        local Position, OnScreen = Camera:WorldToViewportPoint(Target.Character:WaitForChild("HumanoidRootPart").Position)
        local Position2, OnScreen2 = Camera:WorldToViewportPoint(Client.Character:WaitForChild("HumanoidRootPart").Position)
        if library.pointers["HighlightTarget"]:Get() then
            targetHighlight.Enabled = true 
            targetHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            targetHighlight.FillColor = library.pointers["Highlight Color"]:Get().Color
            targetHighlight.OutlineColor = library.pointers["Highlight Color"]:Get().Color
            targetHighlight.Adornee = Target.Character
            targetHighlight.OutlineTransparency = library.pointers["Highlight Color"]:Get().Transparency
            targetHighlight.FillTransparency = library.pointers["Highlight Color"]:Get().Transparency
        else 
            targetHighlight.Enabled = false 
        end
        if OnScreen then
            if library.pointers["LineToggle"]:Get() then
                AimbotLine.Visible = true 
                if library.pointers["Line Pos"]:Get() == "Mouse" then
                    AimbotLine.From = Vector2.new(Mouse.X,Mouse.Y + GuiService:GetGuiInset().Y)
                elseif library.pointers["Line Pos"]:Get() == "Body" then
                    AimbotLine.From = Vector2.new(Position2.X,Position2.Y)
                end
                AimbotLine.To = Vector2.new(Position.X, Position.Y)
                AimbotLine.Color = library.pointers["Line Color"]:Get().Color
                AimbotLine.Transparency = library.pointers["Line Color"]:Get().Transparency
            else
                AimbotLine.Visible = false
            end
        else
            AimbotLine.Visible = false
        end
    else 
        AimbotLine.Visible = false
        targetHighlight.Enabled = false 
    end
end)

local Games = loadstring(game:HttpGet("https://raw.githubusercontent.com/kexrna/ethh/refs/heads/main/GDATA.lua"))()


if not hookmetamethod and Games[game.PlaceId] and Games[game.PlaceId].Version and Games[game.PlaceId].Version ~= game.PlaceVersion then
    local bindable = Instance.new("BindableFunction")
    function bindable.OnInvoke(response)
        if response == "Yes" then
            return
        else
            Client:Kick("you chose to not continue")
        end
    end
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Alert",
        Text = "The game has updated but not the remote that is known, if you press yes than we will use the known one but you might get banned",
        Callback = bindable ,
        Duration = 999999,
        Button1 = "Yes",
        Button2 = "No"
    })
end

Script.Functions.FireEndpoint = LPH_NO_VIRTUALIZE(function()
    if EndPoint ~= nil then
        if Games[game.PlaceId] then
            local gameInfo = Games[game.PlaceId]
            local Arg = gameInfo.Argument
            ReplicatedStorage[gameInfo.Remote]:FireServer(Arg, EndPoint)
            return
        else
            ReplicatedStorage.MainEvent:FireServer("UpdateMousePos", EndPoint)
            return
        end
    end
end)

Script.Functions.CalculateEndpoint = LPH_NO_VIRTUALIZE(function(DeltaTime)
    local Prediction
    local TargetCF = Target.Character[library.pointers["HitPart"]:Get()].Position
    local TargetVel = Target.Character[library.pointers["HitPart"]:Get()].Velocity
    if not library.pointers["AutoPred"]:Get() then
        Prediction = library.pointers["Prediction"]:Get()
    else
        --Prediction = Script.Functions.GetPred()
        local pingvalue = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
        local split = Split(pingvalue,'(')
        local ping = tonumber(split[1])/500
        if not hookmetamethod and Prediction then
            Prediction = Prediction * 1.15
        end
        Prediction = Vector3.new(ping, ping/2.5, ping)

    end

    if library.pointers["Backtrack"]:Get() and Script.Variables.Backtrackedpos then
        TargetCF = Script.Variables.Backtrackedpos.Position
    end

    if library.pointers["Resolver"]:Get() then
        TargetVel = Resolver:GetResolverData(Target).Velocity
        if not Resolver:isValidPosition(Target) then
            local TargetCF = Resolver:GetResolverData(Target).lastValidCFrame.Position
        end
        local predictedcframe = TargetCF + TargetVel * (DeltaTime * 15)
        TargetCF = TargetCF:Lerp(predictedcframe, DeltaTime)
    end
    
    if not Prediction then
        Prediction = Script.Functions.GetPred()
        if not hookmetamethod and Prediction then
            Prediction = Prediction * 1.15
        end
    end

    local moveDirection = Target.Character.Humanoid.MoveDirection
    local angularChange = Abs(moveDirection:Dot(TargetVel.unit))
    if library.pointers["Agnlescheck"]:Get() and angularChange < 0.5 then
        Prediction = Prediction * angularChange
    end    

    if not library.pointers['Predictionbool']:Get() then
        Prediction = 0
    end
    if library.pointers["NoGRound"]:Get() and TargetVel.Y < -15 then
        TargetVel = Vector3.new(TargetVel.X, TargetVel.Y * 0.7, TargetVel.Z)
    end
    if TargetCF and TargetVel and Prediction then
        local newedp = TargetCF + (TargetVel * Prediction)
        if library.pointers["Resolver"]:Get() then
            if newedp.Y > 1e5 or newedp.Y < -1e3 then
                return
            else
                EndPoint = newedp
            end
        else
            EndPoint = newedp
        end
    end
end)

Script.Functions.fly = LPH_NO_VIRTUALIZE(function(delta) 
    if library.pointers["Fly1"]:Get() and library.pointers["Fly2"]:Active() then 
        Client.Character.HumanoidRootPart.Velocity = Vector3.zero; 
        local x = 0 
        local y = 0 
        local z = 0 
        -- 
        if not GetFocusedTextBox() then 
            if Uis:IsKeyDown(Enum.KeyCode.W) then
                z -= 1
            end
            -- 
            if Uis:IsKeyDown(Enum.KeyCode.S) then
                z += 1
            end
            -- 
            if Uis:IsKeyDown(Enum.KeyCode.D) then
                x += 1
            end
            -- 
            if Uis:IsKeyDown(Enum.KeyCode.A) then
                x -= 1
            end
            -- 
            if Uis:IsKeyDown(Enum.KeyCode.Space) then
                y += 1
            end
            -- 
            if Uis:IsKeyDown(Enum.KeyCode.LeftControl) then
                y -= 1
            end
        end 
        -- 
        local direction = utility:safeUnit(Camera.CFrame:VectorToWorldSpace(Vector3.new(x, 0, z)).Unit)
        Client.Character.HumanoidRootPart.CFrame += (direction + Vector3.new(0, y, 0)) * (library.pointers["Fly Speed"]:Get() / 10) * (delta * 60)
    end 
end )

Script.Functions.CreateClone = LPH_NO_VIRTUALIZE(function(Player)
    local Character = Players[Player.Name].Character
    Character.Archivable  = true
  
    local Clone = Character:Clone()
    Clone.Parent = HitChams
    Clone.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None

    for _, v in pairs(Clone:GetDescendants()) do
        if (v:IsA('BasePart')) then
            v.Material = Enum.Material.ForceField
            v.Color = library.pointers["Effect color"]:Get().Color
            v.CanCollide = false
            v.Anchored = true
            v.CanQuery = false
            v.CanTouch = false
        end

        if (v:IsA('Accessory') or v:IsA('Tool')) then
            v:Destroy()
        end
    end

    for i,v in pairs(Character:GetDescendants()) do
        if (v:IsA('BasePart')) then
            local ClonePart = Clone:FindFirstChild(v.Name)

            if (ClonePart) then
                ClonePart.CFrame = v.CFrame
            end
        end
    end

    Clone:PivotTo(Character.PrimaryPart.CFrame + Vector3.new(Client.Character.HumanoidRootPart.CFrame.lookVector.x * 1.5, 0, Client.Character.HumanoidRootPart.CFrame.lookVector.z * 1.5))

    CharacterArchivable = false
    delay(library.pointers["Life time"]:Get(), function()
        Clone:Destroy()
    end)
end)

local hitmodule = game:GetObjects("rbxassetid://7255773215")[1]
if hitmodule then
    hitmodule.Parent = ReplicatedStorage
end
Script.Functions.CreateConfetti = LPH_NO_VIRTUALIZE(function(Plr)
    local Character = Players[Plr.Name].Character
    Spawn(function()
        local Confetti_Amount = 20000
        local RootPart = Character.HumanoidRootPart
        local ConfettiClone = hitmodule:Clone()
        ConfettiClone.RainbowParticles.Rate = Confetti_Amount
        ConfettiClone.Parent = workspace
        ConfettiClone.CanCollide = false
        ConfettiClone.CFrame = RootPart.CFrame
        -- 
        for i = Confetti_Amount, 0 , -(Confetti_Amount/50) do 
            Wait()
            ConfettiClone.RainbowParticles.Rate = i
        end 
        -- 
        delay(5, function()
            ConfettiClone:Destroy()
        end)
    end)
end)

Script.Functions.Pulse = LPH_NO_VIRTUALIZE(function(Plr)
    local Character = Players[Plr.Name].Character
    local RootPart = Character.HumanoidRootPart
    local Attachment = Instance.new('Attachment', RootPart)
    local Particle1  = Instance.new('ParticleEmitter', Attachment)
    local Particle2  = Instance.new('ParticleEmitter', Attachment)
    Particle1.Name = 'Particle1'
    Particle1.LightEmission = 3
    Particle1.Transparency = NumberSequence.new(0)
    Particle1.Color = ColorSequence.new(library.pointers["Effect color"]:Get().Color)
    Particle1.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 6, 1.2)}
    Particle1.Rotation = NumberRange.new(0)
    Particle1.RotSpeed = NumberRange.new(0)
    Particle1.Enabled = false
    Particle1.Rate = 2
    Particle1.Lifetime = NumberRange.new(0.25)
    Particle1.Speed = NumberRange.new(0.1)
    Particle1.Squash = NumberSequence.new(0)
    Particle1.ZOffset = 1
    Particle1.Texture = 'rbxassetid://2916153928'
    Particle1.Orientation = 'VelocityPerpendicular'
    Particle1.Shape = 'Box'
    Particle1.ShapeInOut = 'Outward'
    Particle1.ShapeStyle = 'Volume'
    Particle2.Name = 'Particle1'
    Particle2.LightEmission = 3
    Particle2.Transparency  = NumberSequence.new(0)
    Particle2.Color = ColorSequence.new(library.pointers["Effect color"]:Get().Color)
    Particle2.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 6, 1.2)}
    Particle2.Rotation = NumberRange.new(0)
    Particle2.RotSpeed = NumberRange.new(0)
    Particle2.Enabled = false
    Particle2.Rate = 2
    Particle2.Lifetime = NumberRange.new(0.25)
    Particle2.Speed = NumberRange.new(0.1)
    Particle2.Squash = NumberSequence.new(0)
    Particle2.ZOffset = 1
    Particle2.Texture = 'rbxassetid://2916153928'
    Particle2.Orientation  = 'FacingCamera'
    Particle2.Shape = 'Box'
    Particle2.ShapeInOut = 'Outward'
    Particle2.ShapeStyle = 'Volume'

    Particle1:Emit(1);
    Particle2:Emit(1);

    delay(1, function()
        Attachment:Destroy()
    end)
end)

Script.Functions.CreateBeam = LPH_NO_VIRTUALIZE(function(Origin, End)
    local BeamPart = Instance.new("Part", Workspace)
    BeamPart.Name = "BeamPart"
    BeamPart.Transparency = 1
    --
    local Part = Instance.new("Part", BeamPart)
    Part.Size = Vector3.new(1, 1, 1)
    Part.Transparency = 1
    Part.CanCollide = false
    Part.CFrame = typeof(Origin) == "CFrame" and Origin or CFrame.new(Origin)
    Part.Anchored = true
    local Attachment = Instance.new("Attachment", Part)
    local Part2 = Instance.new("Part", BeamPart)
    Part2.Size = Vector3.new(1, 1, 1)
    Part2.Transparency = 1
    Part2.CanCollide = false
    Part2.CFrame = typeof(End) == "CFrame" and End or CFrame.new(End)
    Part2.Anchored = true
    Part2.Color = Color3.fromRGB(255, 255, 255)
    local Attachment2 = Instance.new("Attachment", Part2)
    local Beam = Instance.new("Beam", Part)
    Beam.FaceCamera = true
    Beam.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, library.pointers["BulletTracer Color"]:Get().Color),
        ColorSequenceKeypoint.new(1, library.pointers["BulletTracer Color"]:Get().Color),
    }
    Beam.Attachment0 = Attachment
    Beam.Attachment1 = Attachment2
    Beam.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 0),
    }
    Beam.LightEmission = 6
    Beam.LightInfluence = 1
    Beam.Width0 = 1
    Beam.Width1 = 1
    Beam.Texture = "rbxassetid://7151778302"
    Beam.LightEmission = 1
    Beam.LightInfluence = 1
    Beam.TextureMode = Enum.TextureMode.Wrap 
    Beam.TextureLength = 3 
    Beam.TextureSpeed = 3
    Spawn(function()
        local tracerLifeTime = library.pointers["Tracers Life Time"]:Get() / 10
        for i = 0, 10 do 
            Wait(tracerLifeTime)
            local transparencyValue = i / 10
            Beam.Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, transparencyValue),
                NumberSequenceKeypoint.new(1, transparencyValue),
            }
        end
        Part:Destroy()
        Part2:Destroy()
        BeamPart:Destroy()
    end)
end)

local RandomNumberRange = LPH_NO_VIRTUALIZE(function(a)
	return Random(-a * 100, a * 100) / 100
end)

Resolver.MAX_TELEPORT_DISTANCE = 10000
Resolver.VALID_X_RANGE = {min = -2800, max = 2048}
Resolver.VALID_Y_RANGE = {min = -250, max = 2000}
Resolver.VALID_Z_RANGE = {min = -2200, max = 1700}

Resolver.ResolverData = {}

function Resolver:isInRange(value, range)
    return value >= range.min and value <= range.max
end

function Resolver:isValidPosition(Plr)
    local humanoid = Plr.Character:FindFirstChildOfClass("Humanoid")
    local currentCFrame = Plr.Character.HumanoidRootPart.CFrame
    local position = currentCFrame.Position
    --local workspacepos = Workspace.Players[Plr.Name].HumanoidRootPart.CFrame.Position

    if position.Y > 1e5 or position.Y < -1e3 then
        return false
    end

    --[[if self.ResolverData[Plr] and self.ResolverData[Plr].lastValidCFrame then
        local distance = (position - self.ResolverData[Plr].lastValidCFrame.Position).Magnitude

        if (workspacepos - self.ResolverData[Plr].lastValidCFrame.Position).Magnitude > 50 then
        end

        local maxDistance = (self.ResolverData[Plr].LastTp and self.ResolverData[Plr].LastTp.Magnitude) or self.MAX_TELEPORT_DISTANCE
        if distance > maxDistance then
            self.ResolverData[Plr].LastTp = position
            return false
        end
    end]]

    self.ResolverData[Plr].LastTp = nil
    self.ResolverData[Plr].lastValidCFrame = currentCFrame
    return true
end


function Resolver:ResolveVoidTp()
    if self:isValidPosition(Target) then
        Script.Variables.Window.statuslist:Remove("Resolving Void TP")
    else
        Script.Variables.Window.statuslist:Add("Resolving Void TP")
    end
end

function Resolver:GetVelocity(Plr, DeltaTime)
    local currentPosition, currentTime = Plr.Character.HumanoidRootPart.Position, tick()
    
    if not self.ResolverData[Plr] then
        self.ResolverData[Plr] = {
            OldPosition = currentPosition,
            LastUpdateTime = currentTime,
            Velocity = Vector3.new(0, 0, 0),
            Calculated = false,
            Positions = {},
            BackTrackedPos = nil,
            lastValidCFrame = nil
        }
    end
    
    if self.ResolverData[Plr].Calculated then
        return self.ResolverData[Plr].Velocity
    else
        self.ResolverData[Plr].Calculated = true
    end
    
    local velocity
    if DeltaTime ~= nil then
        velocity = (currentPosition - self.ResolverData[Plr].OldPosition) / DeltaTime
    else
        velocity = (currentPosition - self.ResolverData[Plr].OldPosition) / (currentTime - self.ResolverData[Plr].LastUpdateTime)
    end
    
    self.ResolverData[Plr].OldPosition = currentPosition
    self.ResolverData[Plr].LastUpdateTime = currentTime
    self.ResolverData[Plr].Velocity = velocity
    self.ResolverData[Plr].Calculated = false
    
    return velocity
end

function Resolver:RecordPlayerPosition(Plr)
    local currentPosition, currentTime = Plr.Character.HumanoidRootPart.CFrame, tick()

    Resolver:GetResolverData(Plr)
    
    Insert(self.ResolverData[Plr].Positions, {Position = currentPosition, Time = currentTime})
end

function Resolver:GetBacktrackPosition(Plr)
    local currentTime = tick()
    local playerData = self.ResolverData[Plr]
    
    if not playerData or not playerData.Positions then
        return Plr.Character.HumanoidRootPart.CFrame
    end
    
    local delay = 100
    local boostValue = library.pointers["Backtrack boost"]:Get()
    
    if boostValue == "Lowest" then
        delay = delay * 0.5
    elseif boostValue == "Normal" then
        delay = delay * 1
    elseif boostValue == "High" then
        delay = delay * 5
    elseif boostValue == "Maximum" then
        delay = delay * 8
    end
    
    for i = #playerData.Positions, 1, -1 do
        local record = playerData.Positions[i]
        if currentTime - record.Time >= (delay / 1000) then
            playerData.BackTrackedPos = record
            return record.Position
        end
    end
    
    return Plr.Character.HumanoidRootPart.CFrame
end


function Resolver:GetResolverData(Plr)
    if not self.ResolverData[Plr] then
        self.ResolverData[Plr] = {
            OldPosition = Vector3.new(0, 0, 0),
            LastUpdateTime = 0,
            Velocity = Vector3.new(0, 0, 0),
            Calculated = false,
            Positions = {},
            BackTrackedPos = nil,
            lastValidCFrame = CFrame.new()
        }
    end
    return self.ResolverData[Plr]
end

function Resolver:ResetPlayerData(Plr)
    self.ResolverData[Plr] = {
        OldPosition = Vector3.new(0, 0, 0),
        LastUpdateTime = 0,
        Velocity = Vector3.new(0, 0, 0),
        Calculated = false,
        Positions = {},
        BackTrackedPos = nil,
        lastValidCFrame = CFrame.new()
    }
end

Resolver.backtrackedModels = {}
Resolver.currentBacktrackedPlayer = nil

function Resolver:BacktrackPlayer(player, backtrackedPos)
    if not player or not player.Character or not backtrackedPos then
        return
    end
    if self.currentBacktrackedPlayer and self.currentBacktrackedPlayer ~= player then
        self:CleanupBacktrack(self.currentBacktrackedPlayer)
    end
    self.currentBacktrackedPlayer = player

    local model = self.backtrackedModels[player]
    if not model then
        player.Character.Archivable = true
        model = player.Character:Clone()
        model.Name = "Backtrack_" .. player.Name

        for _, v in ipairs(model:GetChildren()) do
            if v:IsA("BasePart") then
                v.CanCollide = false
                v.Anchored = true
                v.Material = Enum.Material.SmoothPlastic
                v.BrickColor = BrickColor.new(library.pointers["BackTrack Color"]:Get().Color)
                v.Transparency = 0.5
            elseif v.Name ~= "HumanoidRootPart" then
                v:Destroy()
            end
        end

        if model:FindFirstChild("Head") and model.Head:FindFirstChild("face") then
            model.Head.face:Destroy()
        end

        if not model.PrimaryPart then
            local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                model.PrimaryPart = humanoidRootPart
            else
                model:Destroy()
                return
            end
        end

        model.Parent = workspace
        self.backtrackedModels[player] = model
    end

    model:SetPrimaryPartCFrame(backtrackedPos)
end

function Resolver:CleanupBacktrack(player)
    local model = self.backtrackedModels[player]
    if model then
        model:Destroy()
        self.backtrackedModels[player] = nil
    end
    if self.currentBacktrackedPlayer == player then
        self.currentBacktrackedPlayer = nil
    end
end

function Resolver:ClearAllBacktracks()
    for player, model in pairs(self.backtrackedModels) do
        model:Destroy()
    end
    self.backtrackedModels = {}
    self.currentBacktrackedPlayer = nil
end

Script.Functions.Desync = LPH_NO_VIRTUALIZE(function()
    if sethiddenproperty and Client and Client.Parent then
        if library.pointers["DesyncBool"]:Get() and library.pointers["DesyncBool2"].Active() then
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", true)
            Wait(library.pointers["Desync tick"]:Get())
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
        end

        if library.pointers["NetworkDesync"].Active() then
            if library.pointers["Network Mode"]:Get() == "Lag on Stepped" then
                sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", true)
                RS.PostSimulation:Wait()
                sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
            elseif library.pointers["Network Mode"]:Get() == "Classic" then
                sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", true)
                Wait(library.pointers["network tick"]:Get())
                sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
            end
        end
    end
end)

local stat = false
Script.Functions.Async = LPH_NO_VIRTUALIZE(function()
    if library.pointers["Asyncbool"]:Get() and library.pointers["Asyncbool2"]:Active() then
        local hrp = Client.Character.HumanoidRootPart
        local Old = hrp.Anchored
        if (library.pointers["IsCframeActive"]:Active() and not library.pointers["CFRAMESPEED"]:Get()) or (not library.pointers["IsCframeActive"]:Active()) then
            hrp.CFrame = hrp.CFrame + Client.Character.Humanoid.MoveDirection * 0.029
        end
        hrp.Anchored = stat
        RS.RenderStepped:Wait()
        hrp.Anchored = Old    
    end
end)

Script.Functions.AutoArmor = LPH_NO_VIRTUALIZE(function()
    if library.pointers["Auto Armor"]:Get() then
        local success, err = pcall(function()

            if Priority.Current > Priority.AutoArmor then
                return
            end

            if not Script.Variables.armor then
                Script.Variables.armor = ToolName("High-Medium Armor")
            end

            repeat Wait() until Client.Character and Client.Character:FindFirstChild("BodyEffects")
            
            local Armor = Client.Character.BodyEffects.Armor
            
            if Armor.Value <= library.pointers["Auto Armor Threshold"]:Get() and Script.Variables.armor then
                Priority.Current = Priority.AutoArmor

                if not Script.Variables.oldTarget then
                    Script.Variables.oldTarget = Target
                end
                if not Script.Variables.oldpos then
                    Script.Variables.oldpos = Client.Character.HumanoidRootPart.CFrame
                end
                stopblyat()
                Resolver:CleanupBacktrack(Target)
                Target = nil
                local item
                if Client.Character:FindFirstChildWhichIsA("Tool") then
                    item = Client.Character:FindFirstChildWhichIsA("Tool")
                end
                local Is_On_FFlags = Script.Functions.Fflags_Manager()
                
                while Wait(0.1) do
                    if Client.Character.BodyEffects.Armor.Value >= library.pointers["Auto Armor Threshold"]:Get() then 
                        break 
                    end

                    Client.Character.HumanoidRootPart.CFrame = Script.Variables.armor.Head.CFrame + Vector3.new(0, -5, 0)
                    if item then
                        Client.Character.Humanoid:UnequipTools()
                    end
                    fireclickdetector(Script.Variables.armor.ClickDetector)
                    
                end

                Wait()
                Script.Functions.Fflags_Manager(Is_On_FFlags)
                Client.Character.HumanoidRootPart.CFrame =  Script.Variables.oldpos
                Target = Script.Variables.oldTarget
                Script.Variables.oldTarget = nil
                Script.Variables.oldpos = nil
                Priority.Current = 0
                Client.Character.Humanoid:EquipTool(item)

            end
        end)
    end
end)

Script.Functions.AutoFireArmor = LPH_NO_VIRTUALIZE(function()
    if library.pointers["Auto Fire Armor"]:Get() then
        local success, err = pcall(function()
            if Priority.Current > Priority.FireArmor then
                return
            end
        
            if not Script.Variables.Firearmor then
                Script.Variables.Firearmor = ToolName("Fire Armor")
            end
            repeat Wait() until Client.Character and Client.Character:FindFirstChild("BodyEffects")
            local Armor = Client.Character.BodyEffects.FireArmor
            if Armor.Value <= library.pointers["Auto Fire Armor Threshold"]:Get() and Script.Variables.Firearmor then
                Priority.Current = Priority.FireArmor
                if not Script.Variables.oldTarget then
                    Script.Variables.oldTarget = Target
                end
                
                if not Script.Variables.oldpos then
                    Script.Variables.oldpos = Client.Character.HumanoidRootPart.CFrame
                end
                Resolver:CleanupBacktrack(Target)
                Target = nil
                stopblyat()
                local item
                if Client.Character:FindFirstChildWhichIsA("Tool") then
                    item = Client.Character:FindFirstChildWhichIsA("Tool")
                end
                local oldpos = Client.Character.HumanoidRootPart.CFrame
                local Is_On_FFlags = Script.Functions.Fflags_Manager()
                while Wait(0.1) do
                    if Client.Character.BodyEffects.FireArmor.Value >= library.pointers["Auto Fire Armor Threshold"]:Get() then 
                        break 
                    end

                    Client.Character.HumanoidRootPart.CFrame = Script.Variables.Firearmor.Head.CFrame + Vector3.new(0, -5, 0)
                    if item then
                        Client.Character.Humanoid:UnequipTools()
                    end
                    fireclickdetector(Script.Variables.Firearmor.ClickDetector)
                end

                Wait()
                Script.Functions.Fflags_Manager(Is_On_FFlags)

                Client.Character.HumanoidRootPart.CFrame = Script.Variables.oldpos
                Target = Script.Variables.oldTarget
                Script.Variables.oldTarget = nil
                Script.Variables.oldpos = nil
                Priority.Current = 0
                Client.Character.Humanoid:EquipTool(item)

            end
        end)
    end
end)

Script.Functions.AntiMoveDirection = LPH_NO_VIRTUALIZE(function()
    if library.pointers["AntiMoveDirection"]:Get() and library.pointers["Velobool2"]:Active() then
        local oldws = Client.Character.Humanoid.WalkSpeed
        Client.Character.Humanoid.WalkSpeed = Random(-50,70)
        RS.PreRender:Wait()
        Client.Character.Humanoid.WalkSpeed = oldws
    end
end)
Script.Desync["calculatedPositions"] = {
    ["Void"] = CFrame.new(0, -2147483648, 0),
}
Script.Functions.CalculateServerSide = LPH_NO_VIRTUALIZE(function()
    local Origin = Client.Character.HumanoidRootPart
    Script.Desync["calculatedPositions"] = {
        ["Roll"] = Origin.CFrame * CFrame.new(Random(-3, 5), Random(-3, 5) ,Random(-3, 5)) * CFrame.Angles(Rad(Random(1, 360)), Rad(Random(1, 360)), Rad(-180)),
        ["Random"] = Origin.CFrame * CFrame.new(Random(-library.pointers["Random X"]:Get(),library.pointers["Random X"]:Get()), Random(-library.pointers["Random Y"]:Get(),library.pointers["Random Y"]:Get()),Random(-library.pointers["Random Z"]:Get(),library.pointers["Random Z"]:Get()))
    }
end)
Script.Functions.Rolls = LPH_NO_VIRTUALIZE(function()
    if library.pointers["Rollss"]:Get() and not (Target ~= nil and library.pointers["Server_sided"]:Get() and library.pointers["TargetStrafe"]:Active()) then
        Script.Desync["Old_CFrame"] = Client.Character.HumanoidRootPart.CFrame
        Client.Character.HumanoidRootPart.CFrame = Script.Desync["calculatedPositions"]["Roll"]
        Script.Desync["Real_Pos"] = Client.Character.HumanoidRootPart.CFrame
        RS.PreRender:Wait()
        Client.Character.HumanoidRootPart.CFrame =  Script.Desync["Old_CFrame"]
    end
end)

Script.Functions.RandomTP = LPH_NO_VIRTUALIZE(function()
    --if library.pointers["TargetStrafe"]:Active() and Target and not (library.pointers["autostomp"]:Get() and Target.Character:FindFirstChild("BodyEffects") and not Script.Functions.Knocked_Check(Target) and not Script.Functions.Death_Check(Target)) then
    --    return
    --end
    if library.pointers["RandomTP"]:Get() and library.pointers["RandomTP2"]:Active() then
        if Priority.Current > Priority.CFDesync then
            return
        end
        Priority.Current = Priority.CFDesync
        Script.Desync["Old_CFrame"] = Client.Character.HumanoidRootPart.CFrame
        Client.Character.HumanoidRootPart.CFrame = Script.Desync["calculatedPositions"]["Random"]
        Script.Desync["Real_Pos"] = Client.Character.HumanoidRootPart.CFrame
        RS.PreRender:Wait()
        Client.Character.HumanoidRootPart.CFrame = Script.Desync["Old_CFrame"]
        Priority.Current = 0
    end
end)

Script.Functions.DestroyCheater = LPH_NO_VIRTUALIZE(function()
    local Character = Client and Client.Character
    if Character then
        local RootPart = Character and Character:FindFirstChild('HumanoidRootPart')
        local Position = RootPart and RootPart.CFrame
        Spawn(function()
            while Wait(0.5) do
                if not library.pointers["Destroy Cheaters1"]:Get() or not library.pointers["Destroy Cheaters2"]:Active() then
                    break
                end
                Script.Desync.cframe = (RootPart.CFrame * CFrame.new(9e9, 0/0, 9e9))
                Wait(0.5)
                Script.Desync.cframe = Position
                Position = RootPart.CFrame
                Wait()
                Script.Desync.cframe = nil
            end
        end)

        local Con = Script.Connections.DC
        if Script.Connections.DC then
            Con:Disconnect()
            Script.Connections.DC = nil
        end

        Script.Connections.DC = RS.PostSimulation:Connect(function()
            if Priority.Current > Priority.CFDesync then
                if Script.Desync.ClientLocation then
                    Client.Character:FindFirstChild("HumanoidRootPart").CFrame = Script.Desync.ClientLocation
                    Script.Desync.ClientLocation = nil
                end
                return
            end
        
            Priority.Current = Priority.CFDesync

            local LocalCharacter = Client.Character
            local LocalRootPart = Client and LocalCharacter:FindFirstChild("HumanoidRootPart")
    
            if not LocalRootPart then return end
    
            Script.Desync.ClientLocation = LocalRootPart.CFrame

            if (Script.Desync.cframe) then 
                LocalRootPart.CFrame = Script.Desync.cframe
            end
    
            RS.PreRender:Wait()
            LocalRootPart.CFrame = Script.Desync.ClientLocation
            Script.Desync.ClientLocation = nil
            Priority.Current = 0
        end)
    end
end)

Script.Functions.VoidDesync = LPH_NO_VIRTUALIZE(function()
    local Con = Script.Connections.VC
    if Script.Connections.VC then
        Con:Disconnect()
        Script.Connections.VC = nil
    end
    if library.pointers["Void 1"]:Get() and library.pointers["Void 2"]:Active() then
        local Character = Client and Client.Character
        if Character then
            local RootPart = Character and Character:FindFirstChild('HumanoidRootPart')
            local Position = RootPart and RootPart.CFrame
            Spawn(function()
                while true do
                    if not library.pointers["Void 2"]:Active() then
                        break
                    end
                    Script.Desync.cframe = (RootPart.CFrame * CFrame.new(0, -Huge, 0))
                    Wait(0.2)
                    Script.Desync.cframe = Position
                    Wait(0.2)
                    Position = RootPart.CFrame
                    Script.Desync.cframe = nil
                end
            end)

            local Con = Script.Connections.VC
            if Script.Connections.VC then
                Con:Disconnect()
                Script.Connections.VC = nil
            end

            Script.Connections.VC = RS.PostSimulation:Connect(function()
                if Priority.Current > Priority.CFDesync then
                    if Script.Desync.ClientLocation then
                        Client.Character:FindFirstChild("HumanoidRootPart").CFrame = Script.Desync.ClientLocation
                        Script.Desync.ClientLocation = nil
                    end
                    return
                end
            
                Priority.Current = Priority.CFDesync
                local LocalCharacter = Client.Character
                local LocalRootPart = Client and LocalCharacter:FindFirstChild("HumanoidRootPart")
        
                if not LocalRootPart then return end
        
                Script.Desync.ClientLocation = LocalRootPart.CFrame

                if (Script.Desync.cframe) then 
                    LocalRootPart.CFrame = Script.Desync.cframe
                end
        
                RS.PreRender:Wait()
                LocalRootPart.CFrame = Script.Desync.ClientLocation
                Script.Desync.ClientLocation = nil
                Priority.Current = 0
            end)
        end
    end
end)

Script.Functions.unlockk = LPH_NO_VIRTUALIZE(function()
    if Find(library.pointers["Unlock Checks"]:Get(),"Dead Check") and Script.Functions.Death_Check(Target) then
        Target = nil
        local con = Script.Connections.TargetRespawn 
        if con then
            con:Disconnect()
            Script.Connections.TargetRespawn = nil
            Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
        end
        stopblyat()
        Resolver:CleanupBacktrack(Target)
        bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))
    end
    if Find(library.pointers["Unlock Checks"]:Get(),"Knocked Check") and not Script.Functions.Knocked_Check(Target)then
        Target = nil
        local con = Script.Connections.TargetRespawn 
        if con then
            con:Disconnect()
            Script.Connections.TargetRespawn = nil
            Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
        end
        stopblyat()
        Resolver:CleanupBacktrack(Target)
        bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))
    end
    if Find(library.pointers["Unlock Checks"]:Get(),"Grabbed Check") and Target.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil then
        Target = nil
        local con = Script.Connections.TargetRespawn 
        if con then
            con:Disconnect()
            Script.Connections.TargetRespawn = nil
            Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
        end
        stopblyat()
        Resolver:CleanupBacktrack(Target)
        bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))
    end
end)

Script.Functions.ANTIRPG = LPH_NO_VIRTUALIZE(function()
    if library.pointers["ANTIRPG"]:Get() then
        local playerPosition = Client.Character.HumanoidRootPart.Position
        for _, model in pairs(game.Workspace.Ignored:GetChildren()) do
            if model:IsA("Model") and model.Name == "GrenadeLauncherAmmo" or model.Name == "Handle" or model:FindFirstChild("Launcher") then
                local launcher = model:FindFirstChild("Launcher") or model:FindFirstChild("Main") or model
                if launcher and (launcher.Position - playerPosition).Magnitude <= 30 then
                    local offset = Vector3.new(Random(30, 50), 0, Random(30, 50))
                    Client.Character.HumanoidRootPart.CFrame = CFrame.new(playerPosition + offset)
                end
            end
        end
    end
end)

Script.Functions.CombinedRocketHandler = LPH_NO_VIRTUALIZE(function()
    pcall(function()
        local bulletTP = library.pointers["BulletTP"]:Get() and Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") and Workspace.Players[Target.Name]
        local antiRPG = library.pointers["ANTIRPG"]:Get()
        
        if bulletTP or antiRPG then
            local playerPosition = Client.Character.HumanoidRootPart.Position
            local targetpos
            
            if bulletTP then
                targetpos = CFrame.new(Workspace.Players[Target.Name].Head.CFrame.X,Workspace.Players[Target.Name].Head.CFrame.Y + 2,Workspace.Players[Target.Name].Head.CFrame.Z)
                targetpos = targetpos + (Resolver:GetResolverData(Target).Velocity * Script.Functions.GetPred())
            end
            
            for _, object in ipairs(Workspace.Ignored:GetChildren()) do
                local launcher
                
                if object:IsA("Model") and object:FindFirstChild("Launcher") then
                    launcher = object:FindFirstChild("Launcher")
                elseif object:IsA("BasePart") and object.Name == "Handle" then
                    launcher = object
                elseif object:IsA("Model") and object.Name == "GrenadeLauncherAmmo" then
                    launcher = object:FindFirstChild("Main")
                end
                if launcher and launcher:IsA("BasePart") then
                    if bulletTP then
                        if launcher:FindFirstChildOfClass("BodyVelocity") then
                            launcher.BodyVelocity:Destroy()
                        end
                        launcher.CFrame = targetpos
                    end
                    
                    if antiRPG and (launcher.Position - playerPosition).Magnitude <= 30 then
                        local offset = Vector3.new(Random(30, 50), 0, Random(30, 50))
                        Client.Character.HumanoidRootPart.CFrame = CFrame.new(playerPosition + offset)
                    end
                end
            end
        end
    end)

end)


Script.Functions.AnimationLag = function()
    if library.pointers["AnimationLag"]:Get() then
        local tracks = Client.Character.Humanoid:GetPlayingAnimationTracks()
        local tickPercentage = library.pointers["Animation Tick"]:Get() / 100
        local time = tickPercentage / 2
        for _, track in ipairs(tracks) do
            track:AdjustSpeed(0) 
        end
        wait(time)
        for _, track in ipairs(tracks) do
            track:AdjustSpeed(1)
        end
        wait(time) 
    end
end

local aimviewedbro = nil
-- minified it 
local Aimview_Beam=Instance.new("Beam")
Aimview_Beam.Segments=1;
Aimview_Beam.Width0=0.2;
Aimview_Beam.Width1=0.2;
Aimview_Beam.FaceCamera=true;

local BeamAttachment_1=Instance.new("Attachment")
local BeamAttachment_2=Instance.new("Attachment")
Aimview_Beam.Attachment0 = BeamAttachment_1
Aimview_Beam.Attachment1 = BeamAttachment_2
Aimview_Beam.Parent = workspace.Terrain
BeamAttachment_1.Parent=workspace.Terrain
BeamAttachment_2.Parent=workspace.Terrain

Script.Functions.Aimview = LPH_NO_VIRTUALIZE(function()
    if not aimviewedbro then return end

    function getgun()
        for i,v in pairs(aimviewedbro.Character:GetChildren()) do
            if v and (v:FindFirstChild('Default') or v:FindFirstChild('Handle') )then
                return v
            end
        end
    end
    Aimview_Beam.Color = ColorSequence.new(library.pointers["AimviewerColor"]:Get().Color)  

    if library.pointers["Aimview"]:Get() and aimviewedbro and getgun() and aimviewedbro.Character:FindFirstChild("BodyEffects") and aimviewedbro.Character:FindFirstChild("Head") then
        Aimview_Beam.Enabled = true
        BeamAttachment_1.Position =  aimviewedbro.Character:FindFirstChild("Head").Position
        BeamAttachment_2.Position = aimviewedbro.Character.BodyEffects.MousePos.Value
    else
        Aimview_Beam.Enabled = false
    end
end)

local a = Instance.new("Animation")
a.AnimationId = "rbxassetid://10714340543"
local b = Instance.new("Animation")
b.AnimationId = "rbxassetid://10714369624"
local character = Client.Character or Client.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local Floss = humanoid:LoadAnimation(a)
local Hype = humanoid:LoadAnimation(b)

Script.Functions.PlayAnimation = function()
    local state = library.pointers["Animations"]:Get()

    if state == "Floss" then
        Hype:Stop()
        Floss:Play()
    elseif state == "Hype" then
        Floss:Stop()
        Hype:Play()
    elseif state == "Off" then
        Floss:Stop()
        Hype:Stop()
    end
end

local FFlags = {
    ["PhysicsSenderMaxBandwidthBps"] = "38760",
    ["S2PhysicsSenderRate"] = "15"
}
Script.Functions.Fflags_Manager = function(value)
    if value == true and setfflag then
        setfflag("PhysicsSenderMaxBandwidthBps", tostring(Pi/3))
        setfflag("S2PhysicsSenderRate", tostring(library.pointers["Desync Packets"]:Get()))
        Script.Desync.IsOnFFlags = true 
    elseif setfflag then
        if Script.Desync.IsOnFFlags == true then
            setfflag("PhysicsSenderMaxBandwidthBps", FFlags.PhysicsSenderMaxBandwidthBps)
            setfflag("S2PhysicsSenderRate", FFlags.S2PhysicsSenderRate)
            Script.Desync.IsOnFFlags = false 
            return true
        end
    end
    return false
end
Workspace.FallenPartsDestroyHeight = -500000
do -- Gui
    Script.Variables.Window = library:New({Name = "ethh.lol",Size = Vector2.new(550,635), PageAmmount = 6 })

    Script.Variables.Aimbot = Script.Variables.Window:Page({Name = "Rage Bot"})
    --Script.Variables.Legitbot = Script.Variables.Window:Page({Name = "Legit Bot"})
    Script.Variables.AntiAim = Script.Variables.Window:Page({Name = "Anti Aim"})
    Script.Variables.Misc = Script.Variables.Window:Page({Name = "Misc"})
    Script.Variables.Visuals = Script.Variables.Window:Page({Name = "Visuals"})
    Script.Variables.Players = Script.Variables.Window:Page({Name = "Players"})
    --Script.Variables.Luas = Script.Variables.Window:Page({Name = "Lua"})
    Script.Variables.Settings = Script.Variables.Window:Page({Name = "Settings"})
    
    do -- Silent
        Script.Variables.AimbotSettings = Script.Variables.Aimbot:Section({Name = "Main", Side = "Left"})
        Script.Variables.AimbotSection = Script.Variables.Aimbot:Section({Name = "Settings", Side = "Left"})
        Script.Variables.AimbotSectionOther = Script.Variables.Aimbot:Section({Name = "Other", Side = "Right"})
        Script.Variables.AimbotV = Script.Variables.Aimbot:Section({Name = "Visualize", Side = "Left", Fill = true})
        Script.Variables.AimbotSectionStrafe = Script.Variables.Aimbot:Section({Name = "Target strafe", Side = "Right"})
        Script.Variables.AimbotChecks = Script.Variables.Aimbot:Section({Name = "Checks", Side = "Right", Fill = true})

        Script.Variables.AimbotSettings:Toggle({Name = "Enabled", Default = false, Pointer = "AimbotMain_Enabled"})
        Script.Variables.AimbotSettings:Toggle({Name = "Spectate Target", Default = false, Pointer = "Spec" , callback = function()
            if library.pointers["Spec"]:Get() and Target then
                local con = Script.Connections.TargetRespawn 
                if con then
                    con:Disconnect()
                    Script.Connections.TargetRespawn = nil
                end
    
                if Target.Character then
                    Workspace.CurrentCamera.CameraSubject = Target.Character:FindFirstChild("Humanoid")
                end
    
                Script.Connections.TargetRespawn = Target.CharacterAdded:Connect(function(Plr)
                    Workspace.CurrentCamera.CameraSubject = Players[Plr.Name].Character:WaitForChild("Humanoid")
                end)
            else
                local con = Script.Connections.TargetRespawn 
                if con then
                    con:Disconnect()
                    Script.Connections.TargetRespawn = nil
                    Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
                end
                Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
            end
        end})
        Script.Variables.AimbotSettings:Toggle({Name = "Auto Select Target", Default = false, Pointer = "AutoSelection"})
        Script.Variables.AimbotSettings:Keybind({Name = "Get Target",nothanks = true, Default = Enum.KeyCode.C, Mode = "Toggle", Pointer = "blkfrr", Callback = function(keybind, state)
            if not library.pointers["AutoSelection"]:Get() then
                if Target then
                    if library.pointers["Automatic_fire"]:Get() and Client.Character:FindFirstChildWhichIsA("Tool")  then
                        Client.Character:FindFirstChildWhichIsA("Tool"):Deactivate()
                    end
                    Resolver:CleanupBacktrack(Target)
                    Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
                    Resolver:ResetPlayerData(Target)
                    Target = nil
                    local con = Script.Connections.TargetRespawn 
                    if con then
                        con:Disconnect()
                        Script.Connections.TargetRespawn = nil
                        Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
                    end
                    stopblyat()
                    bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))

                    Notificationslib:New("[ethh.lol] Unlocked", 1.5, Color3.fromRGB(255, 102, 204))
                else 
                    Script.Functions.GetTarget()
                    if library.pointers["Spec"]:Get() and Target then
                        local con = Script.Connections.TargetRespawn 
                        if con then
                            con:Disconnect()
                            Script.Connections.TargetRespawn = nil
                        end
            
                        if Target.Character then
                            Workspace.CurrentCamera.CameraSubject = Target.Character:FindFirstChild("Humanoid")
                        end
            
                        Script.Connections.TargetRespawn = Target.CharacterAdded:Connect(function(Plr)
                            Workspace.CurrentCamera.CameraSubject = Players[Plr.Name].Character:WaitForChild("Humanoid")
                        end)
                    end
                end
            end
        end})

        Script.Variables.AimbotSection:Dropdown({Name = "Target hitbox", Options = {"Head", "LeftArm", "RightArm", "LeftLeg", "RightLeg", "HumanoidRootPart"}, Default = "HumanoidRootPart", Pointer = "HitPart"})
        Script.Variables.AimbotSection:Toggle({Name = "Baim", Default = true}):Keybind({Pointer = "B aim",mode = "On Hold", Default = Enum.KeyCode.B, Callback = function(state)
            local oldpart = library.pointers["HitPart"]:Get()
            repeat 
                library.pointer["HitPart"]:Set("HumanoidRootPart")
                Wait()
            until not state
            library.pointer["HitPart"]:Set(oldpart)
        end})
        
        Script.Variables.AimbotSection:Toggle({Name = "Predict velocity", Default = true, Pointer = "Predictionbool"})
        Script.Variables.AimbotSection:Toggle({Name = "Auto prediction", Default = true, Pointer = "AutoPred"})
        Script.Variables.AimbotSection:Slider({Name = "Prediction", Minimum = 0, Maximum = 1, decimals = 0.001, Default = 0.135, Pointer = "Prediction"})
        Script.Variables.AimbotSection:Toggle({Name = "Automatic fire", Default = false, Pointer = "Automatic_fire"})
        Script.Variables.AimbotSection:Toggle({Name = "Anti ground shot", Default = false, Pointer = "NoGRound"})
        Script.Variables.AimbotSection:Toggle({Name = "Angular checks", Default = false, Pointer = "Agnlescheck"})
        Script.Variables.AimbotSection:Toggle({Name = "Use FOV", Default = false, Pointer = "Use Fov"}):Colorpicker({Pointer = "FovColor"})
        Script.Variables.AimbotSection:Slider({Name = "Maximum FOV", Minimum = 0, Maximum = 180, Default = 180, Pointer = "FOV"})

        Script.Variables.AimbotSectionOther:Toggle({Name = "Look at target", Default = false, Pointer = "LookATTarget"})
        Script.Variables.AimbotSectionOther:Toggle({Name = "Anti aim correction", Default = false, Pointer = "Resolver"})
        Script.Variables.AimbotSectionOther:Toggle({Name = "Backtrack", Default = false, Pointer = "Backtrack", callback = function(state)
            if not state and Target then
                Resolver:CleanupBacktrack(Target)
            end
        end})
        Script.Variables.AimbotSectionOther:Dropdown({Name = "Backtrack boost", Options = {"Lowest", "Normal", "High", "Maximum"}, Default = "Normal", Pointer = "Backtrack boost"})
        Script.Variables.AimbotSectionOther:Toggle({Name = "Remove recoil", Default = false, Pointer = "Norecoil"})
        Script.Variables.AimbotSectionOther:Toggle({Name = "Automatic reload", Default = false, Pointer = "Auto reload"})
        Script.Variables.AimbotSectionOther:Toggle({Name = (game.PlaceId == 2788229376 or game.PlaceId == 7213786345 or game.PlaceId == 16033173781) and "Explosive TP" or "Bullet TP", Default = false, Pointer = "BulletTP",callback = function (state)
            if state and Target and not (game.PlaceId == 2788229376 or game.PlaceId == 7213786345 or game.PlaceId == 16033173781) then
                Script.Functions.BulletTp()
            else
                local Con1 = Script.Connections.BulletTP1
                local con2 = Script.Connections.BulletTP2

                if Con1 then
                    Con1:Disconnect()
                    Script.Connections.BulletTP1 = nil
                end

                if con2 then
                    con2:Disconnect()
                    Script.Connections.BulletTP2 = nil
                end
            end
        end})

        Script.Variables.AimbotSectionStrafe:Toggle({Name = "Enabled", Default = false, Pointer = "iazhneia"}):Keybind({Pointer = "TargetStrafe",Default = Enum.KeyCode.K ,mode = "Always", keybindName = "Target Strafe", callback = function(current , state)
            if not state then
                bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))
            end
        end})
        Script.Variables.AimbotSectionStrafe:Toggle({Name = "Server sided", Default = false, Pointer = "Server_sided", callback = function(state)
            if not state then
                bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))
            end
        end})
        Script.Variables.AimbotSectionStrafe:Toggle({Name = "Visualize", Default = false, Pointer = "Visualize_Server_sided"}):Colorpicker({Pointer = "CloneCOlor"})
        Script.Variables.AimbotSectionStrafe:Dropdown({Name = "Mode", Options = {"Random",  "Circle"}, Pointer = "StrafeMode", callback = function(state)
            if not library.pointers["Minimum height"] then return end
            if state == "Circle" then
                library.pointers["Maximum Distance"]:SetName("Speed")
                library.pointers["Minimum Distance"]:SetName("Y offset")
                library.pointers["Maximum height"]:SetName("Radius")
                library.pointers["Minimum height"]:SetName("Ignore (random mode only)")
            else
                library.pointers["Maximum Distance"]:SetName("Maximum Distance")
                library.pointers["Minimum Distance"]:SetName("Minimum Distance")
                library.pointers["Maximum height"]:SetName("Maximum height")
                library.pointers["Minimum height"]:SetName("Minimum height")
            end
        end})


        Script.Variables.AimbotSectionStrafe:Slider({Name = "Maximum Distance", Minimum = 0, Maximum = 20, Default = 18, Pointer = "Maximum Distance"})
        Script.Variables.AimbotSectionStrafe:Slider({Name = "Minimum Distance", Minimum = 0, Maximum = 20, Default = 7, Pointer = "Minimum Distance"})
        Script.Variables.AimbotSectionStrafe:Slider({Name = "Maximum height", Minimum = 0, Maximum = 20, Default = 17, Pointer = "Maximum height"})
        Script.Variables.AimbotSectionStrafe:Slider({Name = "Minimum height", Minimum = 0, Maximum = 20, Default = 1, Pointer = "Minimum height"})
        Script.Variables.AimbotSectionStrafe:Toggle({Name = "Stomp when knocked", Default = false, Pointer = "autostomp"})

        Script.Variables.AimbotChecks:Multibox({Name = "Checks", Options = {"Knocked Check","Dead Check","Wall Check", "Crew Check"}, Default = {}, Pointer = "Checks"})
        Script.Variables.AimbotChecks:Multibox({Name = "Unlock on", Options = {"Knocked Check","Dead Check","Grabbed Check"}, Default = {}, Pointer = "Unlock Checks"})
        Script.Variables.AimbotV:Toggle({Name = "Line", Default = false, Pointer = "LineToggle"}):Colorpicker({Pointer = "Line Color"})
        Script.Variables.AimbotV:Dropdown({Name = "From", Default = "Mouse", Options = {"Mouse" , "Body"}, Pointer = "Line Pos" })
        Script.Variables.AimbotV:Toggle({Name = "Highlight", Default = false, Pointer = "HighlightTarget"}):Colorpicker({Pointer = "Highlight Color"})
    end

    --[[do-- Legit bot
        Script.Variables.LegitAim = Script.Variables.Legitbot:Section({Name = "Aimbot", Side = "Left"})
        --Script.Variables.TriggerBot = Script.Variables.Legitbot:Section({Name = "Trigger Bot", Side = "Right"})
        Script.Variables.AimChecks = Script.Variables.Legitbot:Section({Name = "Checks", Side = "Right"})
        
        Script.Variables.LegitAim:Toggle({Name = "Enabled", Pointer = "Aimlock", Default = false}):Keybind({nothanks = true, Default = Enum.KeyCode.E, KeybindName = (""), Mode = "Toggle", Pointer = "Aimlockkey", callback = function(state)
            if state then
                --get a targt
            else
                AimTarget = nil
            end
        end})
        Script.Variables.LegitAim:Dropdown({Name = "Target hitbox", Options = {"Head", "LeftArm", "RightArm", "LeftLeg", "RightLeg", "HumanoidRootPart"}, Default = "HumanoidRootPart", Pointer = "AimlockPart"})
        Script.Variables.LegitAim:Slider({Name = "Prediction X", Minimum = 0, Maximum = 1, decimals = 0.001, Default = 0.135, Pointer = "CamPredictionX"})
        Script.Variables.LegitAim:Slider({Name = "Prediction Y", Minimum = 0, Maximum = 1, decimals = 0.001, Default = 0.135, Pointer = "CamPredictionY"})
        Script.Variables.LegitAim:Slider({Name = "Smoothness X", Minimum = 0, Maximum = 1, decimals = 0.001, Default = 0.02, Pointer = "CamSmoothnessX"})
        Script.Variables.LegitAim:Slider({Name = "Smoothness Y", Minimum = 0, Maximum = 1, decimals = 0.001, Default = 0.05, Pointer = "CamSmoothnessY"})

        Script.Variables.LegitAim:Toggle({Name = "Use FOV", Default = false, Pointer = "Aim  Use Fov"}):Colorpicker({Pointer = "AimFovColor"})
        Script.Variables.LegitAim:Slider({Name = "Maximum FOV", Minimum = 0, Maximum = 180, Default = 180, Pointer = "AimFOV"})

        Script.Variables.AimChecks:Multibox({Name = "Checks", Options = {"Knocked Check","Dead Check","Wall Check", "Crew Check"}, Default = {}, Pointer = "Aim Checks"})
        Script.Variables.AimChecks:Multibox({Name = "Unlock on", Options = {"Knocked Check","Dead Check","Grabbed Check"}, Default = {}, Pointer = "Aim Unlock Checks"})

        --Script.Variables.TriggerBot:Toggle({Name = "Enabled", Pointer = "Triggerbot Enabled", Default = false}):Keybind({Default = Enum.KeyCode.E, KeybindName = ("Trigger Bot"), Mode = "Hold", Pointer = "TriggerBot"})
    end]]

    do -- misc
            -- CFrame Section
        Script.Variables.CFrameSection = Script.Variables.Misc:Section({Name = "CFrame", Side = "Left"})
        Script.Variables.CFrameSection:Toggle({Name = "Cframe Speed", Default = false, Pointer = "CFRAMESPEED"}):Keybind({Default = Enum.KeyCode.X, KeybindName = "CFrame Speed", Mode = "Toggle", Pointer = "IsCframeActive"})
        Script.Variables.CFrameSection:Slider({Name = "Speed", Minimum = 0, Maximum = 100, Default = 40, Pointer = "CFRAMESPEED VALUE"})

        -- Auto Block Section
        Script.Variables.AutoBlockSection = Script.Variables.Misc:Section({Name = "Auto Block", Side = "Left"})
        Script.Variables.AutoBlockSection:Toggle({Name = "Auto block", Default = false, Pointer = "AUTOBLOCK"})
        Script.Variables.AutoBlockSection:Slider({Name = "Auto block min distance", Minimum = 0, Maximum = 15, Default = 8, Pointer = "AUTOBLOCK VALUE"})
        Script.Variables.AutoTrashtalkSection = Script.Variables.Misc:Section({Name = "TrashTalk", Side = "Left"})
        Script.Variables.AutoTrashtalkSection:Dropdown({Name = "Auto Trash talk", Options = {"Off", "English", "Russian", "Both"}, Default = "Off", Pointer = "TRASHTALK"})

        -- Anti Features Section
        Script.Variables.AntiFeaturesSection = Script.Variables.Misc:Section({Name = "Anti Features", Side = "Left"})
        Script.Variables.AntiFeaturesSection:Toggle({Name = "No seat", Default = false, Pointer = "destroysits", callback = function(state)
            for i, v in pairs(Workspace:GetDescendants()) do 
                if v:IsA("Seat") then 
                    v.Disabled = state
                end 
            end 
        end})
        Script.Variables.AntiFeaturesSection:Toggle({Name = "Anti RPG", Default = false, Pointer = "ANTIRPG"})
        Script.Variables.AntiFeaturesSection:Toggle({Name = "Anti stomp", Default = false, Pointer = "AntiStomp"})

        -- Fly Section
        Script.Variables.FlySection = Script.Variables.Misc:Section({Name = "Fly", Side = "Left"})
        Script.Variables.FlySection:Toggle({Name = "Fly", Default = false, Pointer = "Fly1"}):Keybind({Default = Enum.KeyCode.W, KeybindName = "Fly", Mode = "Toggle", Pointer = "Fly2"})
        Script.Variables.FlySection:Slider({Name = "Fly Speed", Minimum = 0, Maximum = 100, Default = 30, Pointer = "Fly Speed"})

        -- Force Reset Section
        Script.Variables.ForceResetSection = Script.Variables.Misc:Section({Name = "Force Reset", Side = "Left"})
        Script.Variables.ForceResetSection:Button({Name = "Force Reset", callback = function()
            Client.Character.Humanoid:ChangeState("Dead")
        end})
        local gunNames = {}
        for gunName, _ in pairs(Script.Variables.Guns) do
            Insert(gunNames, gunName)
        end
        -- Auto Buy Section
        Script.Variables.AutobuySection = Script.Variables.Misc:Section({Name = "Auto Buy", Side = "Right"})
        Script.Variables.AutobuySection:Toggle({Name = "Teleport back", Default = true, Pointer = "Tpback"})
        Script.Variables.AutobuySection:Dropdown({Name = "Gun", Options = gunNames, Default = gunNames[1] or "no guns found", Pointer = "Selected Gun"})
        Script.Variables.AutobuySection:Button({Name = "Buy Gun", CallBack = function ()
            local OldPosition = Client.Character.HumanoidRootPart.CFrame
            bodyClone:SetPrimaryPartCFrame(CFrame.new(9959, 9999, 9990))
            stopblyat()
            repeat
                Resolver:CleanupBacktrack(Target)
                Target = nil
                Client.Character.HumanoidRootPart.CFrame = Script.Variables.Guns[library.pointers["Selected Gun"]:Get()].Gun.Head.CFrame + Vector3.new(0, -5, 0)
                Wait(0.2)
                fireclickdetector(Script.Variables.Guns[library.pointers["Selected Gun"]:Get()].Gun.ClickDetector)
            until hasToolInInventory("["..library.pointers["Selected Gun"]:Get().."]")
            if library.pointers["Tpback"]:Get() then
                Client.Character.HumanoidRootPart.CFrame = OldPosition
            end
        end})

        Script.Variables.AutobuySection:Button({Name = "Buy Ammo", CallBack = function ()
            local OldPosition = Client.Character.HumanoidRootPart.CFrame
            local ammovalue = tonumber(Client.DataFolder.Inventory["["..library.pointers["Selected Gun"]:Get().."]"].Value)
            local oldammo = ammovalue
            bodyClone:SetPrimaryPartCFrame(CFrame.new(9959, 9999, 9990))
            stopblyat()
            local con = Script.Connections.TargetRespawn 
            if con then
                con:Disconnect()
                Script.Connections.TargetRespawn = nil
                Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
            end
            repeat
                Resolver:CleanupBacktrack(Target)
                Target = nil
                unequipAllTools()
                Client.Character.HumanoidRootPart.CFrame = Script.Variables.Guns[library.pointers["Selected Gun"]:Get()].Ammo.Head.CFrame + Vector3.new(0, -5, 0)
                Wait(0.2)
                fireclickdetector(Script.Variables.Guns[library.pointers["Selected Gun"]:Get()].Ammo.ClickDetector)
                ammovalue = tonumber(Client.DataFolder.Inventory["["..library.pointers["Selected Gun"]:Get().."]"].Value)
            until ammovalue > oldammo
            if library.pointers["Tpback"]:Get() then
                Client.Character.HumanoidRootPart.CFrame = OldPosition
            end
        end})

        -- Auto Armor Section
        Script.Variables.MiscArmor = Script.Variables.Misc:Section({Name = "Auto Armor", Side = "Right"})
        Script.Variables.MiscArmor:Toggle({Name = "Auto Armor", Default = false, Pointer = "Auto Armor"})
        Script.Variables.MiscArmor:Slider({Name = "Auto Armor Threshold", Min = 0, Max = 130, Default = 70, Pointer = "Auto Armor Threshold"})
        Script.Variables.MiscArmor:Toggle({Name = "Auto Fire Armor", Default = false, Pointer = "Auto Fire Armor"})
        Script.Variables.MiscArmor:Slider({Name = "Auto Fire Armor Threshold", Min = 0, Max = 200, Default = 70, Pointer = "Auto Fire Armor Threshold"})

        -- Teleport Section
        Script.Variables.MiscTp = Script.Variables.Misc:Section({Name = "Teleport", Side = "Right"})
        Script.Variables.MiscTp:Dropdown({Name = "Place", Options = {"Revolver", "Hospital","Casino","Boxing Club","Gym","PlayGround","School","Military","Basket Ball","Ovni","UpHill","Gas Station","Ware House","DownHill", "Bank"}, Default = "Revolver", Pointer = "Location"})
        Script.Variables.MiscTp:Button({Name = "Teleport To", CallBack = function()
            if library.pointers["Location"]:Get() == "Revolver" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-638.022827, 21.9748421, -128.713028, -0.999997199, 1.9194446e-09, -0.00235899375, 1.78167403e-09, 1, 5.8404396e-08, 0.00235899375, 5.84000333e-08, -0.999997199)
            elseif library.pointers["Location"]:Get() == "Military" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(37.1350822, 25.4798431, -878.950195, -0.999956131, -2.32964759e-08, 0.00936603174, -2.41687559e-08, 1, -9.30191462e-08, -0.00936603174, -9.32414324e-08, -0.999956131)
            elseif library.pointers["Location"]:Get() == "Ovni" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(86.723671, 139.224792, -640.820435, 0.962958038, 2.29497186e-08, 0.269651234, -1.06976494e-09, 1, -8.12886256e-08, -0.269651234, 7.79890783e-08, 0.962958038)
            elseif library.pointers["Location"]:Get() == "UpHill" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(491.409515, 47.9798279, -569.828918, 0.00947026815, -7.09887473e-08, 0.999955177, 3.99464213e-08, 1, 7.06136092e-08, -0.999955177, 3.92758999e-08, 0.00947026815)
            elseif library.pointers["Location"]:Get() == "Gas Station" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(519.166565, 48.0048294, -245.954147, 0.0427071229, -4.01408728e-09, -0.999087632, -1.17610066e-09, 1, -4.0680268e-09, 0.999087632, 1.34876132e-09, 0.0427071229)
            elseif library.pointers["Location"]:Get() == "Ware House" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(618.71936, 211.181015, -0.813318849, -0.0164720397, -2.94878877e-08, -0.99986434, -4.12523793e-09, 1, -2.94239282e-08, 0.99986434, 3.64000607e-09, -0.0164720397)
            elseif library.pointers["Location"]:Get() == "Bank" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-457.318298, 39.2583694, -280.641724, -0.0255939662, -5.41709362e-08, -0.999672413, -5.01915121e-10, 1, -5.41758389e-08, 0.999672413, -8.84823881e-10, -0.0255939662)
            elseif library.pointers["Location"]:Get() == "DownHill" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-532.7901, 7.77968121, -769.451172, 0.00499271043, 1.92325285e-08, 0.999987543, -1.34647795e-08, 1, -1.9165542e-08, -0.999987543, -1.33689237e-08, 0.00499271043)
            elseif library.pointers["Location"]:Get() == "Basket Ball" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-933.007568, 22.2246609, -482.761902, 0.00884684082, 7.83275098e-08, -0.99996084, -6.47402203e-08, 1, 7.77578038e-08, 0.99996084, 6.40497717e-08, 0.00884684082)
            elseif library.pointers["Location"]:Get() == "Casino" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-950.866699, 21.4798355, -185.903458, -0.00777026732, 4.39235626e-09, 0.99996984, 8.32501499e-08, 1, -3.74559317e-09, -0.99996984, 8.32185307e-08, -0.00777026732)
            elseif library.pointers["Location"]:Get() == "School" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-600.178406, 21.4748363, 196.948257, -0.999962747, 3.5574427e-08, -0.00863110367, 3.61365302e-08, 1, -6.49689937e-08, 0.00863110367, -6.52784777e-08, -0.999962747)
            elseif library.pointers["Location"]:Get() == "Gym" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-73.212738, 21.4798355, -583.745789, 0.998194933, -1.83605788e-08, 0.0600570962, 1.23209567e-08, 1, 1.00934962e-07, -0.0600570962, -1.00012812e-07, 0.998194933)
            elseif library.pointers["Location"]:Get() == "Boxing Club" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-195.137863, 21.9798393, -1117.77271, 0.0316264816, -2.77072187e-09, 0.999499738, 2.01495194e-08, 1, 2.13453122e-09, -0.999499738, 2.00719317e-08, 0.0316264816)
            elseif library.pointers["Location"]:Get() == "PlayGround" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(-247.645737, 21.9798393, -796.975464, -0.0181502849, 6.85812296e-09, 0.999835253, -5.52949153e-08, 1, -7.86303644e-09, -0.999835253, -5.54285222e-08, -0.0181502849)
            elseif library.pointers["Location"]:Get() == "Hospital" then
                Client.Character.HumanoidRootPart.CFrame = CFrame.new(75.2508698, 21.9798393, -483.567963, 0.0233723093, -7.77975551e-09, -0.999726832, 1.12244765e-08, 1, -7.51946772e-09, 0.999726832, -1.10456631e-08, 0.0233723093)
            end
        end})
    end
    Script.Variables.Animation = Script.Variables.Misc:Section({Name = "Animation", Side = "Right"})
    Script.Variables.Animation:Dropdown({Name = "Animations" , Options = {"Off", "Floss", "Hype"}, Pointer = "Animations", callback = Script.Functions.PlayAnimation})
    do -- anti aim
        if not getfflag or SFind(identifyexecutor(), "Solara") then
            getfflag = function(...)
                return {}
            end
        end
        if not setfflag or SFind(identifyexecutor(), "Solara") then
            setfflag = function(...)
                return {}
            end
        end
        Script.Variables.AntiAimVel = Script.Variables.AntiAim:Section({Name = "Velocity", Side = "Left"})
        Script.Variables.AntiAimDesync = Script.Variables.AntiAim:Section({Name = "Desync", Side = "Right"})
        Script.Variables.AntiAimAsync = Script.Variables.AntiAim:Section({Name = "a-sync", Side = "Right"})
        Script.Variables.DestroyCheaterss = Script.Variables.AntiAim:Section({Name = "Destroy Cheaters", Side = "Right"})
        Script.Variables.AntiAimSpin = Script.Variables.AntiAim:Section({Name = "Spinbot", Side = "Left"})
        Script.Variables.RANDOMTP = Script.Variables.AntiAim:Section({Name = "Random TP", Side = "Right"})
        Script.Variables.AntiAimNetwork = Script.Variables.AntiAim:Section({Name = "Network Desync", Side = "Left"})
        Script.Variables.AnimationLag = Script.Variables.AntiAim:Section({Name = "Animation Lag", Side = "Left"})

        Script.Variables.AntiAimVel:Toggle({Name= "Enabled", Default = false, Pointer= "Velobool1"}):Keybind({Default = Enum.KeyCode.C, KeybindName = ("Velocity AA"), Mode = "Toggle", Pointer = "Velobool2"})
        Script.Variables.AntiAimVel:Toggle({Name = "Anti MoveDirection", Default = false, Pointer = "AntiMoveDirection"})
        Script.Variables.AntiAimVel:Dropdown({Name = "Type", Options = {"Max Velocity", "Underground", "Sky", "Pred breaker","Zero"}, Default= "Max Velocity", Pointer = "VeloType"})

        Script.Variables.AntiAimDesync:Toggle({Name= "Enabled", Default = false, Pointer= "DesyncBool"}):Keybind({Default = Enum.KeyCode.Z, KeybindName = ("Desync AA"), Mode = "Toggle", Pointer = "DesyncBool2", callback = function(key, value) 
            if not value then 
                if sethiddenproperty then
                    sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
                end
                if setfflag then
                    setfflag("PhysicsSenderMaxBandwidthBps", FFlags.PhysicsSenderMaxBandwidthBps)
                    setfflag("S2PhysicsSenderRate", FFlags.S2PhysicsSenderRate)
                    Script.Desync.IsOnFFlags = false
                end
            else 
                if setfflag then
                    setfflag("PhysicsSenderMaxBandwidthBps", tostring(Pi/3))
                    setfflag("S2PhysicsSenderRate", tostring(library.pointers["Desync Packets"]:Get()))
                    Script.Desync.IsOnFFlags = true
                end
            end
        end})
        Script.Variables.AntiAimDesync:Slider({Name = "Ticks", min = 0.1, max = 2.0 , default = 0.3, Decimals = 0.01, Pointer = "Desync tick"})
        Script.Variables.AntiAimDesync:Toggle({Name = "Rolls", Default = false, Pointer = "Rollss"})
        Script.Variables.AntiAimDesync:Slider({Name = "Choked packets", min = 1, max = 4 , default = 2, Pointer = "Desync Packets", callback = function(value) 
            if library.pointers["DesyncBool2"].Active() then
                setfflag("S2PhysicsSenderRate", tostring(value))
                Script.Desync.IsOnFFlags = true
            else
                setfflag("S2PhysicsSenderRate", FFlags.S2PhysicsSenderRate)
                Script.Desync.IsOnFFlags = false
            end
        end})

        Script.Variables.AntiAimAsync:Toggle({Name= "Enabled", Default = false, Pointer= "Asyncbool"}):Keybind({Default = Enum.KeyCode.V, KeybindName = ("A-Sync"), Mode = "Toggle", Pointer = "Asyncbool2"})
        Script.Variables.AntiAimAsync:Slider({Name = "Ticks",Min = 0.01, Max = 15, Decimals = 0.001, Default = 0.350, Pointers = "ASYNC TICK"})

        Script.Variables.DestroyCheaterss:Toggle({Name= "Destroy Cheater", Default = false, Pointer= "Destroy Cheaters1"}):Keybind({nothanks = true, Default = Enum.KeyCode.K, KeybindName = ("Destroy Cheater"), Mode = "Toggle", Pointer = "Destroy Cheaters2", Callback = function()
            local Con = Script.Connections.DC
            if Script.Connections.DC then
                Con:Disconnect()
                Script.Connections.DC = nil
            end
            if library.pointers["Destroy Cheaters1"]:Get() and library.pointers["Destroy Cheaters2"]:Active() then
                Script.Functions.DestroyCheater()
            end
        end})
        Script.Variables.DestroyCheaterss:Toggle({Name= "Void spam", Default = false, Pointer= "Void 1"}):Keybind({Default = Enum.KeyCode.H, KeybindName = ("Void spam"), Mode = "Toggle", Pointer = "Void 2", callback = Script.Functions.VoidDesync})

        Script.Variables.AntiAimSpin:Toggle({Name= "Enabled", Default = false , Pointer = "Spinbot", callback = function(state)
            Spawn(function()
                Client.Character.Humanoid.AutoRotate = not state
                repeat
                    if Client.Parent and library.pointers["Spinbot"]:Get() then
                        Client.Character.HumanoidRootPart.CFrame = Client.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, Rad(library.pointers["spinbot speed"]:Get() / 10), 0)
                    end
                    RS.Heartbeat:Wait()
                until not state or not library.pointers["Spinbot"]:Get()
            end)
        end})
        Script.Variables.AntiAimSpin:Slider({Name = "Speed",Min = 0.01, Max = 100, Decimals = 0.001, Default = 30, Pointer = "spinbot speed"})

        Script.Variables.RANDOMTP:Toggle({Name = "Enabled" , Default = false, Pointer = "RandomTP"}):Keybind({Default = Enum.KeyCode.K, KeybindName = "Random TP", Mode = "Toggle", Pointer = "RandomTP2"})
        Script.Variables.RANDOMTP:Slider({Name = "X", Default = 10, Min = 0, Max = 15, Pointer = "Random X"})
        Script.Variables.RANDOMTP:Slider({Name = "Y", Default = 10, Min = 0, Max = 15, Pointer = "Random Y"})
        Script.Variables.RANDOMTP:Slider({Name = "Z", Default = 10, Min = 0, Max = 15, Pointer = "Random Z"})

        Script.Variables.AntiAimNetwork:Toggle({Name = "Enabled" , Default = false, Pointer = "networked"}):Keybind({Default = Enum.KeyCode.K, KeybindName = "Network Desync", Mode = "Toggle", Pointer = "NetworkDesync"})
        Script.Variables.AntiAimNetwork:Dropdown({Name = "Mode", Options = {"Lag on Stepped", "Classic"}, Pointer = "Network Mode" })
        Script.Variables.AntiAimNetwork:Slider({Name = "Refresh rate", Default = 10, Min = 0, Max = 15, Pointer = "network tick"})

        Script.Variables.AnimationLag:Toggle({Name = "Enabled", Default = false, Pointer = "AnimationLag"})
        Script.Variables.AnimationLag:Slider({Name = "Pourcentage", Default = 50, Min = 0, Max = 100, Suffix = "%" ,Pointer = "Animation Tick"})
    end

    do-- visuals
        Script.Variables.VisualsESP = Script.Variables.Visuals:Section({Name = "ESP", Side = "Left"})
        Script.Variables.Onhit = Script.Variables.Visuals:Section({Name = "On hit", Side = "Right"})
        Script.Variables.Visualisation = Script.Variables.Visuals:Section({Name = "Visualisation", Side = "Right"})
        Script.Variables.Crosshair = Script.Variables.Visuals:Section({Name = "Crosshair", Side = "Left", Fill = true})
        Script.Variables.Self, Script.Variables.SelfWeapon  = Script.Variables.Visuals:MultiSection({Name = "Self", Sections = { "Character","Weapon"}, Side = "Right",Fill = true})

        Script.Variables.VisualsESP:Toggle({Name = "Enabled",Default = false, Pointer= "EnableESP"})
        Script.Variables.VisualsESP:Toggle({Name = "Box",Default = false, Pointer= "BOX"}):Colorpicker({Pointer = "BoxColor"})
        Script.Variables.VisualsESP:Toggle({Name = "Name",Default = false, Pointer= "Name"}):Colorpicker({Pointer = "NameColor"})
        Script.Variables.VisualsESP:Toggle({Name = "Health",Default = false, Pointer= "Health"}):Colorpicker({Pointer = "HealthColor"})
        Script.Variables.VisualsESP:Toggle({Name = "Armor",Default = false, Pointer= "Armor"}):Colorpicker({Pointer = "ArmorColor"})
        Script.Variables.VisualsESP:Toggle({Name = "Distance",Default = false, Pointer= "Distance"}):Colorpicker({Pointer = "DistanceColor"})
        Script.Variables.VisualsESP:Toggle({Name = "Tool",Default = false, Pointer= "Tool"}):Colorpicker({Pointer = "ToolColor"})

        Script.Variables.Onhit:Toggle({Name = "Notfiy", Default = false, Pointer = "NotfiyHit"})
        Script.Variables.Onhit:Toggle({Name = "Hit Effect", Default = false, Pointer = "HitEffect"})
        Script.Variables.Onhit:Toggle({Name = "Hit sound", Default = false, Pointer = "Hitsound"})
        Script.Variables.Onhit:Dropdown({Name = "sound" , Options = {"Rust", "GameSense", "Neverlose","Bow", "Minecraft", "Fatality"} , Default = "Rust", Pointer= "Chosen sound"})
        Script.Variables.Onhit:Multibox({Name = "Effects", Options = {"Clone", "Confetti", "Pulse"}, Minimum = 1, Default = {"Clone"}, Pointer = "Effects"})
        Script.Variables.Onhit:Slider({Name = "Life time", Default = 0.4, Minimum = 0.0, Maximum = 10.0, Decimals =0.1, Pointer = "Life time", Suffix = "s"})
        Script.Variables.Onhit:Colorpicker({Name = "Effect color", Pointer = "Effect color"})

        Script.Variables.Visualisation:Toggle({Name= "Visualise Backtrack", Default = true, Pointer = "Visualise Backtrack"}):Colorpicker({Pointer =  "BackTrack Color"})
        Script.Variables.Visualisation:Toggle({Name = "Show bullets impact", Default = false, Pointer= "ShowBulleti"}):Colorpicker({Pointer =  "BulletIColor"})
        Script.Variables.Visualisation:Slider({Name = "Life time", Default = 0.4, Minimum = 0.0, Maximum = 10.0, Decimals =0.1, Pointer = "Bullet Life time", Suffix = "s"})
        Script.Variables.Visualisation:Toggle({Name= "Bullet Tracers", Default = false, Pointer = "BulletTracer"}):Colorpicker({Pointer =  "BulletTracer Color"})
        Script.Variables.Visualisation:Slider({Name = "Bullet Tracers Lifetime", Flag = 'Tracers Life Time', Min = 0, Max = 10,  Suffix = "s",Default = 2, Decimals = 0.1})
        Script.Variables.Visualisation:Toggle({Name = "Ambient Color", Default = false, Pointer= "Ambient Color"}):Colorpicker({Pointer =  "Ambient_Color", Callback = function()
            Spawn(function ()
                while Wait() do 
                    if library.pointers["Ambient Color"]:Get() then
                        Lighting.ColorCorrection.TintColor = library.pointers["Ambient_Color"]:Get().Color
                    else
                        Lighting.ColorCorrection.TintColor = Color3.fromRGB(255, 255, 255)
                    end
                end
            end)
        end})


        Script.Variables.Crosshair:Toggle({Name = "Enable", Default = false, Pointer = "CrossEnabled", callback = function()
            for i = 1, #crosshair_Lines do
                crosshair_Lines[i].Visible = false; 
            end 
            --
            for i = 1, #crosshair_Outlines do
                crosshair_Outlines[i].Visible = false; 
            end 
        end}):Colorpicker({Pointer = "Crossair_Color", callback = function ()
            for i = 1, #crosshair_Lines do 
                crosshair_Lines[i].Color = library.pointers["Crossair_Color"]:Get().Color
                crosshair_Lines[i].Transparency =  (1 - library.pointers["Crossair_Color"]:Get().Transparency)
            end
        end})
        Script.Variables.Crosshair:Slider({Name = "Size", Min = 0, Max = 30, Default = 12, Decimals = 1, Pointer = "Crossair_Size"})
        Script.Variables.Crosshair:Slider({Name = "Gap", Min = 0, Max = 30, Default = 12, Decimals = 1, Pointer = "Crossair_Gap"})
        Script.Variables.Crosshair:Slider({Name = "Thickness", Min = 1, Max = 5, Default = 1, Decimals = 0.1, Pointer = "Crossair_Thickness", callback = function(Int)
            for i = 1, #crosshair_Lines do
                crosshair_Lines[i].Thickness = Int; 
                crosshair_Outlines[i].Thickness = Int; 
            end 
        end})
        Script.Variables.Crosshair:Slider({Name = "Sides", Min = 1, Max = 12, default = 4, Decimals = 1, Pointer = "Crosshair_Sides_Pointer"})

        Script.Variables.Crosshair:Toggle({Name = "Spin", Default = false, Pointer = "Spinning_Crosshair"})
        Script.Variables.Crosshair:Slider({Name = "Speed", Min = 0, Max = 24, Default = 12, Decimals = 0.1, Pointer = "Crossair_Speed"})
        Script.Variables.Crosshair:Toggle({Name = "On Target", Default = false, Pointer = "crosshair_onTarget"})
        Script.Variables.Crosshair:Toggle({Name = "Watermark", Default = false, Pointer = "crosshair_Watermark", callback = function(Bool)
            Domain1.Visible = Bool 
            Domain.Visible = Bool
        end})
        Script.Variables.Crosshair:Dropdown({Name = "Sizing Easing Style", Pointer = "Crosshair Sizing Easing Style", Options = {"Off", "Linear", "Cubic", "Quad", "Quart", "Quint", "Sine", "Exponential", "Back", "Bounce", "Elastic", "Circular"}, Default = "Off"})
        Script.Variables.Crosshair:Dropdown({Name = "Speed Easing Style", Pointer = "Crosshair Speed Easing Style", Options = {"Off", "Linear", "Cubic", "Quad", "Quart", "Quint", "Sine", "Exponential", "Back", "Bounce", "Elastic", "Circular"}, Default = "Off"})
        
        local MAT = {"Concrete","ForceField","Glass","Ice","LeafyGrass","Metal","Neon","Plastic",'SmoothPlastic','Snow'}
        Script.Variables.SelfWeapon:Toggle({Name = "Weapon Chams", Default = false, Pointer = "WeaponChams"}):Colorpicker({Pointer = "WeaponCColor", callback = Script.Functions.WeaponChams})
        Script.Variables.SelfWeapon:Dropdown({Name = "Material" , Options = MAT, Default = "Neon", Pointer = "WeaponCMaterial", callback = Script.Functions.WeaponChams})

        Script.Variables.Self:Toggle({Name = "Player Chams", Default = false, Pointer = "PlayerChams",  callback = Script.Functions.ClientChams}):Colorpicker({Pointer = "PlayerChamsColor", callback = Script.Functions.ClientChams})
        Script.Variables.Self:Dropdown({Name = "Material" , Options = MAT, Default = "Neon", Pointer = "PlayerCMaterial", callback = Script.Functions.ClientChams})
    end 
    
    do -- Players
    -- TW : Shit Code 
        local playerlist = Script.Variables.Players:PlayerList({})
        local Actions = Script.Variables.Players:Section({Name = "Main", Side = "Left", Size = 50, Fill = true})
        local savee = {}
        local function saveshit(Selection)
            if not savee[Selection] then
                savee[Selection] = {}
            end
            Insert(savee[Selection], {
                [1] = library.pointers["Whitelisted"]:Get(),
                [2] = library.pointers["Aimview"]:Get(),
                [3] = library.pointers["Spectate"]:Get()
            })
        end
        local function loadshit(Selection)
            library.pointers["Whitelisted"]:Set((savee[Selection] and savee[Selection][1]) or false)
            library.pointers["Aimview"]:Set((savee[Selection] and savee[Selection][2]) or false)
            library.pointers["Spectate"]:Set((savee[Selection] and savee[3]) or false)
        end
        Actions:Toggle({Name = "Whitelist", Def = false, Pointer = "Whitelisted", callback = function(state)
            local selectedPlayer = playerlist:GetSelection()[1]
            if selectedPlayer then
                if state then
                    if not Find(Script.Whitelisted, selectedPlayer) then
                        Insert(Script.Whitelisted, selectedPlayer)
                    end
                else
                    local index = Find(Script.Whitelisted, selectedPlayer)
                    if index then
                        Remove(Script.Whitelisted, index)
                    end
                end
            end
            saveshit(selectedPlayer)
        end})
    
        Actions:Toggle({Name = "Aimview", Def = false, Pointer = "Aimview", callback = function(state)
            local selectedPlayer = playerlist:GetSelection()[1]
            aimviewedbro = selectedPlayer
            saveshit(selectedPlayer)
        end}):Colorpicker({Pointer = "AimviewerColor"})
    
        Actions:Toggle({Name = "Spectate", Def = false, Pointer = "Spectate", callback = function(state)
            local selectedPlayer = playerlist:GetSelection()[1]
            if selectedPlayer and state then
                local con = Script.Connections.TargetRespawn 
                if con then
                    con:Disconnect()
                    Script.Connections.TargetRespawn = nil
                end
    
                if selectedPlayer.Character then
                    Workspace.CurrentCamera.CameraSubject = selectedPlayer.Character:FindFirstChild("Humanoid")
                end
    
                Script.Connections.TargetRespawn = selectedPlayer.CharacterAdded:Connect(function(Plr)
                    Workspace.CurrentCamera.CameraSubject = Players[Plr.Name].Character:WaitForChild("Humanoid")
                end)
            else
                local con = Script.Connections.TargetRespawn 
                if con then
                    con:Disconnect()
                    Script.Connections.TargetRespawn = nil
                end
                Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
            end
            saveshit(selectedPlayer)
        end})
    
        Actions:Button({Name = "Teleport To", Callback = function()
            local selectedPlayer = playerlist:GetSelection()[1]
            if selectedPlayer then
                Client.Character.HumanoidRootPart.CFrame = selectedPlayer.Character.HumanoidRootPart.CFrame
            end
        end})
    
        Actions:Button({Name = "Make Target", Callback = function()
            Target = playerlist:GetSelection()[1]
            if library.pointers["Spec"]:Get() and Target then
                local con = Script.Connections.TargetRespawn 
                if con then
                    con:Disconnect()
                    Script.Connections.TargetRespawn = nil
                end
    
                if Target.Character then
                    Workspace.CurrentCamera.CameraSubject = Target.Character:FindFirstChild("Humanoid")
                end
    
                Script.Connections.TargetRespawn = Target.CharacterAdded:Connect(function(Plr)
                    Workspace.CurrentCamera.CameraSubject = Players[Plr.Name].Character:WaitForChild("Humanoid")
                end)
            end
        end})
        
        playerlist.OnSelectionChanged.Event:Connect(function(Selection)
            pcall(function()
                local con = Script.Connections.TargetRespawn 
                if con then
                    con:Disconnect()
                    Script.Connections.TargetRespawn = nil
                    Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
                end
                loadshit(playerlist:GetSelection()[1])
            end)
        end)
        
        local Extra = Script.Variables.Players:Section({Name = "Extra", Side = "Right", Size = 50, Fill = true})
        Extra:Label({Name = "Server ID"})
        Extra:TextBox({Default = game.JobId, Max = 200, Reactive = false, PlaceHolder = "Server ID"})
        
        Extra:Button({Name = "Join Server", Callback = function()
            local serverId = library.pointers["Server ID"]:Get()
            if serverId then
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, serverId)
            end
        end})
    
        Extra:Button({Name = "Rejoin Server", Callback = function()
            game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
        end})
    end
    

    do -- Config
        local Config_Menu = Script.Variables.Settings:Section({Name = ("Menu")})
        local Config_Configuration = Script.Variables.Settings:Section({Name = ("Configuration"), Side = "Right"})
        local Config_Theme = Script.Variables.Settings:Section({Name = ("theme")})
        local Config_Load = Script.Variables.Settings:Section({Name = ("Load"), Fill = true, Side = "Right"})
        local Config_Extra = Script.Variables.Settings:Section({Name = ("Extra"), Fill = true})
        --
        Config_Menu:Keybind({Name = ("Toggle"), Default = Enum.KeyCode.Insert, KeybindName = ("Menu Key"), Mode = "Toggle", Callback = function(Input, Active) Script.Variables.Window.uibind = Input end, Pointer = "ConfigMenu_MenuToggle", nothanks = true})

        Config_Configuration:List({Options = ETHH.Configs, Pointer = "ConfigConfiguration_Box"}) 
        Config_Configuration:TextBox({Name = ("Config Name"), Default = "", Max = 20, PlaceHolder = "Config Name", Callback = function(Text) end, Pointer = "ConfigConfiguration_Name"})
        Config_Configuration:ButtonHolder({Buttons = {{"Create", function() library.PerformConfigAction(library.pointers["ConfigConfiguration_Name"]:Get(), "Save") end}, {"Delete", function() library.PerformConfigAction(library.pointers["ConfigConfiguration_Box"]:Get(), "Delete") end}}})
        Config_Configuration:ButtonHolder({Buttons = {{"Load", function() library.PerformConfigAction( library.pointers["ConfigConfiguration_Box"]:Get(), "Load") end},{"Save", function() library.PerformConfigAction(library.pointers["ConfigConfiguration_Box"]:Get(), "Save") end}}})
        Config_Configuration:Button({Name = ("Refresh"), Callback = function()
            local currentConfigs = {}
    
            for Index, Value in pairs(listfiles("ethh.lol/Configs/" .. ETHH.Version)) do
                local extracted = tostring(Value):match("([^/\\]+)%.lua$")
                if extracted ~= nil then
                    if string.find(extracted, "Hvh Gui" ) then
                        extracted = extracted:gsub("^Hvh Gui\\", "")
                    end
                end
                Insert(currentConfigs, extracted)
                
                if not Find(ETHH.Configs, extracted) then
                    Insert(ETHH.Configs, extracted)
                end
            end
    
            for i = #ETHH.Configs, 1, -1 do
                if not Find(currentConfigs, ETHH.Configs[iF]) then
                    Remove(ETHH.Configs, i)
                end
            end
    
            library:RefreshConfigList()
        end})
        --
        Config_Theme:Dropdown({Name = ("theme"), Pointer = "ConfigTheme_Theme", Default = "Default", Max = 8, Options = utility:GetTableIndexes(Themes, true)})
        Config_Theme:Button({Name = ("Load"), Callback = function() library:LoadTheme(library.pointers["ConfigTheme_Theme"]:Get()) end})
        Config_Theme:Colorpicker({Name = ("Accent"), Default = Color3.fromRGB(93, 62, 152), Callback = function(Color) library:UpdateColor("Accent", Color) end, Pointer = "ConfigTheme_Accent"})
        Config_Theme:Colorpicker({Name = ("Light Contrast"), Default = Color3.fromRGB(30, 30, 30), Callback = function(Color) library:UpdateColor("LightContrast", Color) end, Pointer = "ConfigTheme_LightContrast"})
        Config_Theme:Colorpicker({Name = ("Dark Contrast"), Default = Color3.fromRGB(20, 20, 20), Callback = function(Color) library:UpdateColor("DarkContrast", Color) end, Pointer = "ConfigTheme_DarkContrast"})
        Config_Theme:Colorpicker({Name = ("Outline"), Default = Color3.fromRGB(0, 0, 0), Callback = function(Color) library:UpdateColor("Outline", Color) end, Pointer = "ConfigTheme_Outline"})
        Config_Theme:Colorpicker({Name = ("Inline"), Default = Color3.fromRGB(50, 50, 50), Callback = function(Color) library:UpdateColor("Inline", Color) end, Pointer = "ConfigTheme_Inline"})
        Config_Theme:Colorpicker({Name = ("Light Text"), Default = Color3.fromRGB(255, 255, 255), Callback = function(Color) library:UpdateColor("TextColor", Color) end, Pointer = "ConfigTheme_LightText"})
        Config_Theme:Colorpicker({Name = ("Dark Text"), Default = Color3.fromRGB(175, 175, 175), Callback = function(Color) library:UpdateColor("TextDark", Color) end, Pointer = "ConfigTheme_DarkText"})
        Config_Theme:Colorpicker({Name = ("Text Outline"), Default = Color3.fromRGB(0, 0, 0), Callback = function(Color) library:UpdateColor("TextBorder", Color) end, Pointer = "ConfigTheme_TextBorder"})
        Config_Theme:Colorpicker({Name = ("Cursor Outline"), Default = Color3.fromRGB(10, 10, 10), Callback = function(Color) library:UpdateColor("CursorOutline", Color) end, Pointer = "ConfigTheme_CursorOutline"})
        Config_Theme:Dropdown({Name = ("Accent Effect"), Default = "None", Options = {"None", "Rainbow", "Shift", "Reverse Shift"}, Callback = function(State) if State == "None" then library:UpdateColor("Accent", library.pointers["ConfigTheme_Accent"]:Get()) end end, Pointer = "ConfigTheme_AccentEffect"})
        Config_Theme:Slider({Name = ("Effect Length"), Default = 40, Maximum = 360, Minimum = 1, Decimals = 1, Pointer = "ConfigTheme_EffectLength"})
        --
        Config_Load:Toggle({Name = ("Show Menu"), Default = true, Pointer = "ConfigLoad_ShowMenu"})
        Config_Load:Toggle({Name = ("Auto Load Config"), Default = false, Pointer = "ConfigLoad_AutoLoad"})
        --
        Config_Extra:Toggle({Name = ("Show Watermark"), Default = false, Callback = function(State) Script.Variables.Window.watermark:Update("Visible", State) end, Pointer = "ConfigExtra_Watermark"})
        Config_Extra:Toggle({Name = ("Show Keybinds"), Callback = function(State) Script.Variables.Window.keybindslist:Update("Visible", State) end, Pointer = "ConfigExtra_KBList"})
        --Config_Extra:Toggle({Name = ("Show Target Indicator"), Callback = function(State) Script.Variables.Window.targetindicator:Update("Visible", State) end, Pointer = "ConfigExtra_TBList"})
        Config_Extra:Toggle({Name = ("Show Statuses"), Callback = function(State) Script.Variables.Window.statuslist:Update("Visible", State) end, Pointer = "ConfigExtra_StatusList"})
    end
    --[[(function ()
        do-- lua's
            local ethh = {}
            do-- The fucking api
                ethh.Connections = {}
                
                function ethh:GetSilentTarget()
                    return Target
                end

                --function ethh:GetCurrentPage()
                --    return Script.Variables.Luas
                --end
                
                function ethh:CreateConnection(Method,Callback)
                    local Connexion = Method(Callback)
                    Insert(self.Connections[library.pointers["LuaBox"]:Get()],Connexion)
                    return Connexion
                end

                function ethh:GetPointer(Poiter, mode)
                    if mode then
                        return library.pointers[Poiter]:Active()
                    else
                        return library.pointers[Poiter]:Get()
                    end
                end

                function ethh:SetPointer(Pointer, Value)
                    library.pointers[Pointer]:Set(Value)
                end

                getgenv().ethh = ethh
            end
            Script.Variables.lualist = Script.Variables.Luas:Section({Name = "Lua's", Side = "Left"})
            Script.Variables.lualist:List({Options = ETHH.Luas, Pointer = "LuaBox"})

            Script.Variables.lualist:Button({Name = "load", Callback = function ()
                local LuaName = library.pointers["LuaBox"]:Get()
                local LuaFilePath = ("ethh.lol/Luas/%s"):format(LuaName .. ".lua")
                if LuaFilePath then
                    loadstring(readfile(LuaFilePath))()
                end
            end})
            Script.Variables.lualist:Button({Name = "Unload", Callback = function ()
                --unload the fucking lua
                for i, v in pairs(ethh.Connections[library.pointers["LuaBox"]:Get()]) do
                    v:Disconect()
                end
                ethh.Connections[library.pointers["LuaBox"]:Get()] = nil

            end})
        end
    end)()]]
    library:LoadTheme(library.pointers["ConfigTheme_Theme"]:Get()) 
    Script.Variables.Window:Initialize()
end


Script.Functions.CFrameSpeed = function(deltatime)
    if library.pointers["IsCframeActive"]:Active() and library.pointers["CFRAMESPEED"]:Get() then
        if Client.Character and Client.Character:FindFirstChild("Humanoid") then
            local humanoid = Client.Character.Humanoid
            if humanoid.MoveDirection.Magnitude > 0 then
                for i = 1, (library.pointers["CFRAMESPEED VALUE"]:Get() / 10) * (deltatime * 60) do
                    if not library.pointers["CFRAMESPEED"]:Get() and library.pointers["IsCframeActive"]:Active() then
                        break
                    end
                    Client.Character:TranslateBy(humanoid.MoveDirection)
                end
            end
        end
    end 
end

local Shift = LPH_NO_VIRTUALIZE(function (Number)
    return Acos(Cos(Number * Pi)) / Pi
end)

local oldSides = nil
local setsides = LPH_NO_VIRTUALIZE(function ()
    local Int = tonumber(library.pointers["Crosshair_Sides_Pointer"]:Get())
    if Int ~= oldSides then
        oldSides = Int
        crosshair_lineOffsets = generateAngles(Int)
        for i = 1, #crosshair_Lines do
            crosshair_Lines[i]:Remove()
            crosshair_Lines[i] = nil
        end
        for i = 1, #crosshair_Outlines do
            crosshair_Outlines[i]:Remove()
            crosshair_Outlines[i] = nil
        end
        do 
            for Index = 1, Int do
                local line = Script.Functions.NewDrawing("Line",{
                    Visible = false,
                    Color = library.pointers["Crossair_Color"]:Get().Color,
                    Thickness = library.pointers["Crossair_Thickness"]:Get(),
                    ZIndex = 2,
                    Transparency = (1 - library.pointers["Crossair_Color"]:Get().Transparency)
                })
                crosshair_Lines[Index] = line

                local line_1 = Script.Functions.NewDrawing("Line",{
                    Visible = false,
                    Color = Color3.fromRGB(0, 0, 0),
                    Thickness = library.pointers["Crossair_Thickness"]:Get(),
                    ZIndex = 1,
                    Transparency = 1
                })
                crosshair_Outlines[Index] = line_1
            end
        end
    end
end)

local nojumpcooldown = LPH_NO_VIRTUALIZE(function ()
    local humanoid = Client.Character:FindFirstChildOfClass("Humanoid")
    local con = Script.Connections.NoJumpCoolDown
    if con then
        con:Disconnect()
        Script.Connections.NoJumpCoolDown = nil
    end
    Script.Connections.NoJumpCoolDown = Uis.JumpRequest:Connect(function()
        if humanoid:GetState() == Enum.HumanoidStateType.Running 
        or humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics
        or humanoid:GetState() == Enum.HumanoidStateType.Climbing 
        or humanoid:GetState() == Enum.HumanoidStateType.Seated then
            humanoid.JumpPower = 50 
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping) 
        end
    end)
end)

local maintainWalkSpeed = LPH_NO_VIRTUALIZE(function()
    local humanoid = Client.Character:FindFirstChildOfClass("Humanoid")
    local minWalkSpeed = 16
    humanoid.WalkSpeed = Max(humanoid.WalkSpeed, minWalkSpeed)
    local con = Script.Connections.NoSlowDown
    if con then
        con:Disconnect()
        Script.Connections.NoSlowDown = nil
    end

    Script.Connections.NoSlowDown = RS.Heartbeat:Connect(function()
        if Uis:IsKeyDown(Enum.KeyCode.LeftShift) then
            minWalkSpeed = 22
        else
            minWalkSpeed = 16
        end
        if humanoid.WalkSpeed < minWalkSpeed then
            humanoid.WalkSpeed = minWalkSpeed
        end
    end)
    local con2 = Script.Connections.NoSlowDown2
    if con2 then
        con2:Disconnect()
        Script.Connections.NoSlowDown2 = nil
    end
    Script.Connections.NoSlowDown2 = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if humanoid.WalkSpeed < minWalkSpeed then
            humanoid.WalkSpeed = minWalkSpeed
        end
    end)
end)

local errors = {}
Script.Connections.TargetStuff = RS.Heartbeat:connect(LPH_NO_VIRTUALIZE(function(DeltaTime)
    if not (Client and Client.Parent) then return end

    if library.pointers["AutoSelection"]:Get() then
        pcall(Script.Functions.GetTarget)
    end

    if Target and Target.Parent and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
        pcall(Script.Functions.unlockk)

        local tool = Target.Character:FindFirstChildWhichIsA("Tool")
        local ammoValue = (tool and tool:FindFirstChild("Ammo")) and tool.Ammo.Value or 0
        local isknocked = Script.Functions.Knocked_Check(Target)
        local isdead = Script.Functions.Death_Check(Target)
        Script.Variables.Window.targetindicator:UpdateFields({
            Display = Target.DisplayName,
            UserName = Target.Name,
            Knocked = isknocked,
            AntiLocking = "[False]",
            Health = Floor(Target.Character.Humanoid.Health),
            Armor = Floor(Target.Character:FindFirstChild("BodyEffects") and Target.Character.BodyEffects.Armor.Value) or 0,
            Ammo = ammoValue
        })

        if library.pointers["Resolver"]:Get() then
            Resolver:GetVelocity(Target, DeltaTime)
            Resolver:ResolveVoidTp()
        end

        Script.Functions.CalculateEndpoint(DeltaTime)
        Resolver:RecordPlayerPosition(Target)

        if library.pointers["Backtrack"]:Get() then
            local backtrackedPos = Resolver:GetBacktrackPosition(Target)
            Script.Variables.Backtrackedpos = backtrackedPos
            if backtrackedPos and library.pointers["Visualise Backtrack"]:Get() then
                Resolver:BacktrackPlayer(Target, backtrackedPos)
            end
        end

        if library.pointers["TargetStrafe"]:Active() then
            local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
            local shouldStomp = library.pointers["autostomp"]:Get() and not isknocked and not isdead and not Target.Character:FindFirstChild("GRABBING_CONSTRAINT")
            local clientBodyEffects = Client.Character.BodyEffects

            if not shouldStomp then
                Script.Functions.TargetStrafe()
            elseif not (clientBodyEffects.Reload.Value or clientBodyEffects.Attacking.Value) then
                if library.pointers["TRASHTALK"]:Get() ~= "Off" then
                    Script.Functions.Trashtalk()
                end
                if library.pointers["Automatic_fire"]:Get() and Client.Character:FindFirstChildWhichIsA("Tool") then
                    Client.Character:FindFirstChildWhichIsA("Tool"):Deactivate()
                end
                Script.Functions.stomptarget()
            end
        end

        local clientTool = Client.Character:FindFirstChildWhichIsA("Tool")
        if library.pointers["Automatic_fire"]:Get() and clientTool and clientTool:FindFirstChild("Ammo") then
            local checks = library.pointers["Checks"]:Get()
            local canFire = not isdead and isknocked
            if canFire then
                pcall(clientTool.Activate, clientTool)
            end
        end

        if library.pointers["LookATTarget"]:Get() then
            local hrp = Client.Character.HumanoidRootPart
            local targetPosition = Target.Character.HumanoidRootPart.Position
            hrp.CFrame = CFrame.lookAt(hrp.Position, Vector3.new(targetPosition.X, hrp.Position.Y, targetPosition.Z))
        end
    end
end))


Script.Connections.MainLoop = RS.Heartbeat:connect(LPH_NO_VIRTUALIZE(function(DeltaTime)
    local suc, err = pcall(function()
        do 
            if tick() - antiCheattick > 1 and Client.Character then 
                antiCheattick = tick()
                for _, Script in pairs(Client.Character:GetChildren()) do
                    if Script:IsA("Script") and Script.Name ~= "Health" and Script.Name ~= "Sound" and Script:FindFirstChild("LocalScript") then
                        Script:Destroy()
                    end
                end
            end 	
        end 
        do
            Script.Functions.AutoArmor()
            Script.Functions.AutoFireArmor()
            Script.Functions.Aimview()
            Script.Functions.Rolls()
            Script.Functions.Async()
            Script.Functions.Velocityaa()
            Script.Functions.CalculateServerSide()
            Script.Functions.AntiStomp()
            Script.Functions.AutoBlock()
            Script.Functions.AntiMoveDirection()
            Spawn(Script.Functions.Desync)
            Spawn(Script.Functions.AnimationLag)
            Spawn(Script.Functions.CombinedRocketHandler)
        end
    end)
    if not suc then
        local info = debug.getinfo(2, "Sl")
        local line = info and info.currentline or "unknown"
        local source = info and info.short_src or "unknown"

        local detailed_error = string.format("[ERROR] %s\nSource: %s, Line: %s", err, source, line)
        if not Find(errors, detailed_error) then
            Insert(errors, detailed_error)
            print(detailed_error)
        end
    end
end))

Script.Connections.RandomTp = RS.PostSimulation:connect(Script.Functions.RandomTP)

Script.Connections.Movements = RS.PreSimulation:Connect(LPH_NO_VIRTUALIZE(function(DeltaTime)
    local suc, err = pcall(function()
        Script.Functions.fly(DeltaTime)
        Script.Functions.CFrameSpeed(DeltaTime)
    end)
    if not suc then
        local info = debug.getinfo(2, "Sl")
        local line = info and info.currentline or "unknown"
        local source = info and info.short_src or "unknown"

        local detailed_error = string.format("[ERROR] %s\nSource: %s, Line: %s", err, source, line)
        if not Find(errors, detailed_error) then
            Insert(errors, detailed_error)
            print(detailed_error)
        end
    end
end))

Script.Connections.Visuals = RS.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function(Fps)
    local suc, err = pcall(function()
        library:UpdateHue()
        Script.Functions.UpdateFov()
        Script.Functions.UpdateESP()
        Script.Functions.UpdateAimbotVisual()
        setsides()
            -- // Crosshair Visuals
        do 
            crosshair_SpinAngle = library.pointers["Spinning_Crosshair"]:Get() and crosshair_SpinAngle + Rad((library.pointers["Crossair_Speed"]:Get() * 10) * Fps) or 0;  
            -- // Crosshair 
            local Position, OnScreen
            if Target and Target.Character ~= nil then
                Position, OnScreen = Camera:WorldToViewportPoint(Target.Character.HumanoidRootPart.Position);
            end
            do
                if library.pointers["CrossEnabled"]:Get() then 
                    local Radius = library.pointers["Crossair_Size"]:Get() * 5
                    local Gap = library.pointers["Crossair_Gap"]:Get()
                    local Origin
                    --
                    if library.pointers["crosshair_onTarget"]:Get() and Target ~= nil and Target.Character and OnScreen then 
                        Origin = Vector2.new(Position.X, Position.Y)
                    else 
                        Origin = Vector2.new(Mouse.X, Mouse.Y + GuiService:GetGuiInset().Y)
                    end 
                    -- 
                    CursorSize += 0.025
                    -- 
                    local SmoothAngle = library.pointers["Crosshair Speed Easing Style"]:Get() ~= "Off" and Tween.EasingStyles[Enum.EasingStyle[library.pointers["Crosshair Speed Easing Style"]:Get()]][Enum.EasingDirection.InOut](Shift(crosshair_SpinAngle)) * (Pi * Pi/2) or crosshair_SpinAngle
                    local Dynamic = Cos(CursorSize)
                    local SmoothSize =  library.pointers["Crosshair Sizing Easing Style"]:Get() ~= "Off" and ((Radius / 2) * (Tween.EasingStyles[Enum.EasingStyle[library.pointers["Crosshair Sizing Easing Style"]:Get()]][Enum.EasingDirection.In](Shift(Dynamic)))) or 0 
                    local localRadius = Radius - SmoothSize
                    --
                    for i = 1, #crosshair_Lines do 
                        local Positions = Vector2.new(Cos(SmoothAngle + crosshair_lineOffsets[i]), (Sin(SmoothAngle + crosshair_lineOffsets[i])))
                        -- 
                        crosshair_Lines[i].From = Origin + Vector2.new(Positions.X, Positions.Y) * Gap 
                        crosshair_Lines[i].To = crosshair_Lines[i].From + Vector2.new(Positions.X, Positions.Y) * localRadius
                        -- 
                        crosshair_Outlines[i].From = Origin + Vector2.new(Positions.X, Positions.Y) * (Gap - 1)
                        crosshair_Outlines[i].To = crosshair_Lines[i].From + Vector2.new(Positions.X, Positions.Y) * (localRadius + 1)
                        -- 
                        crosshair_Lines[i].Visible = true 
                        crosshair_Outlines[i].Visible = true 
                    end 
                    pcall(function()
                        Client.PlayerGui.MainScreenGui.Aim.Visible = false 

                    end)
                end 
            end 
            -- // Crosshair Text 
            do
                if library.pointers["crosshair_Watermark"]:Get() then
                    local yOffset = library.pointers["CrossEnabled"]:Get() and ((library.pointers["Crossair_Size"]:Get() * 5) + library.pointers["Crossair_Gap"]:Get()) or 30
                    -- 
                    local textOrigin; 
                    if library.pointers["crosshair_onTarget"]:Get() and Target ~= nil and Target.Character and OnScreen then 
                        textOrigin = Vector2.new(Position.X - 23, Position.Y + yOffset)
                    else 
                        textOrigin = Vector2.new(Mouse.X - 23, Mouse.Y + GuiService:GetGuiInset().Y + yOffset)
                    end 
                    -- 
                    Domain1.Visible = true 
                    Domain.Visible = true    
                    -- 
                    
                    Domain1.Position = textOrigin
                    Domain.Position = Domain1.Position + Vector2.new(Domain1.TextBounds.X, 0)
                end 
                -- 
            end
            if Games[game.PlaceId].Bullet_Path then -- // hit detection
                local Gun = Client.Character:FindFirstChildWhichIsA("Tool")
                local Connection = Script.Connections.Detections
                local HealthChangedConnection = Script.Connections.HealthChangedConnection
                if Gun ~= PreviousGun and Connection then
                    PreviousGun = Gun
                    PreviousAmmo = 999
                    Connection:Disconnect()
                    Script.Connections.Detections = nil
                end
                if Gun ~= PreviousGun and HealthChangedConnection then
                    HealthChangedConnection:Disconnect()
                    Script.Connections.HealthChangedConnection = nil
                end
                if not Script.Connections.Detections and Gun and Gun:FindFirstChild("Ammo") and Gun.Ammo.Value then
                    if library.pointers["Auto reload"]:Get() then
                        Spawn(Script.Functions.autoreload)
                    end
                    Script.Connections.Detections = Gun.Ammo:GetPropertyChangedSignal("Value"):Connect(function()
                        if library.pointers["Auto reload"]:Get() then
                            Spawn(Script.Functions.autoreload)
                        end
    
                        local CurrentAmmo = Gun.Ammo.Value
                        if CurrentAmmo < PreviousAmmo then
                            local ChildrenAdded = 0
                            local ChildAdded
                            local IgnoreList = {Client.Character, Gun.Handle}
                            ChildAdded = Games[game.PlaceId].Bullet_Path.ChildAdded:Connect(function(Object)
                                if Object.Name == Games[game.PlaceId].bullet_name then
                                    ChildrenAdded += 1
                                    if (Find({"[Double-Barrel SG]", "[TacticalShotgun]", "[Shotgun]"}, Gun.Name) and ChildrenAdded <= 5) or (ChildrenAdded == 1) then
                                        local Pos = Object.CFrame.Position
                                        local LookVector = Object.CFrame.LookVector
                                        local RayCastParams = RaycastParams.new()
                                        RayCastParams.FilterType = Enum.RaycastFilterType.Exclude
                                        RayCastParams.IgnoreWater = true
                                        RayCastParams.FilterDescendantsInstances = IgnoreList
                                        local Ray = Workspace:Raycast(Pos, LookVector * 1000, RayCastParams)
    
                                        if not Ray then return end
    
                                        local HitInstance = Ray.Instance
                                        local HitPosition = Ray.Position
                                        delay(0.001, function()
                                            if library.pointers["BulletTracer"]:Get() then
                                                Object:Destroy()
                                                Script.Functions.CreateBeam(Pos, HitPosition)
                                            end
    
                                            if library.pointers["ShowBulleti"]:Get() then
                                                local part = Instance.new("Part")
                                                part.Name = "Hit Impact"
                                                part.Anchored = true
                                                part.CanCollide = false 
                                                part.Shape = Enum.PartType.Block
                                                part.Color = library.pointers["BulletIColor"]:Get().Color
                                                part.Parent = Workspace
                                                part.Transparency = 0
                                                part.Material = "Neon"
                                                part.Size = Vector3.new(0.5, 0.5, 0.5)
                                                part.CFrame = CFrame.new(HitPosition)
                                                Delay(library.pointers["Bullet Life time"]:Get(), function()
                                                    part:Destroy()
                                                end)
                                            end
    
                                            if HitInstance then
                                                local InstanceHit = HitInstance:FindFirstAncestorOfClass('Model')
                                                if not InstanceHit then return end 
                                                local Humanoid = InstanceHit:FindFirstChild("Humanoid")
                                                if Humanoid and InstanceHit:FindFirstChild("HumanoidRootPart") and InstanceHit.Parent ~= Workspace.Folder and InstanceHit.Name ~= Client.Name then
                                                    if not Script.StoredHealth[Players[InstanceHit.Name]] then
                                                        Script.StoredHealth[Players[InstanceHit.Name]] = Humanoid.Health
                                                    end
                                                    local HealthChange = Abs(Script.StoredHealth[Players[InstanceHit.Name]] - Humanoid.Health)
                                                        -- // on hit
                                                    if library.pointers["NotfiyHit"]:Get() then
                                                        Notify('<font color="#ffffff">ethh</font><font color="#5c5c5c">.</font><font color="#F9A8FB">lol</font> >> +1 Hit | ' .. tostring(HitInstance.Name) .. ' | Target : ' .. InstanceHit.Name .. ' |  '.. Floor(HealthChange) .." damage", 1.5)
                                                    end
                                                    if library.pointers["Hitsound"]:Get() then
                                                        Script.Functions.HitSound()
                                                    end
                                                    if library.pointers["HitEffect"]:Get() and Find(library.pointers["Effects"]:Get(),"Clone") then
                                                        Script.Functions.CreateClone(InstanceHit)
                                                    end
                                                    if library.pointers["HitEffect"]:Get() and Find(library.pointers["Effects"]:Get(),"Confetti") then
                                                        Script.Functions.CreateConfetti(InstanceHit)
                                                    end
                                                    if library.pointers["HitEffect"]:Get() and Find(library.pointers["Effects"]:Get(),"Pulse") then
                                                        Script.Functions.Pulse(InstanceHit)
                                                    end
                                                    Script.StoredHealth[Players[InstanceHit.Name]] = Humanoid.Health
                                                end
                                            end
                                            ChildAdded:Disconnect()
                                        end)
                                    end
                                else
                                    ChildAdded:Disconnect()
                                end
                            end)
                        end
                        PreviousAmmo = CurrentAmmo
                    end)
                end
            end
        
        end
    end)
if not suc then
       if not Find(errors, err) then
            Insert(errors, err)
            print(err)
        end
    end
end))

if hookmetamethod then
    local SilentHook
    SilentHook = hookmetamethod(game, "__index",  LPH_NO_VIRTUALIZE(newcclosure(function(self, index)
        if not checkcaller() and library.pointers["AimbotMain_Enabled"]:Get() and self == Mouse and index == "Hit" and Target and Target.Parent then
            if EndPoint then
                return (index == "Hit" and CFrame.new(EndPoint))
            end
        end
        return SilentHook(self, index)
    end)))
    
    if getcallingscript then
        local Framework = Client.PlayerGui:FindFirstChild('Framework')
        local newindex
        newindex = hookmetamethod(game, '__newindex',  LPH_NO_VIRTUALIZE(newcclosure(function(self, key, value)
            local calling_script = getcallingscript()
    
            -- // No recoil
            if library.pointers["Norecoil"]:Get() and Framework and calling_script == Framework and self:IsA('Camera') and key == 'CFrame' then
                return
            end
    
            return newindex(self, key, value)
        end)))
    end
    local newindex; newindex = hookmetamethod(game, '__newindex', LPH_NO_VIRTUALIZE(function(self, key, value)            
        -- // No slowdown
        if key == 'WalkSpeed' and value < 16 then 
            value = 16
        end

        if not checkcaller() and game.IsA(self, "Humanoid") and key == "JumpPower" then 
            return
        end
        
        return newindex(self, key, value)
    end))
    local CSyncIndex
    CSyncIndex = hookmetamethod(game, "__index",  LPH_NO_VIRTUALIZE(newcclosure(function(Self, Index)
        local checks = {
            rollss = library.pointers["Rollss"]:Get(),
            randomTP2 = library.pointers["RandomTP2"]:Active() and library.pointers["RandomTP"]:Get(),
            TargetStrafe = Target ~= nil and library.pointers["Server_sided"]:Get() and library.pointers["TargetStrafe"]:Active(),
            void = library.pointers["Void 1"]:Get() and library.pointers["Void 2"]:Active(),
        }
        local desyncCondition = checks.rollss or checks.randomTP2 or checks.TargetStrafe
    
        if not checkcaller() and desyncCondition and Script.Desync["Old_CFrame"] ~= nil and Index == "CFrame" and Self == Client.Character.HumanoidRootPart then
            return Script.Desync["Old_CFrame"]
        end
    
        return CSyncIndex(Self, Index)
    end)))
    
    local CSyncIndex2
    CSyncIndex2 = hookmetamethod(game, "__index",  LPH_NO_VIRTUALIZE(newcclosure(function(Self, Index)
        if not checkcaller() and Script.Desync.ClientLocation and Index == "CFrame" and Self == Client.Character.HumanoidRootPart then
            return Script.Desync.ClientLocation
        end
    
        return CSyncIndex2(Self, Index)
    end)))
    
else
    local part = Instance.new("Part")
    part.Name = "CameraFocusPart"
    part.Size = Vector3.new(1, 1, 1) 
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Parent = workspace
    -- // Silent aim
    RS.Heartbeat:connect(LPH_NO_VIRTUALIZE(function()
        if Target and library.pointers["AimbotMain_Enabled"]:Get() then
            Script.Functions.FireEndpoint()
        end
    end))
    -- // camera fix
    Script.Connections.CameraFix = RS.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
        local con = Script.Connections.TargetRespawn
        if con then return end

        local checks = {
            rollss = library.pointers["Rollss"]:Get(),
            randomTP2 = library.pointers["RandomTP2"]:Active() and library.pointers["RandomTP"]:Get(),
            TargetStrafe = Target ~= nil and library.pointers["Server_sided"]:Get() and library.pointers["TargetStrafe"]:Active(),
            void = library.pointers["Void 1"]:Get() and library.pointers["Void 2"]:Active(),
        }
        local desyncCondition = checks.rollss or checks.randomTP2 or checks.TargetStrafe

        if Client.Character and desyncCondition and Script.Desync["Old_CFrame"] ~= nil and Client.Character:FindFirstChild("HumanoidRootPart") and Client.Character:FindFirstChild("Humanoid") and Client.Character:FindFirstChild("Humanoid").Health > 0 then
            part.CFrame = Script.Desync["Old_CFrame"] * CFrame.new(0, 2.1, 0)
            Workspace.CurrentCamera.CameraSubject = part
        end
        
        if Client.Character and Script.Desync.ClientLocation then
            part.CFrame = Script.Desync.ClientLocation * CFrame.new(0, 2.1, 0)
            Workspace.CurrentCamera.CameraSubject = part
        end

        if not desyncCondition and not Script.Desync.ClientLocation then
            if Client.Character and Client.Character:FindFirstChild("Humanoid") and Workspace.CurrentCamera.CameraSubject ~= Client.Character.Humanoid then
                Workspace.CurrentCamera.CameraSubject = Client.Character.Humanoid
            end
        end
    end))
end



local lastcheck = tick()

Script.Functions.CheckIfMod = function(Plr)
    spawn(function()
        repeat
            Wait()
        until game.Players:FindFirstChild(Plr.Name) and (tick() - lastcheck) > 2
        lastcheck = tick()
        
        if MarketplaceService:GetProductInfo(game.PlaceId).Creator.CreatorType == "Group" then
            local GetId = cloneref(game:GetService("GroupService")):GetGroupInfoAsync(MarketplaceService:GetProductInfo(game.PlaceId).Creator.CreatorTargetId).Id
            local GroupId = tonumber(GetId)
            local isingroup = Plr:IsInGroup(GroupId)
            local grouprank = Plr:GetRankInGroup(GroupId)
            local grouprole = Plr:GetRoleInGroup(GroupId)
            local flagged = false 

            if SFind(Plr.DisplayName, "🛡️") or SFind(Plr.DisplayName, "👑") then
                print("Flagged for special display name: " .. Plr.DisplayName)
                flagged = true
            end

            if isingroup and grouprole ~= "Member" then
                print("Flagged for group role: " .. grouprole)
                flagged = true
            end
            
            if grouprank > 1 then
                print("Flagged for group rank: " .. grouprank)
                flagged = true
            end
            
            if flagged then
                print("Admin detected: " .. Plr.Name)
                Notificationslib:New(("Admin detected: " .. Plr.Name), 5, Color3.fromRGB(255, 0, 0))
            end
        end
    end)
end



Script.Functions.OnChildAdded = function(Child)
    if library.pointers["Auto reload"]:Get() then
        Spawn(function()
            Script.Functions.autoreload()
        end)
    end
    Script.Functions.WeaponChams()
end

local GetName = LPH_NO_VIRTUALIZE(function(query)
    local targett = query
    local fittest3 = nil
    local fittest2 = nil
    local notit = {}
    local notit2 = {}
    local lenpls = Len(targett)
    local cflen = 0 
    local cf2len = 0
    for n = 1, tonumber(lenpls) do
        for _, i in pairs(Players:GetChildren()) do
            if Find(notit, i.Name) or i.Name == Client.Name then
                continue 
            end
            if Sub(i.Name, n, n):lower() == Sub(targett, n, n):lower() then
                fittest3 = i
                cflen += 1
            else
                Insert(notit, i.Name)
            end
        end 
        if n == lenpls then break end
    end
    for n = 1, tonumber(lenpls) do
        for _, i in pairs(Players:GetChildren()) do
            if Find(notit2, i.DisplayName) or i.DisplayName == Client.DisplayName then
                continue 
            end                     
            if Sub(i.DisplayName, n, n):lower() == Sub(targett, n, n):lower() then
                fittest2 = i
                cf2len += 1
            else
                Insert(notit2, i.DisplayName)
            end
        end 
        if n == lenpls then break end
    end
    if fittest3 and fittest2 then
        if cflen < cf2len then 
            fittest3 = fittest2
            fittest2 = nil
        elseif cflen > cf2len then
            fittest2 = nil
        elseif cflen == cf2len then 
            fittest3 = fittest2
            fittest2 = nil 
        end
    elseif fittest3 and not fittest2 then
            fittest2 = nil
    elseif not fittest3 and fittest2 then
        fittest3 = fittest2
        fittest2 = nil
    end
    return fittest3
end)

Client.CharacterAdded:Connect(function(Character)
    wait(1.5)
    local humanoid = Character:FindFirstChildOfClass("Humanoid")
    Floss = humanoid:LoadAnimation(a)
    Hype = humanoid:LoadAnimation(b)
    nojumpcooldown()
    maintainWalkSpeed()
    Script.Functions.PlayAnimation()
    Script.Functions.ClientChams()
    local con = Script.Connections.ChilAdded
    if con then
        con:Disconnect()
        Script.Connections.ChilAdded = nil
    end
    Script.Connections.ChilAdded = Character.ChildAdded:Connect(Script.Functions.OnChildAdded)
end)

if Client.Character then
    local con = Script.Connections.ChilAdded
    if con then
        con:Disconnect()
        Script.Connections.ChilAdded = nil
    end
    Script.Connections.ChilAdded = Client.Character.ChildAdded:Connect(Script.Functions.OnChildAdded)
end


Client.Chatted:Connect(function(Msg)
    local Splitted = Split(Msg, " ")
    local PrefixFound = Msg:sub(1, 1) == "$"
    if PrefixFound then
        local SplitChat = Msg:split(' ')
        if SplitChat[1]:lower():find('target') then
            Target = GetName(SplitChat[2])
            if not Target then return end
            
            Notificationslib:New("[ethh.lol] Locked on " .. Target.Name, 1.5, Color3.fromRGB(255, 102, 204))

            if library.pointers["Spec"]:Get() and Target then
                local con = Script.Connections.TargetRespawn 
                if con then
                    con:Disconnect()
                    Script.Connections.TargetRespawn = nil
                end
    
                if Target.Character then
                    Workspace.CurrentCamera.CameraSubject = Target.Character:FindFirstChild("Humanoid")
                end
    
                Script.Connections.TargetRespawn = Target.CharacterAdded:Connect(function(Plr)
                    Workspace.CurrentCamera.CameraSubject = Players[Plr.Name].Character:WaitForChild("Humanoid")
                end)
            end
        elseif SplitChat[1]:lower():find('tp') then
            local target = GetName(SplitChat[2])
            Client.Character.HumanoidRootPart.CFrame = target.Character.HumanoidRootPart.CFrame
        elseif SplitChat[1]:lower():find('clear') then
            if library.pointers["Automatic_fire"]:Get() and Client.Character:FindFirstChildWhichIsA("Tool")  then
                Client.Character:FindFirstChildWhichIsA("Tool"):Deactivate()
            end
            Resolver:CleanupBacktrack(Target)
            Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
            Resolver:ResetPlayerData(Target)
            Target = nil
            local con = Script.Connections.TargetRespawn 
            if con then
                con:Disconnect()
                Script.Connections.TargetRespawn = nil
                Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
            end
            stopblyat()
            bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))

            Notificationslib:New("[ethh.lol] Unlocked", 1.5, Color3.fromRGB(255, 102, 204))
        end
    end
end)

Players.PlayerRemoving:Connect(function(Plr)
    if Plr == Target then
        STOPSHIT = false
        Notificationslib:New("[ethh.lol] Unlocked", 1.5, Color3.fromRGB(255, 102, 204))
        Resolver:CleanupBacktrack(Target)
        Target = nil
        local con = Script.Connections.TargetRespawn 
        if con then
            con:Disconnect()
            Script.Connections.TargetRespawn = nil
            Workspace.CurrentCamera.CameraSubject = Client.Character:FindFirstChild("Humanoid")
        end
        stopblyat()
        Workspace.CurrentCamera.CameraSubject = Client.Character:WaitForChild("Humanoid")
        bodyClone:SetPrimaryPartCFrame(CFrame.new(9959,9999,9990))
    end
    if Find(Script.EspPlayers, Plr) then
        for _, v in pairs(Script.EspPlayers[Plr]) do
            if v ~= nil then
                v:Remove()
            end
        end
        Remove(Script.EspPlayers, Plr)
    end
end)
Players.PlayerAdded:Connect(function(Plr)
    Script.Functions.NewPlayer(Plr)
    Script.Functions.CheckIfMod(Plr)
end)
Spawn(function()
    while true do
        stat = not stat
        Wait((library.pointers and library.pointers["ASYNC TICK"] and library.pointers["ASYNC TICK"]:Get()) or 2)
    end
end)
nojumpcooldown()
maintainWalkSpeed()

end)()

--loadstring(game:HttpGet("https://raw.githubusercontent.com/alttobypassstuff/lua/main/codes"))()